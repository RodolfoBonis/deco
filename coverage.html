
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>deco: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/RodolfoBonis/deco/cmd/deco/main.go (0.0%)</option>
				
				<option value="file1">github.com/RodolfoBonis/deco/examples/security/protect_internal_endpoints.go (0.0%)</option>
				
				<option value="file2">github.com/RodolfoBonis/deco/examples/security_example.go (0.0%)</option>
				
				<option value="file3">github.com/RodolfoBonis/deco/pkg/decorators/cache.go (37.1%)</option>
				
				<option value="file4">github.com/RodolfoBonis/deco/pkg/decorators/circuit_breaker.go (90.5%)</option>
				
				<option value="file5">github.com/RodolfoBonis/deco/pkg/decorators/client_sdk.go (0.0%)</option>
				
				<option value="file6">github.com/RodolfoBonis/deco/pkg/decorators/config.go (80.3%)</option>
				
				<option value="file7">github.com/RodolfoBonis/deco/pkg/decorators/docs_handler.go (0.0%)</option>
				
				<option value="file8">github.com/RodolfoBonis/deco/pkg/decorators/generator.go (0.0%)</option>
				
				<option value="file9">github.com/RodolfoBonis/deco/pkg/decorators/health_checker.go (100.0%)</option>
				
				<option value="file10">github.com/RodolfoBonis/deco/pkg/decorators/load_balancer.go (94.5%)</option>
				
				<option value="file11">github.com/RodolfoBonis/deco/pkg/decorators/logging.go (100.0%)</option>
				
				<option value="file12">github.com/RodolfoBonis/deco/pkg/decorators/markers.go (75.3%)</option>
				
				<option value="file13">github.com/RodolfoBonis/deco/pkg/decorators/metrics.go (97.6%)</option>
				
				<option value="file14">github.com/RodolfoBonis/deco/pkg/decorators/minifier.go (91.9%)</option>
				
				<option value="file15">github.com/RodolfoBonis/deco/pkg/decorators/openapi.go (76.4%)</option>
				
				<option value="file16">github.com/RodolfoBonis/deco/pkg/decorators/parser.go (16.9%)</option>
				
				<option value="file17">github.com/RodolfoBonis/deco/pkg/decorators/plugin.go (71.1%)</option>
				
				<option value="file18">github.com/RodolfoBonis/deco/pkg/decorators/proxy.go (71.4%)</option>
				
				<option value="file19">github.com/RodolfoBonis/deco/pkg/decorators/rate_limiting.go (68.2%)</option>
				
				<option value="file20">github.com/RodolfoBonis/deco/pkg/decorators/registry.go (91.8%)</option>
				
				<option value="file21">github.com/RodolfoBonis/deco/pkg/decorators/runtime.go (43.6%)</option>
				
				<option value="file22">github.com/RodolfoBonis/deco/pkg/decorators/schemas.go (62.9%)</option>
				
				<option value="file23">github.com/RodolfoBonis/deco/pkg/decorators/security.go (100.0%)</option>
				
				<option value="file24">github.com/RodolfoBonis/deco/pkg/decorators/service_discovery.go (70.8%)</option>
				
				<option value="file25">github.com/RodolfoBonis/deco/pkg/decorators/telemetry.go (79.9%)</option>
				
				<option value="file26">github.com/RodolfoBonis/deco/pkg/decorators/test_helpers.go (100.0%)</option>
				
				<option value="file27">github.com/RodolfoBonis/deco/pkg/decorators/types.go (100.0%)</option>
				
				<option value="file28">github.com/RodolfoBonis/deco/pkg/decorators/validation.go (43.5%)</option>
				
				<option value="file29">github.com/RodolfoBonis/deco/pkg/decorators/watcher.go (58.7%)</option>
				
				<option value="file30">github.com/RodolfoBonis/deco/pkg/decorators/websocket.go (71.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "net"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "syscall"
        "time"

        decorators "github.com/RodolfoBonis/deco/pkg/decorators"
        "github.com/fsnotify/fsnotify"
)

func main() <span class="cov0" title="0">{
        // Check for init command before flag parsing
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "init" </span><span class="cov0" title="0">{
                verbose := contains(os.Args, "-v") || contains(os.Args, "--verbose")
                if err := handleInitCommand(verbose); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("❌ Error in init command: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Check for dev command for hot reload
        <span class="cov0" title="0">if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "dev" </span><span class="cov0" title="0">{
                verbose := contains(os.Args, "-v") || contains(os.Args, "--verbose")
                port := "8080"
                if len(os.Args) &gt; 2 &amp;&amp; strings.HasPrefix(os.Args[2], "--port=") </span><span class="cov0" title="0">{
                        port = strings.TrimPrefix(os.Args[2], "--port=")
                }</span>
                <span class="cov0" title="0">if err := handleDevCommand(verbose, port); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("❌ Error in dev command: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">var (
                // Main flags
                configPath   = flag.String("config", "", "Configuration file path")
                rootDir      = flag.String("root", "", "Root directory to search for handlers (overrides config)")
                outputPath   = flag.String("out", "", "Output file path (overrides config)")
                packageName  = flag.String("pkg", "", "Package name for the generated file (overrides config)")
                templatePath = flag.String("template", "", "Path to custom template (overrides config)")
                validate     = flag.Bool("validate", true, "Validate generated file")
                verbose      = flag.Bool("v", false, "Verbose output")
                version      = flag.Bool("version", false, "Show version")
        )

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "deco Code Generator v1.0.0\n\n")
                fmt.Fprintf(os.Stderr, "Usage: %s [options] [command]\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "Commands:\n")
                fmt.Fprintf(os.Stderr, "  init                 Create .deco.yaml configuration file\n")
                fmt.Fprintf(os.Stderr, "  generate (default)   Generate code based on configuration\n")
                fmt.Fprintf(os.Stderr, "  dev                  Start development server with hot reload\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  %s init                                    # Create default configuration\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s                                         # Use .deco.yaml\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -config custom.yaml                     # Use custom configuration\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s -root ./handlers -out ./init.go -pkg handlers  # Legacy mode\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s dev                                     # Development mode with hot reload\n", os.Args[0])
        }</span>

        <span class="cov0" title="0">flag.Parse()

        // Version command
        if *version </span><span class="cov0" title="0">{
                fmt.Println("deco Code Generator v1.0.0")
                fmt.Println("Code generator for the deco framework")
                return
        }</span>

        // Configure logging
        <span class="cov0" title="0">if *verbose </span><span class="cov0" title="0">{
                log.SetFlags(log.LstdFlags | log.Lshortfile)
        }</span> else<span class="cov0" title="0"> {
                log.SetFlags(0)
        }</span>

        // Generate command (default)
        <span class="cov0" title="0">if err := handleGenerateCommand(*configPath, *rootDir, *outputPath, *packageName, *templatePath, *validate, *verbose); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("❌ Generation error: %v", err)
        }</span>
}

// handleInitCommand executes the initialization command
func handleInitCommand(verbose bool) error <span class="cov0" title="0">{
        configFile := ".deco.yaml"

        // Check if it already exists
        if _, err := os.Stat(configFile); err == nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  File %s already exists.\n", configFile)
                fmt.Print("Do you want to overwrite? (y/N): ")

                var response string
                if _, err := fmt.Scanln(&amp;response); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error reading input: %v\n", err)
                        return nil
                }</span>

                <span class="cov0" title="0">if response != "y" &amp;&amp; response != "Y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                        fmt.Println("❌ Operation cancelled.")
                        return nil
                }</span>
        }

        // Create default configuration
        <span class="cov0" title="0">config := decorators.DefaultConfig()

        if err := decorators.SaveConfig(config, configFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error saving configuration: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Configuration file created: %s\n\n", configFile)

        if verbose </span><span class="cov0" title="0">{
                fmt.Println("📋 Configuration created with:")
                fmt.Printf("   - %d include patterns\n", len(config.Handlers.Include))
                fmt.Printf("   - %d exclude patterns\n", len(config.Handlers.Exclude))
                fmt.Printf("   - Fixed output: ./.deco/init_decorators.go\n")
                fmt.Printf("   - Fixed package: deco\n")
                fmt.Println("\n🔧 Configurable features:")
                fmt.Printf("   - Redis: %v (Address: %s)\n", config.Redis.Enabled, config.Redis.Address)
                fmt.Printf("   - Cache: %s (TTL: %s)\n", config.Cache.Type, config.Cache.DefaultTTL)
                fmt.Printf("   - Rate Limiting: %v (RPS: %d)\n", config.RateLimit.Enabled, config.RateLimit.DefaultRPS)
                fmt.Printf("   - Metrics/Prometheus: %v (Endpoint: %s)\n", config.Metrics.Enabled, config.Metrics.Endpoint)
                fmt.Printf("   - OpenAPI: %s (%s)\n", config.OpenAPI.Version, config.OpenAPI.Title)
                fmt.Printf("   - Validation: %v (Format: %s)\n", config.Validation.Enabled, config.Validation.ErrorFormat)
                fmt.Printf("   - WebSockets: %v (Buffers: %d/%d)\n", config.WebSocket.Enabled, config.WebSocket.ReadBuffer, config.WebSocket.WriteBuffer)
                fmt.Printf("   - Telemetry/OpenTelemetry: %v (Service: %s)\n", config.Telemetry.Enabled, config.Telemetry.ServiceName)
                fmt.Printf("   - Client SDK: %v (Languages: %v)\n", config.ClientSDK.Enabled, config.ClientSDK.Languages)
        }</span>

        // 🚀 NEW: Automatically generate initial code
        <span class="cov0" title="0">fmt.Println("🔍 Checking for existing handlers...")

        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error getting current directory: %v\n", err)
                return printNextSteps()
        }</span>

        <span class="cov0" title="0">handlerFiles, err := config.DiscoverHandlers(wd)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error discovering handlers: %v\n", err)
                return printNextSteps()
        }</span>

        <span class="cov0" title="0">if len(handlerFiles) == 0 </span><span class="cov0" title="0">{
                fmt.Println("📁 No handlers found yet.")
                return printNextSteps()
        }</span>

        <span class="cov0" title="0">fmt.Printf("✨ Found %d handlers! Generating initial code...\n", len(handlerFiles))

        if verbose </span><span class="cov0" title="0">{
                fmt.Println("📋 Handlers found:")
                for _, file := range handlerFiles </span><span class="cov0" title="0">{
                        fmt.Printf("   - %s\n", file)
                }</span>
        }

        // Run initial generation
        <span class="cov0" title="0">if err := handleGenerateCommand(configFile, "", "", "", "", true, verbose); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error in initial generation: %v\n", err)
                return printNextSteps()
        }</span>

        <span class="cov0" title="0">fmt.Println("\n🎉 Project initialized successfully!")
        fmt.Println("📁 Generated file: ./.deco/init_decorators.go")
        fmt.Println("\n🚀 Next steps:")
        fmt.Println("   1. Import the generated package in your main.go:")
        fmt.Println("      import _ \"yourmodule/.deco\"")
        fmt.Println("   2. Run: go run main.go")
        fmt.Println("   3. Access: http://localhost:8080/decorators/docs")
        fmt.Println("\n💡 To add new routes:")
        fmt.Println("   - Create handlers with @Route decorators")
        fmt.Println("   - Run: deco --config .deco.yaml")
        fmt.Println("\n🔥 For development with hot reload:")
        fmt.Println("   - Run: deco dev")
        fmt.Println("\n📖 For more information: https://github.com/RodolfoBonis/deco")

        return nil</span>
}

// printNextSteps prints instructions when automatic generation is not possible
func printNextSteps() error <span class="cov0" title="0">{
        fmt.Println("\n🔧 Next steps:")
        fmt.Println("   1. Create handlers with @Route decorators")
        fmt.Println("   2. Run: deco --config .deco.yaml")
        fmt.Println("   3. Import the generated package in your main.go:")
        fmt.Println("      import _ \"yourmodule/.deco\"")
        fmt.Println("   4. Run: go run main.go")
        fmt.Println("\n📖 For more information: https://github.com/RodolfoBonis/deco")
        return nil
}</span>

// handleGenerateCommand executes generation command
func handleGenerateCommand(configPath, rootDir, outputPath, packageName, templatePath string, validate, verbose bool) error <span class="cov0" title="0">{
        startTime := time.Now()

        // Load configuration
        config, err := decorators.LoadConfig(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading configuration: %v", err)
        }</span>

        // Override configuration with flags if provided
        <span class="cov0" title="0">if rootDir != "" </span><span class="cov0" title="0">{
                // Legacy mode: use root flag
                if verbose </span><span class="cov0" title="0">{
                        log.Printf("🔧 Using legacy mode with -root: %s", rootDir)
                }</span>
                <span class="cov0" title="0">return handleLegacyMode(rootDir, outputPath, packageName, templatePath, validate, verbose, startTime)</span>
        }

        // Use configuration for discovery
        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                log.Printf("📋 Using configuration for discovery")
                log.Printf("   - Include patterns: %v", config.Handlers.Include)
                log.Printf("   - Exclude patterns: %v", config.Handlers.Exclude)
        }</span>

        // Discover handlers based on configuration
        <span class="cov0" title="0">wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting current directory: %v", err)
        }</span>

        <span class="cov0" title="0">handlerFiles, err := config.DiscoverHandlers(wd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error discovering handlers: %v", err)
        }</span>

        <span class="cov0" title="0">if len(handlerFiles) == 0 </span><span class="cov0" title="0">{
                log.Printf("⚠️  No handlers found with configured patterns")
                log.Printf("💡 Tip: Run 'deco init' to generate default configuration")
                return nil
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                log.Printf("🔍 Handlers found (%d):", len(handlerFiles))
                for _, file := range handlerFiles </span><span class="cov0" title="0">{
                        log.Printf("   - %s", file)
                }</span>
        }

        // Force use of .deco folder in root (not customizable)
        <span class="cov0" title="0">finalOutput := "./.deco/init_decorators.go"
        finalPackage := "deco"

        // Ignore user output and package configurations
        if outputPath != "" &amp;&amp; verbose </span><span class="cov0" title="0">{
                log.Printf("⚠️  Ignoring -out: always uses ./.deco/init_decorators.go")
        }</span>
        <span class="cov0" title="0">if packageName != "" &amp;&amp; verbose </span><span class="cov0" title="0">{
                log.Printf("⚠️  Ignoring -pkg: always uses package deco")
        }</span>

        <span class="cov0" title="0">finalTemplate := config.Generate.Template
        if templatePath != "" </span><span class="cov0" title="0">{
                finalTemplate = templatePath
        }</span>

        // Final logs
        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                log.Printf("📄 Output file: %s", finalOutput)
                log.Printf("�� Package name: %s", finalPackage)
                if finalTemplate != "" </span><span class="cov0" title="0">{
                        log.Printf("🎨 Custom template: %s", finalTemplate)
                }</span>
        }

        // Generate using configuration-based discovery
        <span class="cov0" title="0">err = generateFromFilesWithConfig(handlerFiles, finalOutput, finalPackage, finalTemplate, validate, verbose, config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Final statistics only in verbose mode
        <span class="cov0" title="0">duration := time.Since(startTime)
        if verbose </span><span class="cov0" title="0">{
                log.Printf("✅ Generation completed in %v", duration)
                log.Printf("📁 File created: %s", finalOutput)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleLegacyMode executes generation in legacy mode (compatibility)
func handleLegacyMode(rootDir, outputPath, packageName, templatePath string, validate, verbose bool, startTime time.Time) error <span class="cov0" title="0">{
        if err := validateLegacyArgs(rootDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Force use of .deco folder in root (not customizable)
        <span class="cov0" title="0">outputPath, packageName = setupLegacyPaths(outputPath, packageName, verbose)

        absRootDir, absOutputPath, err := resolveLegacyPaths(rootDir, outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := verifyRootDirectory(absRootDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logLegacyInfo(absRootDir, absOutputPath, packageName, verbose)

        if err := generateLegacyFile(absRootDir, absOutputPath, packageName, templatePath, verbose); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := validateLegacyFile(validate, verbose); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logLegacyCompletion(startTime, absOutputPath, verbose)

        return nil</span>
}

// validateLegacyArgs validates legacy mode arguments
func validateLegacyArgs(rootDir string) error <span class="cov0" title="0">{
        if rootDir == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("root directory is required (-root)")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// setupLegacyPaths sets up legacy paths and logs warnings
func setupLegacyPaths(outputPath, packageName string, verbose bool) (outputPathResult, packageNameResult string) <span class="cov0" title="0">{
        if outputPath != "" &amp;&amp; verbose </span><span class="cov0" title="0">{
                log.Printf("⚠️  Ignoring -out: always uses ./.deco/init_decorators.go")
        }</span>
        <span class="cov0" title="0">if packageName != "" &amp;&amp; verbose </span><span class="cov0" title="0">{
                log.Printf("⚠️  Ignoring -pkg: always uses package deco")
        }</span>
        <span class="cov0" title="0">return "./.deco/init_decorators.go", "deco"</span>
}

// resolveLegacyPaths resolves absolute paths for legacy mode
func resolveLegacyPaths(rootDir, outputPath string) (absRootDir, absOutputPath string, err error) <span class="cov0" title="0">{
        absRootDir, err = filepath.Abs(rootDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("error resolving root path: %v", err)
        }</span>

        <span class="cov0" title="0">absOutputPath, err = filepath.Abs(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("error resolving output path: %v", err)
        }</span>

        <span class="cov0" title="0">return absRootDir, absOutputPath, nil</span>
}

// verifyRootDirectory verifies that the root directory exists
func verifyRootDirectory(absRootDir string) error <span class="cov0" title="0">{
        if _, err := os.Stat(absRootDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("root directory not found: %s", absRootDir)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// logLegacyInfo logs legacy mode information
func logLegacyInfo(absRootDir, absOutputPath, packageName string, verbose bool) <span class="cov0" title="0">{
        if verbose </span><span class="cov0" title="0">{
                log.Printf("🔍 Analyzing directory: %s", absRootDir)
                log.Printf("📄 Output file: %s", absOutputPath)
                log.Printf("📦 Package name: %s", packageName)
        }</span>
}

// generateLegacyFile generates the file using legacy method
func generateLegacyFile(absRootDir, absOutputPath, packageName, templatePath string, verbose bool) error <span class="cov0" title="0">{
        if templatePath != "" </span><span class="cov0" title="0">{
                return generateWithCustomTemplate(absRootDir, absOutputPath, packageName, templatePath, verbose)
        }</span>
        <span class="cov0" title="0">return generateWithDefaultConfig(absRootDir, absOutputPath, packageName)</span>
}

// generateWithCustomTemplate generates file with custom template
func generateWithCustomTemplate(absRootDir, absOutputPath, packageName, templatePath string, verbose bool) error <span class="cov0" title="0">{
        absTemplatePath, err := filepath.Abs(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error resolving template path: %v", err)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                log.Printf("🎨 Using custom template: %s", absTemplatePath)
        }</span>

        <span class="cov0" title="0">return decorators.GenerateFromTemplate(absRootDir, absTemplatePath, absOutputPath, packageName)</span>
}

// generateWithDefaultConfig generates file with default configuration
func generateWithDefaultConfig(absRootDir, absOutputPath, packageName string) error <span class="cov0" title="0">{
        config, configErr := decorators.LoadConfig("")
        if configErr != nil </span><span class="cov0" title="0">{
                config = decorators.DefaultConfig()
        }</span>
        <span class="cov0" title="0">return decorators.GenerateInitFileWithConfig(absRootDir, absOutputPath, packageName, config)</span>
}

// validateLegacyFile validates the generated file if needed
func validateLegacyFile(validate, verbose bool) error <span class="cov0" title="0">{
        if !validate </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">config, _ := decorators.LoadConfig("")
        if config != nil &amp;&amp; config.Prod.Validate </span><span class="cov0" title="0">{
                return nil // Already validated automatically
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                log.Printf("✅ Validating generated file...")
        }</span>

        <span class="cov0" title="0">if err := decorators.ValidateGeneration("./.deco/init_decorators.go"); err != nil </span><span class="cov0" title="0">{
                enhancedErr := enhanceErrorWithSourceInfo(err, ".deco.yaml")
                return fmt.Errorf("validation failed: %v", enhancedErr)
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                log.Printf("✅ File validated successfully")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// logLegacyCompletion logs completion information
func logLegacyCompletion(startTime time.Time, absOutputPath string, verbose bool) <span class="cov0" title="0">{
        duration := time.Since(startTime)
        log.Printf("✅ Generation completed in %v", duration)
        log.Printf("📁 File created: %s", absOutputPath)

        if verbose </span><span class="cov0" title="0">{
                log.Printf("\n📋 Next steps:")
                log.Printf("   1. Run: go build -tags prod")
                log.Printf("   2. File %s will be used in production", filepath.Base(absOutputPath))
        }</span>
}

// generateFromFilesWithConfig generates code with specific configuration
func generateFromFilesWithConfig(handlerFiles []string, outputPath, packageName, templatePath string, _, verbose bool, config *decorators.Config) error <span class="cov0" title="0">{
        // Extract common directory from files to use as root
        rootDir := findCommonRoot(handlerFiles)

        if verbose </span><span class="cov0" title="0">{
                log.Printf("📁 Root directory detected: %s", rootDir)
        }</span>

        // Use default configuration if not provided
        <span class="cov0" title="0">if config == nil </span><span class="cov0" title="0">{
                config = decorators.DefaultConfig()
        }</span>

        // Use default generation in root directory
        <span class="cov0" title="0">if templatePath != "" </span><span class="cov0" title="0">{
                return decorators.GenerateFromTemplate(rootDir, templatePath, outputPath, packageName)
        }</span>

        <span class="cov0" title="0">return decorators.GenerateInitFileWithConfig(rootDir, outputPath, packageName, config)</span>
}

// findCommonRoot finds the common root directory of a file list
func findCommonRoot(files []string) string <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return "."
        }</span>

        // Get the first file as base
        <span class="cov0" title="0">common := filepath.Dir(files[0])

        // Find common prefix with all others
        for _, file := range files[1:] </span><span class="cov0" title="0">{
                dir := filepath.Dir(file)

                // Find common prefix between common and dir
                for !strings.HasPrefix(dir, common) </span><span class="cov0" title="0">{
                        common = filepath.Dir(common)
                        if common == "." || common == "/" </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return common</span>
}

// contains checks if slice contains a string
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// handleDevCommand executes hot reload development server
func handleDevCommand(verbose bool, port string) error <span class="cov0" title="0">{
        // Configure logging based on verbose flag
        decorators.SetVerbose(verbose)

        fmt.Printf("🔥 Starting development server with hot reload on port %s...\n", port)

        configFile := ".deco.yaml"

        // Verify if config exists
        if _, err := os.Stat(configFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("⚠️  File .deco.yaml not found. Run 'deco init' first.")
                return nil
        }</span>

        // Load configuration
        <span class="cov0" title="0">config, err := decorators.LoadConfig(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error loading configuration: %v", err)
        }</span>

        // Perform initial generation
        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Println("🔄 Generating initial code...")
        }</span>
        <span class="cov0" title="0">if err := handleGenerateCommand(configFile, "", "", "", "", true, verbose); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in initial generation: %v", err)
        }</span>

        // Setup to capture signals
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Channel for communication with watcher
        reloadChan := make(chan bool, 1)
        errorChan := make(chan error, 1)

        // Create DevServer
        devServer := &amp;DevServer{
                Port:       port,
                Verbose:    verbose,
                Config:     config,
                ConfigFile: configFile,
                ReloadChan: reloadChan,
                ErrorChan:  errorChan,
                SigChan:    sigChan,
        }

        // Start server
        if err := devServer.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start file watcher
        <span class="cov0" title="0">if err := devServer.StartWatcher(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Println("👀 Monitoring changes automatically...")
                fmt.Println("📝 Edit your handlers - automatic regeneration and restart!")
                fmt.Println("⏹️  Ctrl+C to stop")
        }</span>

        // Main dev server loop
        <span class="cov0" title="0">return devServer.Run()</span>
}

// DevServer manages the development server with hot reload
type DevServer struct {
        Port       string
        Verbose    bool
        Config     *decorators.Config
        ConfigFile string
        ReloadChan chan bool
        ErrorChan  chan error
        SigChan    chan os.Signal

        serverCmd    *exec.Cmd
        watcher      *decorators.FileWatcher
        isRunning    bool
        restartCount int
}

// Start starts the server for the first time
func (ds *DevServer) Start() error <span class="cov0" title="0">{
        return ds.startServer()
}</span>

// StartWatcher starts the file watcher
func (ds *DevServer) StartWatcher() error <span class="cov0" title="0">{
        // Ensure watch is enabled
        ds.Config.Dev.Watch = true

        watcher, err := decorators.NewFileWatcher(ds.Config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating file watcher: %v", err)
        }</span>

        <span class="cov0" title="0">ds.watcher = watcher

        // Start watcher with custom callback
        return ds.startWatcherWithCallback()</span>
}

// startWatcherWithCallback starts watcher with callback for hot reload
func (ds *DevServer) startWatcherWithCallback() error <span class="cov0" title="0">{
        // Discover files to monitor
        wd, err := filepath.Abs(".")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting current directory: %v", err)
        }</span>

        <span class="cov0" title="0">handlerFiles, err := ds.Config.DiscoverHandlers(wd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error discovering handlers: %v", err)
        }</span>

        <span class="cov0" title="0">if len(handlerFiles) == 0 </span><span class="cov0" title="0">{
                fmt.Println("⚠️  No handlers found to monitor")
                return nil
        }</span>

        // Monitor handler directories
        <span class="cov0" title="0">monitoredDirs := make(map[string]bool)
        for _, file := range handlerFiles </span><span class="cov0" title="0">{
                dir := filepath.Dir(file)
                if !monitoredDirs[dir] </span><span class="cov0" title="0">{
                        monitoredDirs[dir] = true
                }</span>
        }

        // DO NOT monitor .deco directory to avoid infinite loop

        <span class="cov0" title="0">if ds.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("🔍 Monitoring directories: %v\n", getKeys(monitoredDirs))
        }</span>

        // Start watcher
        <span class="cov0" title="0">if err := ds.watcher.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Goroutine to process file watching events
        <span class="cov0" title="0">go ds.watchFiles()

        return nil</span>
}

// watchFiles processes file watcher events
func (ds *DevServer) watchFiles() <span class="cov0" title="0">{
        watcher, monitoredDirs, err := ds.setupFileWatcher()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("❌ Error setting up file watcher: %v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer watcher.Close()

        ds.addDirectoriesToWatcher(watcher, monitoredDirs)
        ds.processWatcherEvents(watcher)</span>
}

// setupFileWatcher sets up the file watcher and discovers monitored directories
func (ds *DevServer) setupFileWatcher() (*fsnotify.Watcher, map[string]bool, error) <span class="cov0" title="0">{
        wd, _ := filepath.Abs(".")
        handlerFiles, err := ds.Config.DiscoverHandlers(wd)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error discovering handlers: %v", err)
        }</span>

        <span class="cov0" title="0">monitoredDirs := ds.getMonitoredDirectories(handlerFiles)

        if ds.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("🔍 Monitoring directories: %v\n", getKeys(monitoredDirs))
        }</span>

        <span class="cov0" title="0">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error creating fsnotify watcher: %v", err)
        }</span>

        <span class="cov0" title="0">return watcher, monitoredDirs, nil</span>
}

// getMonitoredDirectories gets the directories to monitor from handler files
func (ds *DevServer) getMonitoredDirectories(handlerFiles []string) map[string]bool <span class="cov0" title="0">{
        monitoredDirs := make(map[string]bool)
        for _, file := range handlerFiles </span><span class="cov0" title="0">{
                dir := filepath.Dir(file)
                if !monitoredDirs[dir] </span><span class="cov0" title="0">{
                        monitoredDirs[dir] = true
                }</span>
        }
        <span class="cov0" title="0">return monitoredDirs</span>
}

// addDirectoriesToWatcher adds directories to the file watcher
func (ds *DevServer) addDirectoriesToWatcher(watcher *fsnotify.Watcher, monitoredDirs map[string]bool) <span class="cov0" title="0">{
        for dir := range monitoredDirs </span><span class="cov0" title="0">{
                if err := watcher.Add(dir); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️ Error monitoring directory %s: %v\n", dir, err)
                }</span> else<span class="cov0" title="0"> if ds.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("👀 Monitoring directory: %s\n", dir)
                }</span>
        }
}

// processWatcherEvents processes file watcher events
func (ds *DevServer) processWatcherEvents(watcher *fsnotify.Watcher) <span class="cov0" title="0">{
        var debounceTimer *time.Timer
        debounceDuration := 500 * time.Millisecond

        for </span><span class="cov0" title="0">{
                select </span>{
                case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">ds.handleWatcherEvent(event, &amp;debounceTimer, debounceDuration)</span>

                case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("❌ Error in file watcher: %v\n", err)</span>
                }
        }
}

// handleWatcherEvent handles a single watcher event
func (ds *DevServer) handleWatcherEvent(event fsnotify.Event, debounceTimer **time.Timer, debounceDuration time.Duration) <span class="cov0" title="0">{
        if !ds.shouldProcessEvent(event) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if ds.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("📁 Modified: %s\n", event.Name)
        }</span>

        // Debounce
        <span class="cov0" title="0">if *debounceTimer != nil </span><span class="cov0" title="0">{
                (*debounceTimer).Stop()
        }</span>
        <span class="cov0" title="0">*debounceTimer = time.AfterFunc(debounceDuration, ds.regenerateCode)</span>
}

// regenerateCode regenerates the code and signals reload
func (ds *DevServer) regenerateCode() <span class="cov0" title="0">{
        if ds.Verbose </span><span class="cov0" title="0">{
                fmt.Println("🔄 Changes detected, regenerating...")
        }</span>

        // Regenerate code
        <span class="cov0" title="0">if err := handleGenerateCommand(ds.ConfigFile, "", "", "", "", true, false); err != nil </span><span class="cov0" title="0">{
                // Enhanced error reporting with source file information
                enhancedErr := enhanceErrorWithSourceInfo(err, ds.ConfigFile)
                fmt.Printf("❌ Error in regeneration: %v\n", enhancedErr)
                ds.ErrorChan &lt;- enhancedErr
                return
        }</span>

        <span class="cov0" title="0">if ds.Verbose </span><span class="cov0" title="0">{
                fmt.Println("✅ Code regenerated, restarting server...")
        }</span>

        // Signal reload
        <span class="cov0" title="0">select </span>{
        case ds.ReloadChan &lt;- true:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Channel full, ignore
        }
}

// shouldProcessEvent checks if we should process the file event
func (ds *DevServer) shouldProcessEvent(event fsnotify.Event) bool <span class="cov0" title="0">{
        // Ignore irrelevant events
        if event.Op&amp;fsnotify.Chmod == fsnotify.Chmod </span><span class="cov0" title="0">{
                return false // Ignore permission changes
        }</span>

        // Process only .go files
        <span class="cov0" title="0">if !strings.HasSuffix(event.Name, ".go") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Ignore temporary files
        <span class="cov0" title="0">if strings.HasSuffix(event.Name, "~") ||
                strings.HasSuffix(event.Name, ".tmp") ||
                strings.HasSuffix(event.Name, ".swp") ||
                strings.Contains(event.Name, ".git/") </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">eventPath, err := filepath.Abs(event.Name)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // DO NOT process .deco/init_decorators.go file to avoid infinite loop
        <span class="cov0" title="0">initDecoratorsPath, err := filepath.Abs("./.deco/init_decorators.go")
        if err == nil &amp;&amp; eventPath == initDecoratorsPath </span><span class="cov0" title="0">{
                if ds.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⏭️  Ignoring .deco/init_decorators.go (generated file)\n")
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        // Verify if the file is in the list of monitored handlers
        <span class="cov0" title="0">wd, err := filepath.Abs(".")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">handlerFiles, err := ds.Config.DiscoverHandlers(wd)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Verify if the modified file is one of the handlers
        <span class="cov0" title="0">for _, handlerFile := range handlerFiles </span><span class="cov0" title="0">{
                handlerPath, err := filepath.Abs(handlerFile)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if eventPath == handlerPath </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// getKeys returns the keys of a map as slice
func getKeys(m map[string]bool) []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Run executes the main dev server loop
func (ds *DevServer) Run() error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ds.ReloadChan:<span class="cov0" title="0">
                        // Server restart
                        if err := ds.restartServer(); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("❌ Error restarting server: %v\n", err)
                        }</span>

                case err := &lt;-ds.ErrorChan:<span class="cov0" title="0">
                        fmt.Printf("⚠️  Error in dev server: %v\n", err)</span>

                case &lt;-ds.SigChan:<span class="cov0" title="0">
                        fmt.Println("\n🛑 Stopping development server...")
                        return ds.Stop()</span>
                }
        }
}

// startServer starts the server process
func (ds *DevServer) startServer() error <span class="cov0" title="0">{
        // Verify if port is free before trying to start
        if !ds.isPortFree() </span><span class="cov0" title="0">{
                return fmt.Errorf("port :%s is already in use", ds.Port)
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("go", "run", "main.go")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Env = append(os.Environ(), fmt.Sprintf("PORT=%s", ds.Port))

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error starting server: %v", err)
        }</span>

        <span class="cov0" title="0">ds.serverCmd = cmd
        ds.isRunning = true
        ds.restartCount++

        fmt.Printf("✅ Server started (PID: %d, restart #%d)\n", cmd.Process.Pid, ds.restartCount)

        // Goroutine to monitor the process
        go func() </span><span class="cov0" title="0">{
                if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                        if ds.isRunning </span><span class="cov0" title="0">{
                                // Process died unexpectedly
                                fmt.Printf("⚠️  Server stopped unexpectedly: %v\n", err)
                                ds.isRunning = false
                        }</span>
                }
        }()

        // Wait a bit for the server to initialize
        // We don't need to check the port again as it may be in the process of binding
        <span class="cov0" title="0">time.Sleep(2 * time.Second) // Increased to 2s to give Gin time to bind

        return nil</span>
}

// restartServer restarts the server gracefully
func (ds *DevServer) restartServer() error <span class="cov0" title="0">{
        fmt.Println("🔄 Restarting server...")

        // Stop current server if running
        if err := ds.stopServer(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error stopping server: %v\n", err)
        }</span>

        // Wait for port to become free
        <span class="cov0" title="0">if err := ds.waitForPortFree(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error waiting for port to be free: %v", err)
        }</span>

        // Start new server
        <span class="cov0" title="0">return ds.startServer()</span>
}

// stopServer stops the current server robustly
func (ds *DevServer) stopServer() error <span class="cov0" title="0">{
        if ds.serverCmd == nil || ds.serverCmd.Process == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">pid := ds.serverCmd.Process.Pid
        if ds.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("🛑 Stopping server (PID: %d)...\n", pid)
        }</span>

        // Mark as not running to avoid "stopped unexpectedly" logs
        <span class="cov0" title="0">ds.isRunning = false

        // Try graceful shutdown with SIGINT (Go responds better to this)
        if err := ds.serverCmd.Process.Signal(syscall.SIGINT); err != nil </span><span class="cov0" title="0">{
                if ds.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  SIGINT failed: %v, trying SIGTERM...\n", err)
                }</span>
                <span class="cov0" title="0">if err := ds.serverCmd.Process.Signal(syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                        if ds.Verbose </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️  SIGTERM failed: %v, using SIGKILL...\n", err)
                        }</span>
                        <span class="cov0" title="0">if err := ds.serverCmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                                if ds.Verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("⚠️  SIGKILL failed: %v\n", err)
                                }</span>
                        }
                }
        }

        // Wait for process to terminate with extended timeout
        <span class="cov0" title="0">done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                done &lt;- ds.serverCmd.Wait()
        }</span>()

        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                if ds.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("✅ Server stopped gracefully (PID: %d)\n", pid)
                }</span>
                <span class="cov0" title="0">return err</span>
        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0"> // Extended timeout to 10s
                if ds.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⏰ Timeout waiting, forcing kill (PID: %d)...\n", pid)
                }</span>
                <span class="cov0" title="0">if err := ds.serverCmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        if ds.Verbose </span><span class="cov0" title="0">{
                                fmt.Printf("⚠️  Force kill failed: %v\n", err)
                        }</span>
                }
                <span class="cov0" title="0">&lt;-done // Wait for Kill to finish
                return nil</span>
        }
}

// waitForPortFree waits for the port to become available
func (ds *DevServer) waitForPortFree() error <span class="cov0" title="0">{
        maxAttempts := 20 // 20 attempts = 2 seconds maximum
        for i := 0; i &lt; maxAttempts; i++ </span><span class="cov0" title="0">{
                if ds.isPortFree() </span><span class="cov0" title="0">{
                        if ds.Verbose &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("✅ Port :%s freed after %d attempts (%.1fs)\n", ds.Port, i+1, float64(i+1)*0.1)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">if ds.Verbose &amp;&amp; i == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("⏳ Waiting for port :%s to become free...\n", ds.Port)
                }</span>
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        // If we got here, try to force kill processes on the port
        <span class="cov0" title="0">if ds.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Timeout waiting for port :%s, trying forced kill...\n", ds.Port)
        }</span>

        // Try to kill processes using the port (macOS/Linux)
        <span class="cov0" title="0">ds.killProcessesOnPort()

        // Try a few more times after forced kill
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                if ds.isPortFree() </span><span class="cov0" title="0">{
                        if ds.Verbose </span><span class="cov0" title="0">{
                                fmt.Printf("✅ Port :%s freed after forced kill\n", ds.Port)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("timeout waiting for port :%s to become free (tried forced kill)", ds.Port)</span>
}

// killProcessesOnPort tries to kill processes using the port
func (ds *DevServer) killProcessesOnPort() <span class="cov0" title="0">{
        // Validate port to prevent command injection
        if ds.Port == "" || !isValidPort(ds.Port) </span><span class="cov0" title="0">{
                if ds.Verbose </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Invalid port: %s\n", ds.Port)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Command to find and kill processes on the port (works on macOS and Linux)
        // #nosec G204
        <span class="cov0" title="0">cmd := exec.Command("sh", "-c", fmt.Sprintf("lsof -ti :%s | xargs -r kill -9", ds.Port))
        if err := cmd.Run(); err != nil &amp;&amp; ds.Verbose </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Could not force kill on port :%s: %v\n", ds.Port, err)
        }</span>
}

// isValidPort validates if the port string is safe for command execution
func isValidPort(port string) bool <span class="cov0" title="0">{
        // Check if port is numeric and within valid range
        if port == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">portNum, err := strconv.Atoi(port)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return portNum &gt; 0 &amp;&amp; portNum &lt;= 65535</span>
}

// isPortFree checks if the port is available
func (ds *DevServer) isPortFree() bool <span class="cov0" title="0">{
        // Try to bind to the port to check if it's free
        addr := fmt.Sprintf(":%s", ds.Port)
        listener, err := net.Listen("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return false // Port occupied
        }</span>
        <span class="cov0" title="0">listener.Close()
        return true</span> // Port free
}

// Stop stops the dev server
func (ds *DevServer) Stop() error <span class="cov0" title="0">{
        fmt.Println("🛑 Stopping dev server...")

        // Stop watcher
        if ds.watcher != nil </span><span class="cov0" title="0">{
                if err := ds.watcher.Stop(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("⚠️  Error stopping watcher: %v\n", err)
                }</span>
        }

        // Stop server using robust method
        <span class="cov0" title="0">if err := ds.stopServer(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Error stopping server: %v\n", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("✅ Dev server stopped.")
        return nil</span>
}

// enhanceErrorWithSourceInfo attempts to map errors from generated files back to source files
func enhanceErrorWithSourceInfo(err error, configFile string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">errStr := err.Error()

        // Handle decorator validation errors directly
        if multiErr, ok := err.(*decorators.MultipleValidationError); ok </span><span class="cov0" title="0">{
                var messages []string
                for _, valErr := range multiErr.Errors </span><span class="cov0" title="0">{
                        messages = append(messages, valErr.Error())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("❌ Decorator errors found:\n%s", strings.Join(messages, "\n"))</span>
        }

        // Handle single validation error
        <span class="cov0" title="0">if valErr, ok := err.(*decorators.ValidationError); ok </span><span class="cov0" title="0">{
                return fmt.Errorf("❌ Decorator error: %s", valErr.Error())
        }</span>

        // Check if it's a parsing error during generation
        <span class="cov0" title="0">if strings.Contains(errStr, "./.deco/init_decorators.go") </span><span class="cov0" title="0">{
                // Extract line information if available
                if strings.Contains(errStr, "syntax error") || strings.Contains(errStr, "expected") </span><span class="cov0" title="0">{
                        // Load config to get handler files
                        config, configErr := decorators.LoadConfig(configFile)
                        if configErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("❌ Decorator syntax error - check your handler files")
                        }</span>

                        // Get working directory
                        <span class="cov0" title="0">wd, _ := filepath.Abs(".")
                        handlerFiles, _ := config.DiscoverHandlers(wd)

                        if len(handlerFiles) &gt; 0 </span><span class="cov0" title="0">{
                                // Try to extract line number and map to source file
                                lineInfo := extractLineInfoFromError(errStr)
                                if lineInfo != "" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("❌ Decorator syntax error %s - check: %s", lineInfo, getFirstFewFiles(handlerFiles))
                                }</span>
                                <span class="cov0" title="0">return fmt.Errorf("❌ Decorator syntax error - check: %s", getFirstFewFiles(handlerFiles))</span>
                        }

                        <span class="cov0" title="0">return fmt.Errorf("❌ Decorator syntax error - check your handler files")</span>
                }

                // Handle compilation errors
                <span class="cov0" title="0">if strings.Contains(errStr, "cannot use") || strings.Contains(errStr, "undefined") </span><span class="cov0" title="0">{
                        return fmt.Errorf("❌ Compilation error - check your decorator syntax and imports")
                }</span>
        }

        // Handle other Go compilation errors
        <span class="cov0" title="0">if strings.Contains(errStr, "go build") || strings.Contains(errStr, "go run") </span><span class="cov0" title="0">{
                if strings.Contains(errStr, "expected") </span><span class="cov0" title="0">{
                        return fmt.Errorf("❌ Go syntax error - check parentheses, quotes and commas in decorators")
                }</span>
                <span class="cov0" title="0">if strings.Contains(errStr, "undefined") </span><span class="cov0" title="0">{
                        return fmt.Errorf("❌ Error: function or type not defined - check imports and function names")
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}

// extractLineInfoFromError extracts line information from error messages
func extractLineInfoFromError(errStr string) string <span class="cov0" title="0">{
        // Look for patterns like ":123:" or ":123:123:"
        re := regexp.MustCompile(`:\d+:\d*:`)
        match := re.FindString(errStr)
        if match != "" </span><span class="cov0" title="0">{
                return match
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getFirstFewFiles returns a simple comma-separated list of the first few files
func getFirstFewFiles(files []string) string <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return "no handler files found"
        }</span>

        <span class="cov0" title="0">if len(files) == 1 </span><span class="cov0" title="0">{
                return filepath.Base(files[0])
        }</span>

        <span class="cov0" title="0">if len(files) &lt;= 3 </span><span class="cov0" title="0">{
                var names []string
                for _, file := range files </span><span class="cov0" title="0">{
                        names = append(names, filepath.Base(file))
                }</span>
                <span class="cov0" title="0">return strings.Join(names, ", ")</span>
        }

        // More than 3 files, show first 2 and "..."
        <span class="cov0" title="0">return fmt.Sprintf("%s, %s, ... (%d more)",
                filepath.Base(files[0]),
                filepath.Base(files[1]),
                len(files)-2)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"

        deco "github.com/RodolfoBonis/deco"
)

func main() <span class="cov0" title="0">{
        fmt.Println("🔒 Exemplo: Proteção dos endpoints internos do gin-decorators")

        // Exemplo 1: Proteção padrão (apenas localhost)
        fmt.Println("✅ Executando com proteção padrão (localhost apenas)")
        r := deco.Default() // Aplica automaticamente AllowLocalhostOnly()

        fmt.Println("📋 Endpoints protegidos:")
        fmt.Println("   - /decorators/docs (documentação)")
        fmt.Println("   - /decorators/docs.json (documentação JSON)")
        fmt.Println("   - /decorators/openapi.json (especificação OpenAPI)")
        fmt.Println("   - /decorators/openapi.yaml (especificação OpenAPI YAML)")
        fmt.Println("   - /decorators/swagger-ui (interface Swagger)")
        fmt.Println("   - /decorators/swagger (redirecionamento Swagger)")
        fmt.Println("\n🔒 Apenas localhost (127.0.0.1) pode acessar esses endpoints")
        fmt.Println("🌐 Teste acessando: http://localhost:8080/decorators/docs")
        fmt.Println("🚫 Tentativas de acesso externo serão bloqueadas e logadas")

        r.Run(":8080")
}</span>

// Exemplo de como usar em produção
func productionExample() <span class="cov0" title="0">{
        // Configuração de segurança para produção
        prodSecurity := &amp;deco.SecurityConfig{
                // Permitir apenas redes da empresa
                AllowedNetworks: []string{"10.0.0.0/8", "172.16.0.0/12"},
                // Permitir localhost para desenvolvimento
                AllowLocalhost: true,
                // IPs específicos de servidores de monitoramento
                AllowedIPs: []string{"192.168.1.100", "192.168.1.101"},
                // Mensagem de erro personalizada
                ErrorMessage: "Acesso negado: Endpoints de documentação restritos à rede corporativa",
                // Log de tentativas bloqueadas
                LogBlockedAttempts: true,
        }

        // Criar engine com segurança
        r := deco.DefaultWithSecurity(prodSecurity)

        // Adicionar suas rotas de aplicação
        // r.GET("/api/users", handlers.GetUsers)
        // r.POST("/api/users", handlers.CreateUser)

        r.Run(":8080")
}</span>

// Exemplo de como usar em desenvolvimento
func developmentExample() <span class="cov0" title="0">{
        // Configuração de segurança para desenvolvimento
        devSecurity := &amp;deco.SecurityConfig{
                // Permitir redes privadas (VPN, Docker, etc.)
                AllowPrivateNetworks: true,
                // Permitir localhost
                AllowLocalhost: true,
                // Mensagem de erro amigável
                ErrorMessage: "Acesso negado: Endpoints de documentação restritos ao ambiente de desenvolvimento",
                // Log de tentativas bloqueadas
                LogBlockedAttempts: true,
        }

        // Criar engine com segurança
        r := deco.DefaultWithSecurity(devSecurity)

        // Adicionar suas rotas de aplicação
        // r.GET("/api/users", handlers.GetUsers)
        // r.POST("/api/users", handlers.CreateUser)

        r.Run(":8080")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"

        deco "github.com/RodolfoBonis/deco"
        "github.com/gin-gonic/gin"
)

func main() <span class="cov0" title="0">{
        r := gin.Default()

        // Apply security middleware to internal endpoints
        // This will block access from external networks
        internalGroup := r.Group("/internal")
        internalGroup.Use(deco.AllowLocalhostOnly()) // Only localhost can access

        // Alternative: Allow private networks (VPN, internal networks)
        // internalGroup.Use(deco.AllowPrivateNetworks())

        // Alternative: Allow specific networks
        // internalGroup.Use(deco.AllowSpecificNetworks([]string{"192.168.1.0/24", "10.0.0.0/8"}))

        // Alternative: Allow specific IPs
        // internalGroup.Use(deco.AllowSpecificIPs([]string{"192.168.1.100", "10.0.0.50"}))

        // Register routes manually for this example
        r.GET("/internal/health", deco.AllowLocalhostOnly(), InternalHealthCheck)
        r.GET("/internal/metrics", deco.AllowPrivateNetworks(), InternalMetrics)
        r.GET("/public/info", PublicInfo)

        fmt.Println("🚀 Server running on :8080")
        fmt.Println("🔒 Internal endpoints protected:")
        fmt.Println("   - /internal/health (localhost only)")
        fmt.Println("   - /internal/metrics (private networks only)")
        fmt.Println("   - /public/info (public access)")

        r.Run(":8080")
}</span>

// @Route(method="GET", path="/internal/health")
// @Security(localhost)
// @Description("Internal health check - localhost only")
func InternalHealthCheck(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{"status": "healthy", "internal": true})
}</span>

// @Route(method="GET", path="/internal/metrics")
// @Security(private)
// @Description("Internal metrics - private networks only")
func InternalMetrics(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{"metrics": "internal_data"})
}</span>

// Public endpoints (no security restrictions)
// @Route(method="GET", path="/public/info")
// @Description("Public information endpoint")
func PublicInfo(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(200, gin.H{"info": "public_data"})
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package decorators

import (
        "context"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
)

// CacheEntry represents a cache entry
type CacheEntry struct {
        Data      []byte            `json:"data"`
        Headers   map[string]string `json:"headers"`
        Status    int               `json:"status"`
        ExpiresAt time.Time         `json:"expires_at"`
}

// CacheStore interface for different cache implementations
type CacheStore interface {
        Get(ctx context.Context, key string) (*CacheEntry, error)
        Set(ctx context.Context, key string, entry *CacheEntry, ttl time.Duration) error
        Delete(ctx context.Context, key string) error
        Clear(ctx context.Context) error
        Stats() CacheStats
}

// CacheStats cache statistics
type CacheStats struct {
        Hits      int64   `json:"hits"`
        Misses    int64   `json:"misses"`
        Sets      int64   `json:"sets"`
        Deletes   int64   `json:"deletes"`
        Evictions int64   `json:"evictions"`
        Size      int64   `json:"size"`
        MaxSize   int64   `json:"max_size"`
        HitRate   float64 `json:"hit_rate"`
}

// MemoryCache in-memory cache implementation
type MemoryCache struct {
        mu      sync.RWMutex
        data    map[string]*CacheEntry
        access  map[string]time.Time // Track last access time for LRU
        maxSize int
        stats   CacheStats
}

// RedisCache Redis cache implementation
type RedisCache struct {
        client *redis.Client
        prefix string
        stats  CacheStats
}

// CacheKeyFunc function to generate cache key
type CacheKeyFunc func(c *gin.Context) string

// Default cache key generation functions
var (
        URLCacheKey = func(c *gin.Context) string <span class="cov6" title="6">{
                return fmt.Sprintf("cache:url:%s:%s", c.Request.Method, c.Request.URL.Path)
        }</span>

        UserURLCacheKey = func(c *gin.Context) string <span class="cov3" title="2">{
                userID := c.GetString("user_id")
                if userID == "" </span><span class="cov3" title="2">{
                        userID = "anonymous"
                }</span>
                <span class="cov3" title="2">return fmt.Sprintf("cache:user:%s:url:%s:%s", userID, c.Request.Method, c.Request.URL.Path)</span>
        }

        EndpointCacheKey = func(c *gin.Context) string <span class="cov3" title="2">{
                path := c.FullPath()
                if path == "" </span><span class="cov3" title="2">{
                        path = c.Request.URL.Path
                }</span>
                <span class="cov3" title="2">return fmt.Sprintf("cache:endpoint:%s:%s", c.Request.Method, path)</span>
        }
)

// NewMemoryCache creates a new in-memory cache
func NewMemoryCache(maxSize int) *MemoryCache <span class="cov9" title="18">{
        return &amp;MemoryCache{
                data:    make(map[string]*CacheEntry),
                access:  make(map[string]time.Time),
                maxSize: maxSize,
                stats:   CacheStats{MaxSize: int64(maxSize)},
        }
}</span>

// Get retrieves cache entry (in-memory implementation)
func (m *MemoryCache) Get(ctx context.Context, key string) (*CacheEntry, error) <span class="cov7" title="10">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        default:<span class="cov7" title="10"></span>
        }

        <span class="cov7" title="10">m.mu.Lock()
        defer m.mu.Unlock()

        entry, exists := m.data[key]
        if !exists </span><span class="cov7" title="10">{
                m.stats.Misses++
                m.updateHitRate()
                return nil, nil
        }</span>

        // Check if expired
        <span class="cov0" title="0">if time.Now().After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                delete(m.data, key)
                delete(m.access, key)
                m.stats.Evictions++
                m.stats.Misses++
                m.updateHitRate()
                return nil, nil
        }</span>

        // Update access time for LRU
        <span class="cov0" title="0">m.access[key] = time.Now()

        m.stats.Hits++
        m.updateHitRate()
        return entry, nil</span>
}

// Set stores cache entry (in-memory implementation)
func (m *MemoryCache) Set(ctx context.Context, key string, entry *CacheEntry, ttl time.Duration) error <span class="cov0" title="0">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">m.mu.Lock()
        defer m.mu.Unlock()

        // Check size limit
        if len(m.data) &gt;= m.maxSize </span><span class="cov0" title="0">{
                // Simple LRU: remove least recently used entry
                var oldestKey string
                var oldestTime = time.Now()

                for k, accessTime := range m.access </span><span class="cov0" title="0">{
                        if accessTime.Before(oldestTime) </span><span class="cov0" title="0">{
                                oldestTime = accessTime
                                oldestKey = k
                        }</span>
                }

                <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                        delete(m.data, oldestKey)
                        delete(m.access, oldestKey)
                        m.stats.Evictions++
                }</span>
        }

        <span class="cov0" title="0">entry.ExpiresAt = time.Now().Add(ttl)
        m.data[key] = entry
        m.access[key] = time.Now() // Set initial access time
        m.stats.Sets++
        m.stats.Size = int64(len(m.data))

        return nil</span>
}

// Delete removes cache entry (in-memory implementation)
func (m *MemoryCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.data[key]; exists </span><span class="cov0" title="0">{
                delete(m.data, key)
                delete(m.access, key)
                m.stats.Deletes++
                m.stats.Size = int64(len(m.data))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Clear clears entire cache (in-memory implementation)
func (m *MemoryCache) Clear(ctx context.Context) error <span class="cov3" title="2">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov3" title="2"></span>
        }

        <span class="cov3" title="2">m.mu.Lock()
        defer m.mu.Unlock()

        m.data = make(map[string]*CacheEntry)
        m.access = make(map[string]time.Time)
        m.stats.Size = 0

        return nil</span>
}

// Stats returns cache statistics (in-memory implementation)
func (m *MemoryCache) Stats() CacheStats <span class="cov3" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := m.stats
        stats.Size = int64(len(m.data))
        return stats
}</span>

// updateHitRate updates hit rate
func (m *MemoryCache) updateHitRate() <span class="cov7" title="10">{
        total := m.stats.Hits + m.stats.Misses
        if total &gt; 0 </span><span class="cov7" title="10">{
                m.stats.HitRate = float64(m.stats.Hits) / float64(total) * 100
        }</span>
}

// NewRedisCache creates a new Redis cache
func NewRedisCache(config RedisConfig, prefix string) (*RedisCache, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     config.Address,
                Password: config.Password,
                DB:       config.DB,
                PoolSize: config.PoolSize,
        })

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisCache{
                client: client,
                prefix: prefix,
                stats:  CacheStats{},
        }, nil</span>
}

// Get retrieves cache entry (Redis implementation)
func (r *RedisCache) Get(ctx context.Context, key string) (*CacheEntry, error) <span class="cov0" title="0">{
        fullKey := r.prefix + key

        data, err := r.client.Get(ctx, fullKey).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        r.stats.Misses++
                        r.updateHitRate()
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">var entry CacheEntry
        if err := json.Unmarshal(data, &amp;entry); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error deserializing cache: %v", err)
        }</span>

        // Check if expired (double verification)
        <span class="cov0" title="0">if time.Now().After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                r.client.Del(ctx, fullKey)
                r.stats.Misses++
                r.stats.Evictions++
                r.updateHitRate()
                return nil, nil
        }</span>

        <span class="cov0" title="0">r.stats.Hits++
        r.updateHitRate()
        return &amp;entry, nil</span>
}

// Set stores cache entry (Redis implementation)
func (r *RedisCache) Set(ctx context.Context, key string, entry *CacheEntry, ttl time.Duration) error <span class="cov0" title="0">{
        fullKey := r.prefix + key

        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error serializing cache: %v", err)
        }</span>

        <span class="cov0" title="0">if err := r.client.Set(ctx, fullKey, data, ttl).Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.stats.Sets++
        return nil</span>
}

// Delete removes cache entry (Redis implementation)
func (r *RedisCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        fullKey := r.prefix + key

        result := r.client.Del(ctx, fullKey)
        if result.Val() &gt; 0 </span><span class="cov0" title="0">{
                r.stats.Deletes++
        }</span>

        <span class="cov0" title="0">return result.Err()</span>
}

// Clear clears entire cache (Redis implementation)
func (r *RedisCache) Clear(ctx context.Context) error <span class="cov0" title="0">{
        pattern := r.prefix + "*"

        keys, err := r.client.Keys(ctx, pattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                return r.client.Del(ctx, keys...).Err()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stats returns cache statistics (Redis implementation)
func (r *RedisCache) Stats() CacheStats <span class="cov0" title="0">{
        // For Redis, some statistics may be limited
        stats := r.stats

        // Try to get Redis information
        ctx := context.Background()
        info, err := r.client.Info(ctx, "memory").Result()
        if err == nil </span><span class="cov0" title="0">{
                // Basic parsing of memory information
                lines := strings.Split(info, "\r\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        if strings.HasPrefix(line, "used_memory:") </span><span class="cov0" title="0">{
                                if size, err := strconv.ParseInt(strings.TrimPrefix(line, "used_memory:"), 10, 64); err == nil </span><span class="cov0" title="0">{
                                        stats.Size = size
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">r.updateHitRate()
        stats.HitRate = r.stats.HitRate

        return stats</span>
}

// updateHitRate updates hit rate (Redis)
func (r *RedisCache) updateHitRate() <span class="cov0" title="0">{
        total := r.stats.Hits + r.stats.Misses
        if total &gt; 0 </span><span class="cov0" title="0">{
                r.stats.HitRate = float64(r.stats.Hits) / float64(total) * 100
        }</span>
}

// CacheMiddleware creates cache middleware
func CacheMiddleware(config *CacheConfig, keyGen CacheKeyFunc) gin.HandlerFunc <span class="cov8" title="14">{
        var store CacheStore
        var err error

        // Choose implementation based on configuration
        if config.Type == "redis" </span><span class="cov0" title="0">{
                redisConfig := DefaultConfig().Redis
                store, err = NewRedisCache(redisConfig, "gin_decorators:")
                if err != nil </span><span class="cov0" title="0">{
                        // Fallback to memory if Redis fails
                        store = NewMemoryCache(config.MaxSize)
                }</span>
        } else<span class="cov8" title="14"> {
                store = NewMemoryCache(config.MaxSize)
        }</span>

        // Parse default TTL
        <span class="cov8" title="14">defaultTTL, err := time.ParseDuration(config.DefaultTTL)
        if err != nil </span><span class="cov0" title="0">{
                defaultTTL = 5 * time.Minute
        }</span>

        <span class="cov8" title="14">return func(c *gin.Context) </span><span class="cov7" title="10">{
                // Only cache GET methods by default
                if c.Request.Method != "GET" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Generate cache key
                <span class="cov7" title="10">key := keyGen(c)

                // Try to retrieve from cache
                ctx := c.Request.Context()
                entry, err := store.Get(ctx, key)
                if err == nil &amp;&amp; entry != nil </span><span class="cov0" title="0">{
                        // Cache hit - return cached response
                        for headerKey, headerValue := range entry.Headers </span><span class="cov0" title="0">{
                                c.Header(headerKey, headerValue)
                        }</span>
                        <span class="cov0" title="0">c.Header("X-Cache", "HIT")
                        c.Header("X-Cache-Key", generateCacheKeyHash(key))

                        c.Data(entry.Status, c.GetHeader("Content-Type"), entry.Data)
                        c.Abort()
                        return</span>
                }

                // Cache miss - continue processing
                <span class="cov7" title="10">c.Header("X-Cache", "MISS")
                c.Header("X-Cache-Key", generateCacheKeyHash(key))

                // Capture response
                writer := &amp;responseWriter{
                        ResponseWriter: c.Writer,
                        body:           make([]byte, 0),
                        headers:        make(map[string]string),
                }
                c.Writer = writer

                c.Next()

                // Store in cache if response is successful
                if writer.status &gt;= 200 &amp;&amp; writer.status &lt; 300 </span><span class="cov0" title="0">{
                        entry := &amp;CacheEntry{
                                Data:    writer.body,
                                Headers: writer.headers,
                                Status:  writer.status,
                        }

                        if err := store.Set(ctx, key, entry, defaultTTL); err != nil </span><span class="cov0" title="0">{
                                // Log error but don't fail the request
                                log.Printf("Failed to store cache entry: %v", err)
                        }</span>
                }
        }
}

// responseWriter wrapper to capture response
type responseWriter struct {
        gin.ResponseWriter
        body    []byte
        headers map[string]string
        status  int
}

func (w *responseWriter) Write(data []byte) (int, error) <span class="cov0" title="0">{
        w.body = append(w.body, data...)
        return w.ResponseWriter.Write(data)
}</span>

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.status = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func (w *responseWriter) Header() http.Header <span class="cov7" title="10">{
        // Capture important headers
        header := w.ResponseWriter.Header()
        for key, values := range header </span><span class="cov10" title="20">{
                if len(values) &gt; 0 </span><span class="cov10" title="20">{
                        w.headers[key] = values[0]
                }</span>
        }
        <span class="cov7" title="10">return header</span>
}

// CacheByURL cache middleware by URL
func CacheByURL(config *CacheConfig) gin.HandlerFunc <span class="cov5" title="4">{
        return CacheMiddleware(config, URLCacheKey)
}</span>

// CacheByUserURL cache middleware by user and URL
func CacheByUserURL(config *CacheConfig) gin.HandlerFunc <span class="cov5" title="4">{
        return CacheMiddleware(config, UserURLCacheKey)
}</span>

// CacheByEndpoint cache middleware by endpoint
func CacheByEndpoint(config *CacheConfig) gin.HandlerFunc <span class="cov3" title="2">{
        return CacheMiddleware(config, EndpointCacheKey)
}</span>

// CustomCache customizable cache middleware
func CustomCache(ttl time.Duration, keyGen CacheKeyFunc, cacheType string) gin.HandlerFunc <span class="cov0" title="0">{
        config := &amp;CacheConfig{
                Type:       cacheType,
                DefaultTTL: ttl.String(),
                MaxSize:    1000,
        }

        return CacheMiddleware(config, keyGen)
}</span>

// ParseCacheArgs parses @Cache decorator arguments
func ParseCacheArgs(args []string) (time.Duration, string, CacheKeyFunc) <span class="cov5" title="4">{
        duration := 5 * time.Minute // default
        cacheType := "memory"       // default
        keyGen := URLCacheKey       // default

        for _, arg := range args </span><span class="cov3" title="2">{
                if strings.Contains(arg, "=") </span><span class="cov3" title="2">{
                        parts := strings.SplitN(arg, "=", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"'`)

                        switch key </span>{
                        case "duration", "ttl":<span class="cov1" title="1">
                                if parsed, err := time.ParseDuration(value); err == nil </span><span class="cov1" title="1">{
                                        duration = parsed
                                }</span>
                        case "type":<span class="cov0" title="0">
                                cacheType = value</span>
                        case "key", "by":<span class="cov0" title="0">
                                switch value </span>{
                                case "url":<span class="cov0" title="0">
                                        keyGen = URLCacheKey</span>
                                case "user":<span class="cov0" title="0">
                                        keyGen = UserURLCacheKey</span>
                                case "endpoint":<span class="cov0" title="0">
                                        keyGen = EndpointCacheKey</span>
                                }
                        }
                }
        }

        <span class="cov5" title="4">return duration, cacheType, keyGen</span>
}

// generateCacheKeyHash generates MD5 hash of the key for headers
func generateCacheKeyHash(key string) string <span class="cov7" title="10">{
        hash := sha256.Sum256([]byte(key))
        return fmt.Sprintf("%x", hash)[:8] // First 8 characters
}</span>

// CacheStatsHandler handler for cache statistics
func CacheStatsHandler(store CacheStore) gin.HandlerFunc <span class="cov3" title="2">{
        return func(c *gin.Context) </span><span class="cov3" title="2">{
                stats := store.Stats()
                c.JSON(http.StatusOK, gin.H{
                        "cache_stats": stats,
                })
        }</span>
}

// InvalidateCacheHandler handler to invalidate cache
func InvalidateCacheHandler(store CacheStore) gin.HandlerFunc <span class="cov3" title="2">{
        return func(c *gin.Context) </span><span class="cov3" title="2">{
                key := c.Query("key")

                if key == "" </span><span class="cov3" title="2">{
                        // Clear entire cache
                        if err := store.Clear(c.Request.Context()); err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "error":   "Failed to clear cache",
                                        "details": err.Error(),
                                })
                                return
                        }</span>

                        <span class="cov3" title="2">c.JSON(http.StatusOK, gin.H{
                                "message": "Cache completely cleared",
                        })
                        return</span>
                }

                // Clear specific key
                <span class="cov0" title="0">if err := store.Delete(c.Request.Context(), key); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error":   "Failed to invalidate cache",
                                "details": err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "message": fmt.Sprintf("Cache invalidated for key: %s", key),
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package decorators

import (
        "sync"
        "time"
)

// CircuitBreakerState represents the state of a circuit breaker
type CircuitBreakerState int

const (
        StateClosed CircuitBreakerState = iota
        StateOpen
        StateHalfOpen
)

// CircuitBreakerImpl implements the circuit breaker pattern
type CircuitBreakerImpl struct {
        state           CircuitBreakerState
        failureCount    int
        lastFailureTime time.Time
        lastSuccessTime time.Time

        // Configuration
        failureThreshold int
        recoveryTimeout  time.Duration

        mu sync.RWMutex
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(failureThreshold int, recoveryTimeout time.Duration) *CircuitBreakerImpl <span class="cov8" title="26">{
        return &amp;CircuitBreakerImpl{
                state:            StateClosed,
                failureThreshold: failureThreshold,
                recoveryTimeout:  recoveryTimeout,
        }
}</span>

// IsOpen checks if the circuit breaker is open
func (cb *CircuitBreakerImpl) IsOpen() bool <span class="cov9" title="32">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        switch cb.state </span>{
        case StateOpen:<span class="cov5" title="7">
                // Check if recovery timeout has passed
                if time.Since(cb.lastFailureTime) &gt;= cb.recoveryTimeout </span><span class="cov3" title="3">{
                        cb.state = StateHalfOpen
                }</span>
                <span class="cov5" title="7">return cb.state == StateOpen</span>

        case StateHalfOpen:<span class="cov0" title="0">
                return false</span> // Allow one request to test

        case StateClosed:<span class="cov8" title="25">
                return false</span>

        default:<span class="cov0" title="0">
                return false</span>
        }
}

// RecordSuccess records a successful request
func (cb *CircuitBreakerImpl) RecordSuccess() <span class="cov6" title="12">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.lastSuccessTime = time.Now()

        switch cb.state </span>{
        case StateHalfOpen:<span class="cov3" title="3">
                // Success in half-open state, close the circuit
                cb.state = StateClosed
                cb.failureCount = 0</span>
        case StateClosed:<span class="cov6" title="9">
                // Already closed, just update success time and reset failure count
                cb.failureCount = 0</span>
        }
}

// RecordFailure records a failed request
func (cb *CircuitBreakerImpl) RecordFailure() <span class="cov10" title="44">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.lastFailureTime = time.Now()
        cb.failureCount++

        switch cb.state </span>{
        case StateClosed:<span class="cov9" title="43">
                // Check if threshold reached
                if cb.failureCount &gt;= cb.failureThreshold </span><span class="cov4" title="5">{
                        cb.state = StateOpen
                }</span>
        case StateHalfOpen:<span class="cov0" title="0">
                // Failure in half-open state, open the circuit
                cb.state = StateOpen</span>
        }
}

// GetState returns the current state as a string
func (cb *CircuitBreakerImpl) GetState() string <span class="cov7" title="16">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        switch cb.state </span>{
        case StateClosed:<span class="cov6" title="11">
                return "closed"</span>
        case StateOpen:<span class="cov3" title="3">
                return "open"</span>
        case StateHalfOpen:<span class="cov2" title="2">
                return "half_open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// GetStats returns circuit breaker statistics
func (cb *CircuitBreakerImpl) GetStats() map[string]interface{} <span class="cov3" title="3">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        return map[string]interface{}{
                "state":             cb.GetState(),
                "failure_count":     cb.failureCount,
                "last_failure":      cb.lastFailureTime,
                "last_success":      cb.lastSuccessTime,
                "failure_threshold": cb.failureThreshold,
                "recovery_timeout":  cb.recoveryTimeout.String(),
        }
}</span>

// createCircuitBreaker creates a circuit breaker from configuration
func createCircuitBreaker(config *ProxyConfig) CircuitBreaker <span class="cov7" title="16">{
        failureThreshold := config.FailureThreshold
        if failureThreshold == 0 </span><span class="cov5" title="6">{
                failureThreshold = DefaultFailureThreshold
        }</span>

        <span class="cov7" title="16">recoveryTimeout, _ := time.ParseDuration(config.CircuitBreaker)
        if recoveryTimeout == 0 </span><span class="cov5" title="6">{
                recoveryTimeout = 30 * time.Second
        }</span>

        <span class="cov7" title="16">return NewCircuitBreaker(failureThreshold, recoveryTimeout)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package decorators

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"
        "time"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

// SDKGenerator interface for different SDK generators
type SDKGenerator interface {
        Generate(spec *OpenAPISpec, config *ClientSDKConfig) error
        GetLanguage() string
        GetFileExtension() string
}

// GoSDKGenerator generator for Go
type GoSDKGenerator struct{}

// PythonSDKGenerator generator for Python
type PythonSDKGenerator struct{}

// JavaScriptSDKGenerator generator for JavaScript
type JavaScriptSDKGenerator struct{}

// TypeScriptSDKGenerator generator for TypeScript
type TypeScriptSDKGenerator struct{}

// SDKManager manages SDK generation
type SDKManager struct {
        generators map[string]SDKGenerator
        config     ClientSDKConfig
}

// generateClassName generates a proper class name from package name
func generateClassName(packageName string) string <span class="cov0" title="0">{
        // Handle common patterns
        if strings.Contains(strings.ToLower(packageName), "api") </span><span class="cov0" title="0">{
                // Convert "testapi" to "TestAPIClient"
                parts := strings.Split(strings.ToLower(packageName), "api")
                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        prefix := parts[0]
                        if prefix != "" </span><span class="cov0" title="0">{
                                caser := cases.Title(language.English)
                                return caser.String(prefix) + "APIClient"
                        }</span>
                }
                <span class="cov0" title="0">return "APIClient"</span>
        }

        // Fallback: use Title case + "Client"
        <span class="cov0" title="0">caser := cases.Title(language.English)
        return caser.String(packageName) + "Client"</span>
}

// NewSDKManager creates new SDK manager
func NewSDKManager(config *ClientSDKConfig) *SDKManager <span class="cov0" title="0">{
        manager := &amp;SDKManager{
                generators: make(map[string]SDKGenerator),
                config:     *config,
        }

        // Register generatores
        manager.RegisterGenerator("go", &amp;GoSDKGenerator{})
        manager.RegisterGenerator("python", &amp;PythonSDKGenerator{})
        manager.RegisterGenerator("javascript", &amp;JavaScriptSDKGenerator{})
        manager.RegisterGenerator("typescript", &amp;TypeScriptSDKGenerator{})

        return manager
}</span>

// RegisterGenerator registers new generator
func (sm *SDKManager) RegisterGenerator(language string, generator SDKGenerator) <span class="cov0" title="0">{
        sm.generators[language] = generator
}</span>

// GenerateSDKs generates SDKs for all configured languages
func (sm *SDKManager) GenerateSDKs(spec *OpenAPISpec) error <span class="cov0" title="0">{
        if !sm.config.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create output directory
        <span class="cov0" title="0">if err := os.MkdirAll(sm.config.OutputDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating output directory: %v", err)
        }</span>

        // Generate for each language
        <span class="cov0" title="0">for _, language := range sm.config.Languages </span><span class="cov0" title="0">{
                if generator, exists := sm.generators[language]; exists </span><span class="cov0" title="0">{
                        fmt.Printf("Gerando SDK para %s...\n", language)
                        if err := generator.Generate(spec, &amp;sm.config); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error ao gerar SDK para %s: %v", language, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("Generator not found para linguagem: %s\n", language)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Go SDK Generator

// GetLanguage retorna a linguagem de programação usada.
func (g *GoSDKGenerator) GetLanguage() string <span class="cov0" title="0">{
        return "go"
}</span>

// GetFileExtension retorna a extensão de arquivo para a linguagem.
func (g *GoSDKGenerator) GetFileExtension() string <span class="cov0" title="0">{
        return ".go"
}</span>

// Generate creates a Go client SDK from the OpenAPI specification
func (g *GoSDKGenerator) Generate(spec *OpenAPISpec, config *ClientSDKConfig) error <span class="cov0" title="0">{
        outputDir := filepath.Join(config.OutputDir, "go")
        if err := os.MkdirAll(outputDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Template do cliente Go
        <span class="cov0" title="0">tmpl := `// Package {{.PackageName}} provides a client for the {{.ServiceName}} API
// Generated automatically by gin-decorators on {{.GeneratedAt}}
package {{.PackageName}}

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"
        "time"
)

// Client represents the API client
type Client struct {
        BaseURL    string
        HTTPClient *http.Client
        APIKey     string
        UserAgent  string
}

// NewClient creates a new API client
func NewClient(baseURL string) *Client {
        return &amp;Client{
                BaseURL: strings.TrimSuffix(baseURL, "/"),
                HTTPClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                UserAgent: "{{.PackageName}}-go-client/1.0.0",
        }
}

// SetAPIKey sets the API key for authentication
func (c *Client) SetAPIKey(apiKey string) {
        c.APIKey = apiKey
}

// SetTimeout sets the HTTP client timeout
func (c *Client) SetTimeout(timeout time.Duration) {
        c.HTTPClient.Timeout = timeout
}

{{range .Endpoints}}
// {{.FunctionName}} {{.Description}}
func (c *Client) {{.FunctionName}}(ctx context.Context{{.ParametersSignature}}) ({{.ReturnType}}, error) {
        {{.URLConstruction}}
        
        {{.RequestBody}}
        
        req, err := http.NewRequestWithContext(ctx, "{{.Method}}", url, {{.RequestBodyVar}})
        if err != nil {
                return {{.ZeroValue}}, fmt.Errorf("error creating request: %w", err)
        }

        {{.Headers}}

        resp, err := c.HTTPClient.Do(req)
        if err != nil {
                return {{.ZeroValue}}, fmt.Errorf("error making request: %w", err)
        }
        defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 {
                return {{.ZeroValue}}, fmt.Errorf("API error: %s", resp.Status)
        }

        {{.ResponseHandling}}
}
{{end}}

// Error represents an API error
type Error struct {
        Code    int    ` + "`json:\"code\"`" + `
        Message string ` + "`json:\"message\"`" + `
}

func (e Error) Error() string {
        return fmt.Sprintf("API error %d: %s", e.Code, e.Message)
}
`

        data := g.prepareTemplateData(spec, config)
        return g.executeTemplate(tmpl, data, filepath.Join(outputDir, "client.go"))</span>
}

func (g *GoSDKGenerator) prepareTemplateData(spec *OpenAPISpec, config *ClientSDKConfig) map[string]interface{} <span class="cov0" title="0">{
        endpoints := make([]map[string]interface{}, 0)

        for path, pathItem := range spec.Paths </span><span class="cov0" title="0">{
                for method, operation := range pathItem </span><span class="cov0" title="0">{
                        endpoint := map[string]interface{}{
                                "FunctionName":        g.generateFunctionName(method, path),
                                "Description":         operation.Summary,
                                "Method":              strings.ToUpper(method),
                                "Path":                path,
                                "ParametersSignature": g.generateParametersSignature(operation.Parameters),
                                "URLConstruction":     g.generateURLConstruction(path, operation.Parameters),
                                "RequestBody":         g.generateRequestBody(operation.RequestBody),
                                "RequestBodyVar":      g.getRequestBodyVar(operation.RequestBody),
                                "Headers":             g.generateHeaders(),
                                "ReturnType":          g.generateReturnType(operation.Responses),
                                "ZeroValue":           g.generateZeroValue(operation.Responses),
                                "ResponseHandling":    g.generateResponseHandling(operation.Responses),
                        }
                        endpoints = append(endpoints, endpoint)
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "PackageName": config.PackageName,
                "ClassName":   generateClassName(config.PackageName),
                "ServiceName": spec.Info.Title,
                "GeneratedAt": time.Now().Format("2006-01-02 15:04:05"),
                "Endpoints":   endpoints,
        }</span>
}

func (g *GoSDKGenerator) generateFunctionName(method, path string) string <span class="cov0" title="0">{
        // Convert method and path to function name
        parts := strings.Split(strings.Trim(path, "/"), "/")
        var name strings.Builder

        // Map HTTP methods to more descriptive prefixes
        methodPrefix := map[string]string{
                "GET":    "Get",
                "POST":   "Create",
                "PUT":    "Update",
                "DELETE": "Delete",
                "PATCH":  "Patch",
        }

        prefix, exists := methodPrefix[strings.ToUpper(method)]
        if exists </span><span class="cov0" title="0">{
                name.WriteString(prefix)
        }</span> else<span class="cov0" title="0"> {
                // Use cases.Title instead of deprecated strings.Title
                caser := cases.Title(language.English)
                name.WriteString(caser.String(strings.ToLower(method)))
        }</span>

        <span class="cov0" title="0">for _, part := range parts </span><span class="cov0" title="0">{
                if !strings.HasPrefix(part, "{") </span><span class="cov0" title="0">{
                        // Handle special cases like "api/v1" -&gt; "APIV1"
                        switch part </span>{
                        case "api":<span class="cov0" title="0">
                                name.WriteString("API")</span>
                        case "v1":<span class="cov0" title="0">
                                name.WriteString("V1")</span>
                        default:<span class="cov0" title="0">
                                // Use cases.Title instead of deprecated strings.Title
                                caser := cases.Title(language.English)
                                name.WriteString(caser.String(part))</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Handle path parameters like {id} -&gt; ByID
                        paramName := strings.Trim(part, "{}")
                        switch paramName </span>{
                        case "id":<span class="cov0" title="0">
                                name.WriteString("ByID")</span>
                        default:<span class="cov0" title="0">
                                // Use cases.Title instead of deprecated strings.Title
                                caser := cases.Title(language.English)
                                name.WriteString("By" + caser.String(paramName))</span>
                        }
                }
        }

        <span class="cov0" title="0">return name.String()</span>
}

func (g *GoSDKGenerator) generateParametersSignature(params []OpenAPIParameter) string <span class="cov0" title="0">{
        parts := make([]string, 0, len(params))
        for _, param := range params </span><span class="cov0" title="0">{
                goType := g.convertTypeToGo(param.Schema.Type)
                parts = append(parts, fmt.Sprintf(", %s %s", param.Name, goType))
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, "")</span>
}

func (g *GoSDKGenerator) generateURLConstruction(path string, params []OpenAPIParameter) string <span class="cov0" title="0">{
        // Replace path parameters and build query
        code := fmt.Sprintf("url := c.BaseURL + %q", path)

        // Replace path parameters
        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "path" </span><span class="cov0" title="0">{
                        code = strings.ReplaceAll(code, "{"+param.Name+"}", fmt.Sprintf("\" + %s + \"", param.Name))
                }</span>
        }

        // Add query parameters
        <span class="cov0" title="0">queryParams := make([]string, 0)
        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "query" </span><span class="cov0" title="0">{
                        queryParams = append(queryParams, param.Name)
                }</span>
        }

        <span class="cov0" title="0">if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                code += "\n\tvalues := url.Values{}\n"
                for _, param := range queryParams </span><span class="cov0" title="0">{
                        code += fmt.Sprintf("\tvalues.Set(%q, %s)\n", param, param)
                }</span>
                <span class="cov0" title="0">code += "\turl += \"?\" + values.Encode()"</span>
        }

        <span class="cov0" title="0">return code</span>
}

func (g *GoSDKGenerator) generateRequestBody(body *OpenAPIRequestBody) string <span class="cov0" title="0">{
        if body == nil </span><span class="cov0" title="0">{
                return "var body io.Reader"
        }</span>
        <span class="cov0" title="0">return `jsonBody, _ := json.Marshal(requestBody)
        body := bytes.NewBuffer(jsonBody)`</span>
}

func (g *GoSDKGenerator) getRequestBodyVar(body *OpenAPIRequestBody) string <span class="cov0" title="0">{
        if body == nil </span><span class="cov0" title="0">{
                return "nil"
        }</span>
        <span class="cov0" title="0">return "body"</span>
}

func (g *GoSDKGenerator) generateHeaders() string <span class="cov0" title="0">{
        return `req.Header.Set("Content-Type", "application/json")
        req.Header.Set("User-Agent", c.UserAgent)
        if c.APIKey != "" {
                req.Header.Set("Authorization", "Bearer " + c.APIKey)
        }`
}</span>

func (g *GoSDKGenerator) generateReturnType(_ map[string]OpenAPIResponse) string <span class="cov0" title="0">{
        return "interface{}" // Simplificado
}</span>

func (g *GoSDKGenerator) generateZeroValue(_ map[string]OpenAPIResponse) string <span class="cov0" title="0">{
        return "nil"
}</span>

func (g *GoSDKGenerator) generateResponseHandling(_ map[string]OpenAPIResponse) string <span class="cov0" title="0">{
        return `body, err := io.ReadAll(resp.Body)
        if err != nil {
                return nil, fmt.Errorf("error reading response: %w", err)
        }

        var result interface{}
        if err := json.Unmarshal(body, &amp;result); err != nil {
                return nil, fmt.Errorf("error parsing response: %w", err)
        }

        return result, nil`
}</span>

func (g *GoSDKGenerator) convertTypeToGo(openAPIType string) string <span class="cov0" title="0">{
        switch openAPIType </span>{
        case "string":<span class="cov0" title="0">
                return "string"</span>
        case "integer":<span class="cov0" title="0">
                return "int"</span>
        case "number":<span class="cov0" title="0">
                return "float64"</span>
        case "boolean":<span class="cov0" title="0">
                return "bool"</span>
        case "array":<span class="cov0" title="0">
                return "[]interface{}"</span>
        case "object":<span class="cov0" title="0">
                return "map[string]interface{}"</span>
        default:<span class="cov0" title="0">
                return "interface{}"</span>
        }
}

func (g *GoSDKGenerator) executeTemplate(tmplStr string, data interface{}, outputPath string) error <span class="cov0" title="0">{
        tmpl, err := template.New("client").Parse(tmplStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return tmpl.Execute(file, data)</span>
}

// Python SDK Generator

// GetLanguage retorna a linguagem de programação usada.
func (p *PythonSDKGenerator) GetLanguage() string <span class="cov0" title="0">{
        return "python"
}</span>

// GetFileExtension retorna a extensão de arquivo para a linguagem.
func (p *PythonSDKGenerator) GetFileExtension() string <span class="cov0" title="0">{
        return ".py"
}</span>

// Generate creates a Python client SDK from the OpenAPI specification
func (p *PythonSDKGenerator) Generate(spec *OpenAPISpec, config *ClientSDKConfig) error <span class="cov0" title="0">{
        outputDir := filepath.Join(config.OutputDir, "python")
        if err := os.MkdirAll(outputDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Template do cliente Python
        <span class="cov0" title="0">tmpl := `"""
{{.ServiceName}} API Client
Generated automatically by gin-decorators on {{.GeneratedAt}}
"""

import requests
import json
from typing import Dict, Any, Optional
from urllib.parse import urljoin, urlencode


class {{.ClassName}}:
    """Client for {{.ServiceName}} API"""
    
    def __init__(self, base_url: str, api_key: Optional[str] = None):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': '{{.PackageName}}-python-client/1.0.0'
        })
        
        if api_key:
            self.session.headers['Authorization'] = f'Bearer {api_key}'
    
    def set_api_key(self, api_key: str):
        """Set API key for authentication"""
        self.api_key = api_key
        self.session.headers['Authorization'] = f'Bearer {api_key}'
    
{{range .Endpoints}}
    def {{.FunctionName}}(self{{.ParametersSignature}}) -&gt; Dict[str, Any]:
        """{{.Description}}"""
        {{.URLConstruction}}
        
        {{.RequestBody}}
        
        response = self.session.{{.Method}}(url{{.RequestBodyParam}})
        response.raise_for_status()
        
        return response.json()
{{end}}


class APIError(Exception):
    """API Error Exception"""
    
    def __init__(self, message: str, status_code: int = None):
        self.message = message
        self.status_code = status_code
        super().__init__(self.message)
`

        data := p.prepareTemplateData(spec, config)
        return p.executeTemplate(tmpl, data, filepath.Join(outputDir, "client.py"))</span>
}

func (p *PythonSDKGenerator) prepareTemplateData(spec *OpenAPISpec, config *ClientSDKConfig) map[string]interface{} <span class="cov0" title="0">{
        // Generate proper class name (e.g., "testapi" -&gt; "TestAPIClient")
        className := generateClassName(config.PackageName)
        endpoints := make([]map[string]interface{}, 0)

        for path, pathItem := range spec.Paths </span><span class="cov0" title="0">{
                for method, operation := range pathItem </span><span class="cov0" title="0">{
                        endpoint := map[string]interface{}{
                                "FunctionName":        p.generateFunctionName(method, path),
                                "Description":         operation.Summary,
                                "Method":              strings.ToLower(method),
                                "Path":                path,
                                "ParametersSignature": p.generateParametersSignature(operation.Parameters),
                                "URLConstruction":     p.generateURLConstruction(path, operation.Parameters),
                                "RequestBody":         p.generateRequestBody(operation.RequestBody),
                                "RequestBodyParam":    p.getRequestBodyParam(operation.RequestBody),
                        }
                        endpoints = append(endpoints, endpoint)
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "PackageName": config.PackageName,
                "ClassName":   className,
                "ServiceName": spec.Info.Title,
                "GeneratedAt": time.Now().Format("2006-01-02 15:04:05"),
                "Endpoints":   endpoints,
        }</span>
}

func (p *PythonSDKGenerator) generateFunctionName(method, path string) string <span class="cov0" title="0">{
        // Convert to snake_case with more descriptive method names
        parts := strings.Split(strings.Trim(path, "/"), "/")
        var name strings.Builder

        // Map HTTP methods to more descriptive prefixes
        methodPrefix := map[string]string{
                "GET":    "get",
                "POST":   "create",
                "PUT":    "update",
                "DELETE": "delete",
                "PATCH":  "patch",
        }

        prefix, exists := methodPrefix[strings.ToUpper(method)]
        if exists </span><span class="cov0" title="0">{
                name.WriteString(prefix)
        }</span> else<span class="cov0" title="0"> {
                name.WriteString(strings.ToLower(method))
        }</span>

        <span class="cov0" title="0">for _, part := range parts </span><span class="cov0" title="0">{
                if !strings.HasPrefix(part, "{") </span><span class="cov0" title="0">{
                        name.WriteString("_")
                        name.WriteString(strings.ToLower(part))
                }</span> else<span class="cov0" title="0"> {
                        // Handle path parameters like {id} -&gt; _by_id
                        paramName := strings.Trim(part, "{}")
                        name.WriteString("_by_")
                        name.WriteString(strings.ToLower(paramName))
                }</span>
        }

        <span class="cov0" title="0">return name.String()</span>
}

func (p *PythonSDKGenerator) generateParametersSignature(params []OpenAPIParameter) string <span class="cov0" title="0">{
        parts := make([]string, 0, len(params))
        for _, param := range params </span><span class="cov0" title="0">{
                pythonType := p.convertTypeToPython(param.Schema.Type)
                parts = append(parts, fmt.Sprintf(", %s: %s", param.Name, pythonType))
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, "")</span>
}

func (p *PythonSDKGenerator) generateURLConstruction(path string, params []OpenAPIParameter) string <span class="cov0" title="0">{
        code := fmt.Sprintf("url = f'{self.base_url}%s'", path)

        // Replace path parameters
        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "path" </span><span class="cov0" title="0">{
                        code = strings.ReplaceAll(code, "{"+param.Name+"}", fmt.Sprintf("{%s}", param.Name))
                }</span>
        }

        // Add query parameters
        <span class="cov0" title="0">queryParams := make([]string, 0)
        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "query" </span><span class="cov0" title="0">{
                        queryParams = append(queryParams, param.Name)
                }</span>
        }

        <span class="cov0" title="0">if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                code += "\n        params = {}\n"
                for _, param := range queryParams </span><span class="cov0" title="0">{
                        code += fmt.Sprintf("        params['%s'] = %s\n", param, param)
                }</span>
                <span class="cov0" title="0">code += "        url += '?' + urlencode(params)"</span>
        }

        <span class="cov0" title="0">return code</span>
}

func (p *PythonSDKGenerator) generateRequestBody(body *OpenAPIRequestBody) string <span class="cov0" title="0">{
        if body == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return "json_data = json.dumps(request_body)"</span>
}

func (p *PythonSDKGenerator) getRequestBodyParam(body *OpenAPIRequestBody) string <span class="cov0" title="0">{
        if body == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return ", json=request_body"</span>
}

func (p *PythonSDKGenerator) convertTypeToPython(openAPIType string) string <span class="cov0" title="0">{
        switch openAPIType </span>{
        case "string":<span class="cov0" title="0">
                return "str"</span>
        case "integer":<span class="cov0" title="0">
                return "int"</span>
        case "number":<span class="cov0" title="0">
                return "float"</span>
        case "boolean":<span class="cov0" title="0">
                return "bool"</span>
        case "array":<span class="cov0" title="0">
                return "List"</span>
        case "object":<span class="cov0" title="0">
                return "Dict"</span>
        default:<span class="cov0" title="0">
                return "Any"</span>
        }
}

func (p *PythonSDKGenerator) executeTemplate(tmplStr string, data interface{}, outputPath string) error <span class="cov0" title="0">{
        tmpl, err := template.New("client").Parse(tmplStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return tmpl.Execute(file, data)</span>
}

// JavaScript SDK Generator

// GetLanguage retorna a linguagem de programação usada.
func (j *JavaScriptSDKGenerator) GetLanguage() string <span class="cov0" title="0">{
        return "javascript"
}</span>

// GetFileExtension retorna a extensão de arquivo para a linguagem.
func (j *JavaScriptSDKGenerator) GetFileExtension() string <span class="cov0" title="0">{
        return ".js"
}</span>

// Generate creates a JavaScript client SDK from the OpenAPI specification
func (j *JavaScriptSDKGenerator) Generate(spec *OpenAPISpec, config *ClientSDKConfig) error <span class="cov0" title="0">{
        outputDir := filepath.Join(config.OutputDir, "javascript")
        if err := os.MkdirAll(outputDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Template JavaScript
        <span class="cov0" title="0">tmpl := `/**
 * {{.ServiceName}} API Client
 * Generated automatically by gin-decorators on {{.GeneratedAt}}
 */

class {{.ClassName}} {
    constructor(baseURL, apiKey = null) {
        this.baseURL = baseURL.replace(/\/$/, '');
        this.apiKey = apiKey;
        this.defaultHeaders = {
            'Content-Type': 'application/json',
            'User-Agent': '{{.PackageName}}-js-client/1.0.0'
        };
        
        if (apiKey) {
            this.defaultHeaders['Authorization'] = ` + "`Bearer ${apiKey}`" + `;
        }
    }
    
    setApiKey(apiKey) {
        this.apiKey = apiKey;
        this.defaultHeaders['Authorization'] = ` + "`Bearer ${apiKey}`" + `;
    }

{{range .Endpoints}}
    async {{.FunctionName}}({{.ParametersSignature}}) {
        {{.URLConstruction}}
        
        const options = {
            method: '{{.Method}}',
            headers: this.defaultHeaders{{.RequestBody}}
        };
        
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(` + "`API Error: ${response.status} ${response.statusText}`" + `);
        }
        
        return await response.json();
    }
{{end}}
}

module.exports = {{.ClassName}};
`

        data := j.prepareTemplateData(spec, config)
        return j.executeTemplate(tmpl, data, filepath.Join(outputDir, "client.js"))</span>
}

func (j *JavaScriptSDKGenerator) prepareTemplateData(spec *OpenAPISpec, config *ClientSDKConfig) map[string]interface{} <span class="cov0" title="0">{
        // Generate proper class name
        className := generateClassName(config.PackageName)
        endpoints := make([]map[string]interface{}, 0)

        for path, pathItem := range spec.Paths </span><span class="cov0" title="0">{
                for method, operation := range pathItem </span><span class="cov0" title="0">{
                        endpoint := map[string]interface{}{
                                "FunctionName":        j.generateFunctionName(method, path),
                                "Method":              strings.ToUpper(method),
                                "ParametersSignature": j.generateParametersSignature(operation.Parameters),
                                "URLConstruction":     j.generateURLConstruction(path, operation.Parameters),
                                "RequestBody":         j.generateRequestBody(operation.RequestBody),
                        }
                        endpoints = append(endpoints, endpoint)
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "PackageName": config.PackageName,
                "ClassName":   className,
                "ServiceName": spec.Info.Title,
                "GeneratedAt": time.Now().Format("2006-01-02 15:04:05"),
                "Endpoints":   endpoints,
        }</span>
}

func (j *JavaScriptSDKGenerator) generateFunctionName(method, path string) string <span class="cov0" title="0">{
        // Convert to camelCase
        parts := strings.Split(strings.Trim(path, "/"), "/")
        var name strings.Builder
        name.WriteString(strings.ToLower(method))

        // Use cases.Title instead of deprecated strings.Title
        caser := cases.Title(language.English)
        for _, part := range parts </span><span class="cov0" title="0">{
                if !strings.HasPrefix(part, "{") </span><span class="cov0" title="0">{
                        name.WriteString(caser.String(part))
                }</span>
        }

        <span class="cov0" title="0">return name.String()</span>
}

func (j *JavaScriptSDKGenerator) generateParametersSignature(params []OpenAPIParameter) string <span class="cov0" title="0">{
        parts := make([]string, 0, len(params))
        for _, param := range params </span><span class="cov0" title="0">{
                parts = append(parts, param.Name)
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, ", ")</span>
}

func (j *JavaScriptSDKGenerator) generateURLConstruction(path string, params []OpenAPIParameter) string <span class="cov0" title="0">{
        code := fmt.Sprintf("let url = `${this.baseURL}%s`;", path)

        // Replace path parameters
        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "path" </span><span class="cov0" title="0">{
                        code = strings.ReplaceAll(code, "{"+param.Name+"}", "${"+param.Name+"}")
                }</span>
        }

        // Add query parameters
        <span class="cov0" title="0">queryParams := make([]string, 0)
        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "query" </span><span class="cov0" title="0">{
                        queryParams = append(queryParams, param.Name)
                }</span>
        }

        <span class="cov0" title="0">if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                code += "\n        const params = new URLSearchParams();\n"
                for _, param := range queryParams </span><span class="cov0" title="0">{
                        code += fmt.Sprintf("        params.append('%s', %s);\n", param, param)
                }</span>
                <span class="cov0" title="0">code += "        url += '?' + params.toString();"</span>
        }

        <span class="cov0" title="0">return code</span>
}

func (j *JavaScriptSDKGenerator) generateRequestBody(body *OpenAPIRequestBody) string <span class="cov0" title="0">{
        if body == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return ",\n            body: JSON.stringify(requestBody)"</span>
}

func (j *JavaScriptSDKGenerator) executeTemplate(tmplStr string, data interface{}, outputPath string) error <span class="cov0" title="0">{
        tmpl, err := template.New("client").Parse(tmplStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return tmpl.Execute(file, data)</span>
}

// TypeScript SDK Generator

// GetLanguage retorna a linguagem de programação usada.
func (t *TypeScriptSDKGenerator) GetLanguage() string <span class="cov0" title="0">{
        return "typescript"
}</span>

// GetFileExtension retorna a extensão de arquivo para a linguagem.
func (t *TypeScriptSDKGenerator) GetFileExtension() string <span class="cov0" title="0">{
        return ".ts"
}</span>

// Generate creates a TypeScript client SDK from the OpenAPI specification
func (t *TypeScriptSDKGenerator) Generate(spec *OpenAPISpec, config *ClientSDKConfig) error <span class="cov0" title="0">{
        outputDir := filepath.Join(config.OutputDir, "typescript")
        if err := os.MkdirAll(outputDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TypeScript template (similar to JavaScript but with types)
        <span class="cov0" title="0">tmpl := `/**
 * {{.ServiceName}} API Client
 * Generated automatically by gin-decorators on {{.GeneratedAt}}
 */

export class {{.ClassName}} {
    private baseURL: string;
    private apiKey: string | null;
    private defaultHeaders: Record&lt;string, string&gt;;

    constructor(baseURL: string, apiKey: string | null = null) {
        this.baseURL = baseURL.replace(/\/$/, '');
        this.apiKey = apiKey;
        this.defaultHeaders = {
            'Content-Type': 'application/json',
            'User-Agent': '{{.PackageName}}-ts-client/1.0.0'
        };
        
        if (apiKey) {
            this.defaultHeaders['Authorization'] = ` + "`Bearer ${apiKey}`" + `;
        }
    }
    
    setApiKey(apiKey: string): void {
        this.apiKey = apiKey;
        this.defaultHeaders['Authorization'] = ` + "`Bearer ${apiKey}`" + `;
    }

{{range .Endpoints}}
    async {{.FunctionName}}({{.ParametersSignature}}): Promise&lt;any&gt; {
        {{.URLConstruction}}
        
        const options: RequestInit = {
            method: '{{.Method}}',
            headers: this.defaultHeaders{{.RequestBody}}
        };
        
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(` + "`API Error: ${response.status} ${response.statusText}`" + `);
        }
        
        return await response.json();
    }
{{end}}
}

export class APIError extends Error {
    public statusCode?: number;
    
    constructor(message: string, statusCode?: number) {
        super(message);
        this.statusCode = statusCode;
        this.name = 'APIError';
    }
}
`

        data := t.prepareTemplateData(spec, config)
        return t.executeTemplate(tmpl, data, filepath.Join(outputDir, "client.ts"))</span>
}

func (t *TypeScriptSDKGenerator) prepareTemplateData(spec *OpenAPISpec, config *ClientSDKConfig) map[string]interface{} <span class="cov0" title="0">{
        // Generate proper class name
        className := generateClassName(config.PackageName)
        endpoints := make([]map[string]interface{}, 0)

        for path, pathItem := range spec.Paths </span><span class="cov0" title="0">{
                for method, operation := range pathItem </span><span class="cov0" title="0">{
                        endpoint := map[string]interface{}{
                                "FunctionName":        t.generateFunctionName(method, path),
                                "Method":              strings.ToUpper(method),
                                "ParametersSignature": t.generateParametersSignature(operation.Parameters),
                                "URLConstruction":     t.generateURLConstruction(path, operation.Parameters),
                                "RequestBody":         t.generateRequestBody(operation.RequestBody),
                        }
                        endpoints = append(endpoints, endpoint)
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "PackageName": config.PackageName,
                "ClassName":   className,
                "ServiceName": spec.Info.Title,
                "GeneratedAt": time.Now().Format("2006-01-02 15:04:05"),
                "Endpoints":   endpoints,
        }</span>
}

func (t *TypeScriptSDKGenerator) generateFunctionName(method, path string) string <span class="cov0" title="0">{
        // Similar to JavaScript
        parts := strings.Split(strings.Trim(path, "/"), "/")
        var name strings.Builder
        name.WriteString(strings.ToLower(method))

        // Use cases.Title instead of deprecated strings.Title
        caser := cases.Title(language.English)
        for _, part := range parts </span><span class="cov0" title="0">{
                if !strings.HasPrefix(part, "{") </span><span class="cov0" title="0">{
                        name.WriteString(caser.String(part))
                }</span>
        }

        <span class="cov0" title="0">return name.String()</span>
}

func (t *TypeScriptSDKGenerator) generateParametersSignature(params []OpenAPIParameter) string <span class="cov0" title="0">{
        parts := make([]string, 0, len(params))
        for _, param := range params </span><span class="cov0" title="0">{
                tsType := t.convertTypeToTypeScript(param.Schema.Type)
                parts = append(parts, fmt.Sprintf("%s: %s", param.Name, tsType))
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, ", ")</span>
}

func (t *TypeScriptSDKGenerator) generateURLConstruction(path string, params []OpenAPIParameter) string <span class="cov0" title="0">{
        // Similar to JavaScript
        code := fmt.Sprintf("let url = `${this.baseURL}%s`;", path)

        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "path" </span><span class="cov0" title="0">{
                        code = strings.ReplaceAll(code, "{"+param.Name+"}", "${"+param.Name+"}")
                }</span>
        }

        <span class="cov0" title="0">queryParams := make([]string, 0)
        for _, param := range params </span><span class="cov0" title="0">{
                if param.In == "query" </span><span class="cov0" title="0">{
                        queryParams = append(queryParams, param.Name)
                }</span>
        }

        <span class="cov0" title="0">if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                code += "\n        const params = new URLSearchParams();\n"
                for _, param := range queryParams </span><span class="cov0" title="0">{
                        code += fmt.Sprintf("        params.append('%s', %s.toString());\n", param, param)
                }</span>
                <span class="cov0" title="0">code += "        url += '?' + params.toString();"</span>
        }

        <span class="cov0" title="0">return code</span>
}

func (t *TypeScriptSDKGenerator) generateRequestBody(body *OpenAPIRequestBody) string <span class="cov0" title="0">{
        if body == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return ",\n            body: JSON.stringify(requestBody)"</span>
}

func (t *TypeScriptSDKGenerator) convertTypeToTypeScript(openAPIType string) string <span class="cov0" title="0">{
        switch openAPIType </span>{
        case "string":<span class="cov0" title="0">
                return "string"</span>
        case "integer":<span class="cov0" title="0">
                return "number"</span>
        case "number":<span class="cov0" title="0">
                return "number"</span>
        case "boolean":<span class="cov0" title="0">
                return "boolean"</span>
        case "array":<span class="cov0" title="0">
                return "any[]"</span>
        case "object":<span class="cov0" title="0">
                return "Record&lt;string, any&gt;"</span>
        default:<span class="cov0" title="0">
                return "any"</span>
        }
}

func (t *TypeScriptSDKGenerator) executeTemplate(tmplStr string, data interface{}, outputPath string) error <span class="cov0" title="0">{
        tmpl, err := template.New("client").Parse(tmplStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        return tmpl.Execute(file, data)</span>
}

// GenerateClientSDKs generates client SDKs for multiple languages
func GenerateClientSDKs(config *ClientSDKConfig) error <span class="cov0" title="0">{
        if !config.Enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Generate spec OpenAPI
        <span class="cov0" title="0">defaultConfig := DefaultConfig()
        spec := GenerateOpenAPISpec(defaultConfig)

        // Create manager and generate SDKs
        manager := NewSDKManager(config)
        return manager.GenerateSDKs(spec)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package decorators

import (
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config framework configuration structure
type Config struct {
        Version    string              `yaml:"version"`
        Handlers   HandlersConfig      `yaml:"handlers"`
        Generate   GenerationConfig    `yaml:"generation"`
        Dev        DevConfig           `yaml:"dev"`
        Prod       ProdConfig          `yaml:"prod"`
        Redis      RedisConfig         `yaml:"redis,omitempty"`
        Cache      CacheConfig         `yaml:"cache,omitempty"`
        RateLimit  RateLimitConfig     `yaml:"rate_limit,omitempty"`
        Metrics    MetricsConfig       `yaml:"metrics,omitempty"`
        OpenAPI    OpenAPIConfig       `yaml:"openapi,omitempty"`
        Validation ValidationConfig    `yaml:"validation,omitempty"`
        WebSocket  WebSocketConfig     `yaml:"websocket,omitempty"`
        Telemetry  TelemetryConfig     `yaml:"telemetry,omitempty"`
        ClientSDK  ClientSDKConfig     `yaml:"client_sdk,omitempty"`
        Proxy      ProxyConfigSettings `yaml:"proxy,omitempty"`
}

// HandlersConfig configuration for handlers discovery
type HandlersConfig struct {
        Include []string `yaml:"include"`
        Exclude []string `yaml:"exclude"`
}

// GenerationConfig configuration for code generation
type GenerationConfig struct {
        Template string `yaml:"template,omitempty"`
}

// DevConfig configuration for development mode
type DevConfig struct {
        AutoDiscover bool `yaml:"auto_discover"`
        Watch        bool `yaml:"watch"`
}

// ProdConfig configuration for production mode
type ProdConfig struct {
        Validate bool `yaml:"validate"`
        Minify   bool `yaml:"minify"`
}

// RedisConfig Redis configuration
type RedisConfig struct {
        Enabled  bool   `yaml:"enabled"`
        Address  string `yaml:"address"`
        Password string `yaml:"password,omitempty"`
        DB       int    `yaml:"db"`
        PoolSize int    `yaml:"pool_size"`
}

// CacheConfig cache system configuration
type CacheConfig struct {
        Type        string `yaml:"type"` // "memory", "redis"
        DefaultTTL  string `yaml:"default_ttl"`
        MaxSize     int    `yaml:"max_size,omitempty"`
        Compression bool   `yaml:"compression"`
}

// RateLimitConfig rate limiting configuration
type RateLimitConfig struct {
        Enabled    bool   `yaml:"enabled"`
        Type       string `yaml:"type"` // "memory", "redis"
        DefaultRPS int    `yaml:"default_rps"`
        BurstSize  int    `yaml:"burst_size"`
        KeyFunc    string `yaml:"key_func"` // "ip", "user", "custom"
}

// MetricsConfig Prometheus configuration
type MetricsConfig struct {
        Enabled   bool      `yaml:"enabled"`
        Endpoint  string    `yaml:"endpoint"`
        Namespace string    `yaml:"namespace"`
        Subsystem string    `yaml:"subsystem"`
        Buckets   []float64 `yaml:"buckets,omitempty"`
}

// OpenAPIConfig OpenAPI documentation configuration
type OpenAPIConfig struct {
        Version     string                 `yaml:"version"`
        Title       string                 `yaml:"title"`
        Description string                 `yaml:"description"`
        Host        string                 `yaml:"host"`
        BasePath    string                 `yaml:"base_path"`
        Schemes     []string               `yaml:"schemes"`
        Contact     map[string]interface{} `yaml:"contact,omitempty"`
        License     map[string]interface{} `yaml:"license,omitempty"`
        Security    []map[string][]string  `yaml:"security,omitempty"`
}

// ValidationConfig validation configuration
type ValidationConfig struct {
        Enabled       bool     `yaml:"enabled"`
        FailFast      bool     `yaml:"fail_fast"`
        CustomTags    []string `yaml:"custom_tags,omitempty"`
        ErrorFormat   string   `yaml:"error_format"`
        TranslateFunc string   `yaml:"translate_func,omitempty"`
}

// WebSocketConfig WebSocket configuration
type WebSocketConfig struct {
        Enabled      bool   `yaml:"enabled"`
        ReadBuffer   int    `yaml:"read_buffer"`
        WriteBuffer  int    `yaml:"write_buffer"`
        CheckOrigin  bool   `yaml:"check_origin"`
        Compression  bool   `yaml:"compression"`
        PingInterval string `yaml:"ping_interval"`
        PongTimeout  string `yaml:"pong_timeout"`
}

// TelemetryConfig OpenTelemetry configuration
type TelemetryConfig struct {
        Enabled        bool    `yaml:"enabled"`
        ServiceName    string  `yaml:"service_name"`
        ServiceVersion string  `yaml:"service_version"`
        Environment    string  `yaml:"environment"`
        Endpoint       string  `yaml:"endpoint"`
        Insecure       bool    `yaml:"insecure"`
        SampleRate     float64 `yaml:"sample_rate"`
}

// ClientSDKConfig SDK generation configuration
type ClientSDKConfig struct {
        Enabled     bool     `yaml:"enabled"`
        OutputDir   string   `yaml:"output_dir"`
        Languages   []string `yaml:"languages"` // "go", "python", "javascript", "typescript"
        PackageName string   `yaml:"package_name"`
        ModuleName  string   `yaml:"module_name,omitempty"`
}

// ProxyConfigSettings configuration for proxy functionality
type ProxyConfigSettings struct {
        Enabled bool `yaml:"enabled"`

        // Service Discovery
        ServiceDiscovery ServiceDiscoveryConfig `yaml:"service_discovery"`

        // Load Balancing
        LoadBalancing LoadBalancingConfig `yaml:"load_balancing"`

        // Circuit Breaker
        CircuitBreaker CircuitBreakerConfig `yaml:"circuit_breaker"`

        // Retry
        Retry RetryConfig `yaml:"retry"`

        // HTTP Client
        HTTPClient HTTPClientConfig `yaml:"http_client"`
}

// ServiceDiscoveryConfig configuration for service discovery
type ServiceDiscoveryConfig struct {
        Consul     ConsulConfig     `yaml:"consul"`
        Kubernetes KubernetesConfig `yaml:"kubernetes"`
        DNS        DNSConfig        `yaml:"dns"`
}

// ConsulConfig configuration for Consul service discovery
type ConsulConfig struct {
        Enabled    bool   `yaml:"enabled"`
        Address    string `yaml:"address"`
        Datacenter string `yaml:"datacenter"`
}

// KubernetesConfig configuration for Kubernetes service discovery
type KubernetesConfig struct {
        Enabled bool `yaml:"enabled"`
}

// DNSConfig configuration for DNS service discovery
type DNSConfig struct {
        Enabled bool `yaml:"enabled"`
}

// LoadBalancingConfig configuration for load balancing
type LoadBalancingConfig struct {
        DefaultAlgorithm    string `yaml:"default_algorithm"`
        HealthCheckInterval string `yaml:"health_check_interval"`
        HealthCheckTimeout  string `yaml:"health_check_timeout"`
}

// CircuitBreakerConfig configuration for circuit breaker
type CircuitBreakerConfig struct {
        Enabled                 bool   `yaml:"enabled"`
        DefaultFailureThreshold int    `yaml:"default_failure_threshold"`
        DefaultRecoveryTimeout  string `yaml:"default_recovery_timeout"`
}

// RetryConfig configuration for retry logic
type RetryConfig struct {
        DefaultAttempts int    `yaml:"default_attempts"`
        DefaultBackoff  string `yaml:"default_backoff"`
        DefaultDelay    string `yaml:"default_delay"`
}

// HTTPClientConfig configuration for HTTP client
type HTTPClientConfig struct {
        Timeout         string `yaml:"timeout"`
        MaxIdleConns    int    `yaml:"max_idle_conns"`
        IdleConnTimeout string `yaml:"idle_conn_timeout"`
}

// DefaultConfig returns default configuration
func DefaultConfig() *Config <span class="cov6" title="60">{
        return &amp;Config{
                Version: "1.0",
                Handlers: HandlersConfig{
                        Include: []string{
                                "handlers/*.go",
                                "handlers/**/*.go",
                                "features/*/handlers/**/*.go",
                                "internal/*/handlers/**/*.go",
                                "pkg/*/handlers/**/*.go",
                                "app/*/handlers/**/*.go",
                                "src/handlers/**/*.go",
                        },
                        Exclude: []string{
                                "**/*_test.go",
                                "**/mock_*.go",
                                "**/mocks/**/*.go",
                                "vendor/**",
                                ".git/**",
                                "node_modules/**",
                                "**/*.pb.go",
                                ".deco/**",
                        },
                },
                Generate: GenerationConfig{},
                Dev: DevConfig{
                        AutoDiscover: true,
                        Watch:        false,
                },
                Prod: ProdConfig{
                        Validate: true,
                        Minify:   false,
                },
                Redis: RedisConfig{
                        Enabled:  false,
                        Address:  "localhost:6379",
                        DB:       0,
                        PoolSize: 10,
                },
                Cache: CacheConfig{
                        Type:        "memory",
                        DefaultTTL:  "1h",
                        MaxSize:     1000,
                        Compression: false,
                },
                RateLimit: RateLimitConfig{
                        Enabled:    false,
                        Type:       "memory",
                        DefaultRPS: 100,
                        BurstSize:  200,
                        KeyFunc:    "ip",
                },
                Metrics: MetricsConfig{
                        Enabled:   false,
                        Endpoint:  "/metrics",
                        Namespace: "gin_decorators",
                        Subsystem: "api",
                        Buckets:   []float64{0.1, 0.3, 1.2, 5.0},
                },
                OpenAPI: OpenAPIConfig{
                        Version:     "3.0.0",
                        Title:       "API Documentation",
                        Description: "Generated API documentation",
                        Host:        "localhost:8080",
                        BasePath:    "/api",
                        Schemes:     []string{"http", "https"},
                },
                Validation: ValidationConfig{
                        Enabled:     true,
                        FailFast:    false,
                        ErrorFormat: "json",
                },
                WebSocket: WebSocketConfig{
                        Enabled:      false,
                        ReadBuffer:   1024,
                        WriteBuffer:  1024,
                        CheckOrigin:  false,
                        Compression:  false,
                        PingInterval: "54s",
                        PongTimeout:  "60s",
                },
                Telemetry: TelemetryConfig{
                        Enabled:        false,
                        ServiceName:    "gin-decorators",
                        ServiceVersion: "1.0.0",
                        Environment:    "development",
                        Endpoint:       "http://localhost:4317",
                        Insecure:       true,
                        SampleRate:     1.0,
                },
                ClientSDK: ClientSDKConfig{
                        Enabled:     false,
                        OutputDir:   "./sdk",
                        Languages:   []string{"go", "python", "javascript", "typescript"},
                        PackageName: "client",
                },
                Proxy: ProxyConfigSettings{
                        Enabled: false,
                        ServiceDiscovery: ServiceDiscoveryConfig{
                                Consul: ConsulConfig{
                                        Enabled:    false,
                                        Address:    "localhost:8500",
                                        Datacenter: "dc1",
                                },
                                Kubernetes: KubernetesConfig{
                                        Enabled: false,
                                },
                                DNS: DNSConfig{
                                        Enabled: true,
                                },
                        },
                        LoadBalancing: LoadBalancingConfig{
                                DefaultAlgorithm:    "round_robin",
                                HealthCheckInterval: "30s",
                                HealthCheckTimeout:  "5s",
                        },
                        CircuitBreaker: CircuitBreakerConfig{
                                Enabled:                 true,
                                DefaultFailureThreshold: 5,
                                DefaultRecoveryTimeout:  "30s",
                        },
                        Retry: RetryConfig{
                                DefaultAttempts: 3,
                                DefaultBackoff:  "exponential",
                                DefaultDelay:    "1s",
                        },
                        HTTPClient: HTTPClientConfig{
                                Timeout:         "10s",
                                MaxIdleConns:    100,
                                IdleConnTimeout: "90s",
                        },
                },
        }
}</span>

// LoadConfig loads configuration from file
func LoadConfig(configPath string) (*Config, error) <span class="cov2" title="3">{
        if configPath == "" </span><span class="cov1" title="1">{
                configPath = findConfigFile()
        }</span>

        <span class="cov2" title="3">if configPath == "" </span><span class="cov1" title="1">{
                // Use default configuration if file not found
                return DefaultConfig(), nil
        }</span>

        <span class="cov2" title="2">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("error reading file de configuration %s: %v", configPath, err)
        }</span>

        <span class="cov1" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing da configuration: %v", err)
        }</span>

        // Apply defaults for unspecified fields
        <span class="cov1" title="1">applyDefaults(&amp;config)

        return &amp;config, nil</span>
}

// SaveConfig saves configuration to file
func SaveConfig(config *Config, configPath string) error <span class="cov1" title="1">{
        data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error serializing configuration: %v", err)
        }</span>

        <span class="cov1" title="1">if err := os.WriteFile(configPath, data, 0o600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error saving configuration: %v", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// findConfigFile searches for configuration file in default locations
func findConfigFile() string <span class="cov2" title="3">{
        // Check environment variable first
        if envPath := os.Getenv("DECO_CONFIG"); envPath != "" </span><span class="cov1" title="1">{
                return envPath
        }</span>

        <span class="cov2" title="2">candidates := []string{
                ".deco.yaml",
                ".gin-decorators.yml",
                "gin-decorators.yaml",
                "gin-decorators.yml",
                ".config/gin-decorators.yaml",
        }

        for _, candidate := range candidates </span><span class="cov3" title="6">{
                if _, err := os.Stat(candidate); err == nil </span><span class="cov1" title="1">{
                        return candidate
                }</span>
        }

        <span class="cov1" title="1">return ""</span>
}

// applyDefaults applies default values for unspecified fields
func applyDefaults(config *Config) <span class="cov1" title="1">{
        defaults := DefaultConfig()

        if config.Version == "" </span><span class="cov0" title="0">{
                config.Version = defaults.Version
        }</span>

        <span class="cov1" title="1">if len(config.Handlers.Include) == 0 </span><span class="cov0" title="0">{
                config.Handlers.Include = defaults.Handlers.Include
        }</span>

        <span class="cov1" title="1">if len(config.Handlers.Exclude) == 0 </span><span class="cov0" title="0">{
                config.Handlers.Exclude = defaults.Handlers.Exclude
        }</span>

        // Apply defaults for Redis
        <span class="cov1" title="1">if config.Redis.Address == "" </span><span class="cov0" title="0">{
                config.Redis = defaults.Redis
        }</span>

        // Apply defaults for Cache
        <span class="cov1" title="1">if config.Cache.Type == "" </span><span class="cov0" title="0">{
                config.Cache = defaults.Cache
        }</span>

        // Apply defaults for RateLimit
        <span class="cov1" title="1">if config.RateLimit.Type == "" </span><span class="cov0" title="0">{
                config.RateLimit = defaults.RateLimit
        }</span>

        // Apply defaults for Metrics
        <span class="cov1" title="1">if config.Metrics.Endpoint == "" </span><span class="cov0" title="0">{
                config.Metrics = defaults.Metrics
        }</span>

        // Apply defaults for OpenAPI
        <span class="cov1" title="1">if config.OpenAPI.Version == "" </span><span class="cov0" title="0">{
                config.OpenAPI = defaults.OpenAPI
        }</span>

        // Apply defaults for Validation
        <span class="cov1" title="1">if config.Validation.ErrorFormat == "" </span><span class="cov0" title="0">{
                config.Validation = defaults.Validation
        }</span>

        // Apply defaults for WebSocket
        <span class="cov1" title="1">if config.WebSocket.ReadBuffer == 0 </span><span class="cov0" title="0">{
                config.WebSocket = defaults.WebSocket
        }</span>

        // Apply defaults for Telemetry
        <span class="cov1" title="1">if config.Telemetry.ServiceName == "" </span><span class="cov0" title="0">{
                config.Telemetry = defaults.Telemetry
        }</span>

        // Apply defaults for ClientSDK
        <span class="cov1" title="1">if config.ClientSDK.OutputDir == "" </span><span class="cov0" title="0">{
                config.ClientSDK = defaults.ClientSDK
        }</span>

        // Apply defaults for Proxy
        <span class="cov1" title="1">if !config.Proxy.Enabled </span><span class="cov1" title="1">{
                config.Proxy = defaults.Proxy
        }</span>
}

// DiscoverHandlers discovers handler files based on configuration
func (c *Config) DiscoverHandlers(rootDir string) ([]string, error) <span class="cov3" title="5">{
        var handlerFiles []string

        // Compile exclusion patterns
        excludePatterns, err := compilePatterns(c.Handlers.Exclude)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error compiling exclusion patterns: %v", err)
        }</span>

        // Process each inclusion pattern
        <span class="cov3" title="5">for _, includePattern := range c.Handlers.Include </span><span class="cov4" title="8">{
                files, err := findFilesByPattern(rootDir, includePattern, excludePatterns)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error processing pattern '%s': %v", includePattern, err)
                }</span>
                <span class="cov4" title="8">handlerFiles = append(handlerFiles, files...)</span>
        }

        // Remove duplicates
        <span class="cov3" title="5">return removeDuplicates(handlerFiles), nil</span>
}

// findFilesByPattern finds files that match the pattern
func findFilesByPattern(rootDir, pattern string, excludePatterns []*regexp.Regexp) ([]string, error) <span class="cov4" title="9">{
        var matchedFiles []string

        // Convert glob pattern to regex if necessary
        patternRegex, err := globToRegex(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="9">err = filepath.WalkDir(rootDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov10" title="478">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Ignore access errors
                }</span>

                // Skip directories that match excludes
                <span class="cov10" title="478">if d.IsDir() </span><span class="cov4" title="15">{
                        for _, excludePattern := range excludePatterns </span><span class="cov7" title="64">{
                                if excludePattern.MatchString(path) </span><span class="cov0" title="0">{
                                        return filepath.SkipDir
                                }</span>
                        }
                        <span class="cov4" title="15">return nil</span>
                }

                // Check if file matches pattern
                <span class="cov9" title="463">relPath, err := filepath.Rel(rootDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Normalize path to always use /
                <span class="cov9" title="463">relPath = filepath.ToSlash(relPath)

                if patternRegex.MatchString(relPath) </span><span class="cov3" title="7">{
                        // Check if not excluded
                        excluded := false
                        for _, excludePattern := range excludePatterns </span><span class="cov3" title="7">{
                                if excludePattern.MatchString(relPath) </span><span class="cov1" title="1">{
                                        excluded = true
                                        break</span>
                                }
                        }

                        <span class="cov3" title="7">if !excluded </span><span class="cov3" title="6">{
                                matchedFiles = append(matchedFiles, path)
                        }</span>
                }

                <span class="cov9" title="463">return nil</span>
        })

        <span class="cov4" title="9">return matchedFiles, err</span>
}

// globToRegex converts glob pattern to regex
func globToRegex(pattern string) (*regexp.Regexp, error) <span class="cov6" title="35">{
        // Handle special cases first
        if pattern == "*.{go,js}" </span><span class="cov1" title="1">{
                return regexp.MustCompile(`^[^/]*\.(go|js)$`), nil
        }</span>

        // Handle **/*.go pattern
        <span class="cov6" title="34">if pattern == "**/*.go" </span><span class="cov3" title="4">{
                return regexp.MustCompile(`^.*\.go$`), nil
        }</span>

        // Handle **/handlers/**/*.go pattern
        <span class="cov5" title="30">if pattern == "**/handlers/**/*.go" </span><span class="cov1" title="1">{
                return regexp.MustCompile(`^.*/handlers/.*\.go$`), nil
        }</span>

        // First, handle ** specially
        <span class="cov5" title="29">pattern = strings.ReplaceAll(pattern, "**", "⭐⭐") // temporary placeholder

        // Escape special regex characters
        escaped := regexp.QuoteMeta(pattern)

        // Convert glob wildcards to regex
        escaped = strings.ReplaceAll(escaped, `⭐⭐`, `.*`)    // ** = anything (including / and zero chars)
        escaped = strings.ReplaceAll(escaped, `\*`, `[^/]*`) // * = anything except /
        escaped = strings.ReplaceAll(escaped, `\?`, `[^/]`)  // ? = one character except /

        // Add anchors
        escaped = `^` + escaped + `$`

        return regexp.Compile(escaped)</span>
}

// compilePatterns compiles pattern list to regex
func compilePatterns(patterns []string) ([]*regexp.Regexp, error) <span class="cov4" title="8">{
        compiled := make([]*regexp.Regexp, 0, len(patterns))

        for _, pattern := range patterns </span><span class="cov4" title="15">{
                regex, err := globToRegex(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid pattern '%s': %v", pattern, err)
                }</span>
                <span class="cov4" title="15">compiled = append(compiled, regex)</span>
        }

        <span class="cov4" title="8">return compiled, nil</span>
}

// removeDuplicates removes duplicate files from list
func removeDuplicates(files []string) []string <span class="cov3" title="6">{
        seen := make(map[string]bool)
        var unique []string

        for _, file := range files </span><span class="cov3" title="7">{
                if !seen[file] </span><span class="cov3" title="5">{
                        seen[file] = true
                        unique = append(unique, file)
                }</span>
        }

        <span class="cov3" title="6">return unique</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov2" title="2">{
        if c.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("version is required")
        }</span>

        <span class="cov2" title="2">if len(c.Handlers.Include) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("at least one pattern de include is required")
        }</span>

        // Validate patterns
        <span class="cov1" title="1">for _, pattern := range c.Handlers.Include </span><span class="cov1" title="1">{
                if _, err := globToRegex(pattern); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid include pattern '%s': %v", pattern, err)
                }</span>
        }

        <span class="cov1" title="1">for _, pattern := range c.Handlers.Exclude </span><span class="cov1" title="1">{
                if _, err := globToRegex(pattern); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid exclude pattern '%s': %v", pattern, err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package decorators

import (
        "html/template"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

// DocsData structure to pass data to documentation template
type DocsData struct {
        Routes           []RouteEntry
        TotalRoutes      int
        UniqueMethods    int
        TotalMiddlewares int
}

// DocsHandler serves the HTML documentation page
func DocsHandler(c *gin.Context) <span class="cov0" title="0">{
        routes := GetRoutes()
        groups := GetGroups()

        // Calculate statistics
        methodsMap := make(map[string]bool)
        totalMiddlewares := 0
        uniqueMiddlewares := make(map[string]bool)
        totalWebSockets := 0
        totalProxies := 0

        for i := range routes </span><span class="cov0" title="0">{
                route := &amp;routes[i]
                methodsMap[route.Method] = true
                totalMiddlewares += len(route.MiddlewareInfo)
                for _, mw := range route.MiddlewareInfo </span><span class="cov0" title="0">{
                        uniqueMiddlewares[mw.Name] = true
                        // Count proxy middlewares
                        if mw.Name == "Proxy" </span><span class="cov0" title="0">{
                                totalProxies++
                        }</span>
                }
                // Count WebSocket handlers
                <span class="cov0" title="0">totalWebSockets += len(route.WebSocketHandlers)</span>
        }

        // Organize routes by tags and groups
        <span class="cov0" title="0">routesByTag := make(map[string][]RouteEntry)
        routesByGroup := make(map[string][]RouteEntry)
        untaggedRoutes := []RouteEntry{}
        ungroupedRoutes := []RouteEntry{}

        for i := range routes </span><span class="cov0" title="0">{
                route := &amp;routes[i]
                // Group by tags
                if len(route.Tags) &gt; 0 </span><span class="cov0" title="0">{
                        for _, tag := range route.Tags </span><span class="cov0" title="0">{
                                routesByTag[tag] = append(routesByTag[tag], *route)
                        }</span>
                } else<span class="cov0" title="0"> {
                        untaggedRoutes = append(untaggedRoutes, *route)
                }</span>

                // Group by groups
                <span class="cov0" title="0">if route.Group != nil </span><span class="cov0" title="0">{
                        routesByGroup[route.Group.Name] = append(routesByGroup[route.Group.Name], *route)
                }</span> else<span class="cov0" title="0"> {
                        ungroupedRoutes = append(ungroupedRoutes, *route)
                }</span>
        }

        // Create data structure for template
        <span class="cov0" title="0">data := struct {
                Routes            []RouteEntry
                RoutesByTag       map[string][]RouteEntry
                RoutesByGroup     map[string][]RouteEntry
                UntaggedRoutes    []RouteEntry
                UngroupedRoutes   []RouteEntry
                Groups            map[string]*GroupInfo
                TotalRoutes       int
                UniqueMethods     int
                TotalMiddlewares  int
                UniqueMiddlewares int
                TotalWebSockets   int
                TotalProxies      int
        }{
                Routes:            routes,
                RoutesByTag:       routesByTag,
                RoutesByGroup:     routesByGroup,
                UntaggedRoutes:    untaggedRoutes,
                UngroupedRoutes:   ungroupedRoutes,
                Groups:            groups,
                TotalRoutes:       len(routes),
                UniqueMethods:     len(methodsMap),
                TotalMiddlewares:  totalMiddlewares,
                UniqueMiddlewares: len(uniqueMiddlewares),
                TotalWebSockets:   totalWebSockets,
                TotalProxies:      totalProxies,
        }

        htmlTemplate := `
&lt;!DOCTYPE html&gt;
&lt;html lang="pt-BR"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;gin-decorators - Route Documentation&lt;/title&gt;
    &lt;style&gt;
        :root {
            --mascot-blue: #40B0C0;
            --mascot-cream: #F5E5C0;
            --mascot-green: #66CC33;
            --mascot-brown: #A0522D;
            --dark-bg: #1a1a1a;
            --dark-surface: #2d2d2d;
            --dark-surface-hover: #3a3a3a;
            --dark-border: #404040;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #808080;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--dark-bg);
            color: var(--text-primary);
            line-height: 1.6;
            height: auto;
            min-height: 100vh;
            overflow: auto;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--dark-surface);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            margin-top: 20px;
            margin-bottom: 20px;
            height: auto;
            min-height: auto;
            overflow: auto;
        }

        .header {
            background: linear-gradient(135deg, var(--mascot-blue) 0%, #2a8a9a 100%);
            color: white;
            padding: 40px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102, 204, 51, 0.1) 0%, transparent 70%);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        .header h1 {
            margin: 0;
            font-size: 3rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }

        .header p {
            margin: 10px 0 0 0;
            opacity: 0.95;
            font-size: 1.1rem;
            position: relative;
            z-index: 1;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            background: var(--dark-surface);
            padding: 30px;
            border-bottom: 1px solid var(--dark-border);
        }

        .stat {
            text-align: center;
            background: var(--dark-surface-hover);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--dark-border);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(64, 176, 192, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .stat:hover::before {
            left: 100%;
        }

        .stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(64, 176, 192, 0.2);
            border-color: var(--mascot-blue);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--mascot-blue);
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .view-controls {
            padding: 25px 30px;
            background: var(--dark-surface-hover);
            border-bottom: 1px solid var(--dark-border);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .view-toggle {
            background: var(--dark-surface);
            color: var(--text-primary);
            border: 1px solid var(--dark-border);
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .view-toggle::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 204, 51, 0.2), transparent);
            transition: left 0.3s ease;
        }

        .view-toggle:hover::before {
            left: 100%;
        }

        .view-toggle:hover {
            background: var(--mascot-blue);
            color: white;
            border-color: var(--mascot-blue);
            transform: translateY(-1px);
        }

        .view-toggle.active {
            background: var(--mascot-green);
            color: white;
            border-color: var(--mascot-green);
            box-shadow: 0 4px 12px rgba(102, 204, 51, 0.3);
        }

        .collapse-section {
            margin: 20px 30px;
            border: 1px solid var(--dark-border);
            border-radius: 12px;
            overflow: hidden;
            background: var(--dark-surface);
            transition: all 0.3s ease;
        }

        .collapse-section:hover {
            border-color: var(--mascot-blue);
            box-shadow: 0 4px 20px rgba(64, 176, 192, 0.1);
        }

        .collapse-header {
            background: var(--dark-surface-hover);
            padding: 20px 25px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--dark-border);
            transition: all 0.3s ease;
        }

        .collapse-header:hover {
            background: var(--dark-surface);
        }

        .collapse-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2rem;
            font-weight: 600;
        }

        .collapse-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
            color: var(--mascot-blue);
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapse-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .collapse-content.expanded {
            max-height: fit-content;
        }

        .collapse-routes {
            padding: 0;
        }

        .route {
            border-bottom: 1px solid var(--dark-border);
            padding: 25px 30px;
            transition: all 0.3s ease;
            background: var(--dark-surface);
        }

        .route:hover {
            background: var(--dark-surface-hover);
            transform: translateX(4px);
        }

        .route:last-child {
            border-bottom: none;
        }

        .route-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .method {
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 700;
            font-size: 0.85rem;
            min-width: 80px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .method-GET { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; }
        .method-POST { background: linear-gradient(135deg, #2196F3, #1976D2); color: white; }
        .method-PUT { background: linear-gradient(135deg, #FF9800, #F57C00); color: white; }
        .method-DELETE { background: linear-gradient(135deg, #F44336, #D32F2F); color: white; }
        .method-PATCH { background: linear-gradient(135deg, #9C27B0, #7B1FA2); color: white; }
        .method-WS { background: linear-gradient(135deg, var(--mascot-blue), #2a8a9a); color: white; }

        .path {
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--mascot-cream);
            flex: 1;
            background: var(--dark-bg);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--dark-border);
        }

        .handler {
            color: var(--text-muted);
            font-size: 0.9rem;
            font-style: italic;
            background: var(--dark-surface-hover);
            padding: 6px 10px;
            border-radius: 6px;
        }

        .route-tags {
            margin-bottom: 15px;
        }

        .tag {
            display: inline-block;
            background: linear-gradient(135deg, var(--mascot-blue), #2a8a9a);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            margin-right: 8px;
            margin-bottom: 6px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(64, 176, 192, 0.3);
        }

        .middlewares {
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            position: relative;
            z-index: 1;
        }

        .middleware {
            background: var(--dark-surface-hover);
            color: var(--text-secondary);
            padding: 16px;
            border-radius: 12px;
            font-size: 0.85rem;
            position: relative;
            border: 1px solid var(--dark-border);
            transition: all 0.3s ease;
            min-width: 250px;
            flex: 1;
            max-width: 400px;
            height: auto;
            min-height: auto;
            overflow: visible;
        }

        .middleware:hover {
            background: var(--dark-surface);
            border-color: var(--mascot-blue);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(64, 176, 192, 0.15);
        }

        .middleware-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .middleware-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .middleware-auth .middleware-icon { background: #FF9800; }
        .middleware-cache .middleware-icon { background: #4CAF50; }
        .middleware-ratelimit .middleware-icon { background: #F44336; }
        .middleware-metrics .middleware-icon { background: #2196F3; }
        .middleware-cors .middleware-icon { background: #9C27B0; }
        .middleware-proxy .middleware-icon { background: var(--mascot-green); }

        .middleware-args {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .arg-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 8px 10px;
            background: var(--dark-bg);
            border-radius: 6px;
            border: 1px solid var(--dark-border);
            font-size: 0.75rem;
            gap: 8px;
        }

        .arg-key {
            color: var(--mascot-cream);
            font-weight: 500;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
        }

        .arg-value {
            color: var(--mascot-blue);
            font-weight: 600;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            background: rgba(64, 176, 192, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(64, 176, 192, 0.2);
            word-break: break-all;
            max-width: 200px;
            overflow-wrap: break-word;
            white-space: normal;
            display: inline-block;
        }

        .arg-separator {
            color: var(--text-muted);
            margin: 0 4px;
        }

        .description {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 12px;
            font-style: italic;
            background: var(--dark-surface-hover);
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid var(--mascot-cream);
        }

        .empty-state {
            text-align: center;
            padding: 80px;
            color: var(--text-muted);
        }

        .empty-state h3 {
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .json-link {
            position: fixed;
            bottom: 80px;
            right: 80px;
            background: linear-gradient(135deg, var(--mascot-blue), #2a8a9a);
            color: white;
            padding: 15px 25px;
            border-radius: 30px;
            text-decoration: none;
            box-shadow: 0 8px 25px rgba(64, 176, 192, 0.4);
            transition: all 0.3s ease;
            font-weight: 600;
            z-index: 1000;
            pointer-events: auto;
        }

        .json-link:hover {
            background: linear-gradient(135deg, var(--mascot-green), #5bbf2a);
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(102, 204, 51, 0.4);
            text-decoration: none;
            color: white;
        }

        .routes {
            padding: 0;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 12px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                padding: 20px;
            }
            
            .stat-number {
                font-size: 2rem;
            }
            
            .view-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .route-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .path {
                width: 100%;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--dark-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--mascot-blue);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--mascot-green);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;🎨 gin-decorators&lt;/h1&gt;
            &lt;p&gt;Automatic documentation of routes&lt;/p&gt;
        &lt;/div&gt;
        
        &lt;div class="stats"&gt;
            &lt;div class="stat"&gt;
                &lt;div class="stat-number"&gt;{{.TotalRoutes}}&lt;/div&gt;
                &lt;div class="stat-label"&gt;Routes registradas&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat"&gt;
                &lt;div class="stat-number"&gt;{{.UniqueMethods}}&lt;/div&gt;
                &lt;div class="stat-label"&gt;Unique methods&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat"&gt;
                &lt;div class="stat-number"&gt;{{.TotalMiddlewares}}&lt;/div&gt;
                &lt;div class="stat-label"&gt;Applied middlewares&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat"&gt;
                &lt;div class="stat-number"&gt;{{.UniqueMiddlewares}}&lt;/div&gt;
                &lt;div class="stat-label"&gt;Middleware types&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat"&gt;
                &lt;div class="stat-number"&gt;{{.TotalWebSockets}}&lt;/div&gt;
                &lt;div class="stat-label"&gt;WebSocket handlers&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat"&gt;
                &lt;div class="stat-number"&gt;{{.TotalProxies}}&lt;/div&gt;
                &lt;div class="stat-label"&gt;Proxies processed&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="view-controls"&gt;
            &lt;button class="view-toggle active" onclick="switchView('tags')"&gt;🏷️ Por Tags&lt;/button&gt;
            &lt;button class="view-toggle" onclick="switchView('groups')"&gt;📁 Por Grupos&lt;/button&gt;
            &lt;button class="view-toggle" onclick="switchView('all')"&gt;📄 Todas as Rotas&lt;/button&gt;
            &lt;div style="margin-left: auto;"&gt;
                &lt;button class="view-toggle" onclick="expandAll()" style="background: var(--mascot-green);"&gt;🔽 Expandir Tudo&lt;/button&gt;
                &lt;button class="view-toggle" onclick="collapseAll()" style="background: var(--mascot-brown);"&gt;🔼 Colapsar Tudo&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;!-- Routes by Tags --&gt;
        &lt;div id="tags-view" class="view-content"&gt;
            {{if .RoutesByTag}}
                {{range $tag, $routes := .RoutesByTag}}
                &lt;div class="collapse-section"&gt;
                    &lt;div class="collapse-header" onclick="toggleCollapse('tag-{{$tag}}')"&gt;
                        &lt;h3&gt;🏷️ {{$tag}} ({{len $routes}} rotas)&lt;/h3&gt;
                        &lt;span class="collapse-icon" id="icon-tag-{{$tag}}"&gt;▼&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class="collapse-content" id="content-tag-{{$tag}}"&gt;
                        &lt;div class="collapse-routes"&gt;
                            {{range $routes}}
                            &lt;div class="route"&gt;
                                &lt;div class="route-header"&gt;
                                    &lt;span class="method method-{{.Method}}"&gt;{{.Method}}&lt;/span&gt;
                                    &lt;span class="path"&gt;{{.Path}}&lt;/span&gt;
                                    &lt;span class="handler"&gt;{{.FuncName}}&lt;/span&gt;
                                &lt;/div&gt;
                                
                                {{if .Tags}}
                                &lt;div class="route-tags"&gt;
                                    {{range .Tags}}
                                    &lt;span class="tag"&gt;{{.}}&lt;/span&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                                
                                {{if .Description}}
                                &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                                {{end}}
                                
                                {{if .MiddlewareInfo}}
                                &lt;div class="middlewares"&gt;
                                    {{range .MiddlewareInfo}}
                                    &lt;div class="middleware middleware-{{.Name | lower}}"&gt;
                                        &lt;div class="middleware-header"&gt;
                                            &lt;div class="middleware-icon"&gt;&lt;/div&gt;
                                            &lt;strong&gt;{{.Name}}&lt;/strong&gt;
                                        &lt;/div&gt;
                                        {{if .Description}}
                                        &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                                        {{end}}
                                        {{if .Args}}
                                        &lt;div class="middleware-args"&gt;
                                            {{range $key, $value := .Args}}
                                            &lt;div class="arg-item"&gt;
                                                &lt;span class="arg-key"&gt;{{$key}}&lt;/span&gt;
                                                &lt;span class="arg-separator"&gt;:&lt;/span&gt;
                                                &lt;span class="arg-value"&gt;{{$value}}&lt;/span&gt;
                                            &lt;/div&gt;
                                            {{end}}
                                        &lt;/div&gt;
                                        {{end}}
                                    &lt;/div&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                            &lt;/div&gt;
                            {{end}}
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                {{end}}
            {{end}}
            
            {{if .UntaggedRoutes}}
            &lt;div class="collapse-section"&gt;
                &lt;div class="collapse-header" onclick="toggleCollapse('untagged')"&gt;
                    &lt;h3&gt;🏷️ Sem Tags ({{len .UntaggedRoutes}} rotas)&lt;/h3&gt;
                    &lt;span class="collapse-icon" id="icon-untagged"&gt;▼&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="collapse-content" id="content-untagged"&gt;
                    &lt;div class="collapse-routes"&gt;
                        {{range .UntaggedRoutes}}
                        &lt;div class="route"&gt;
                            &lt;div class="route-header"&gt;
                                &lt;span class="method method-{{.Method}}"&gt;{{.Method}}&lt;/span&gt;
                                &lt;span class="path"&gt;{{.Path}}&lt;/span&gt;
                                &lt;span class="handler"&gt;{{.FuncName}}&lt;/span&gt;
                            &lt;/div&gt;
                            
                            {{if .Description}}
                            &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                            {{end}}
                            
                            {{if .MiddlewareInfo}}
                            &lt;div class="middlewares"&gt;
                                {{range .MiddlewareInfo}}
                                &lt;div class="middleware middleware-{{.Name | lower}}"&gt;
                                    &lt;div class="middleware-header"&gt;
                                        &lt;div class="middleware-icon"&gt;&lt;/div&gt;
                                        &lt;strong&gt;{{.Name}}&lt;/strong&gt;
                                    &lt;/div&gt;
                                    {{if .Description}}
                                    &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                                    {{end}}
                                    {{if .Args}}
                                    &lt;div class="middleware-args"&gt;
                                        {{range $key, $value := .Args}}
                                        &lt;div class="arg-item"&gt;
                                            &lt;span class="arg-key"&gt;{{$key}}&lt;/span&gt;
                                            &lt;span class="arg-separator"&gt;:&lt;/span&gt;
                                            &lt;span class="arg-value"&gt;{{$value}}&lt;/span&gt;
                                        &lt;/div&gt;
                                        {{end}}
                                    &lt;/div&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                            &lt;/div&gt;
                            {{end}}
                        &lt;/div&gt;
                        {{end}}
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            {{end}}
        &lt;/div&gt;
        
        &lt;!-- Routes by Groups --&gt;
        &lt;div id="groups-view" class="view-content" style="display: none;"&gt;
            {{if .RoutesByGroup}}
                {{range $group, $routes := .RoutesByGroup}}
                &lt;div class="collapse-section"&gt;
                    &lt;div class="collapse-header" onclick="toggleCollapse('group-{{$group}}')"&gt;
                        &lt;h3&gt;📁 {{$group}} ({{len $routes}} rotas)&lt;/h3&gt;
                        &lt;span class="collapse-icon" id="icon-group-{{$group}}"&gt;▼&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class="collapse-content" id="content-group-{{$group}}"&gt;
                        &lt;div class="collapse-routes"&gt;
                            {{range $routes}}
                            &lt;div class="route"&gt;
                                &lt;div class="route-header"&gt;
                                    &lt;span class="method method-{{.Method}}"&gt;{{.Method}}&lt;/span&gt;
                                    &lt;span class="path"&gt;{{.Path}}&lt;/span&gt;
                                    &lt;span class="handler"&gt;{{.FuncName}}&lt;/span&gt;
                                &lt;/div&gt;
                                
                                {{if .Tags}}
                                &lt;div class="route-tags"&gt;
                                    {{range .Tags}}
                                    &lt;span class="tag"&gt;{{.}}&lt;/span&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                                
                                {{if .Description}}
                                &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                                {{end}}
                                
                                {{if .MiddlewareInfo}}
                                &lt;div class="middlewares"&gt;
                                    {{range .MiddlewareInfo}}
                                    &lt;div class="middleware middleware-{{.Name | lower}}"&gt;
                                        &lt;div class="middleware-header"&gt;
                                            &lt;div class="middleware-icon"&gt;&lt;/div&gt;
                                            &lt;strong&gt;{{.Name}}&lt;/strong&gt;
                                        &lt;/div&gt;
                                        {{if .Description}}
                                        &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                                        {{end}}
                                        {{if .Args}}
                                        &lt;div class="middleware-args"&gt;
                                            {{range $key, $value := .Args}}
                                            &lt;div class="arg-item"&gt;
                                                &lt;span class="arg-key"&gt;{{$key}}&lt;/span&gt;
                                                &lt;span class="arg-separator"&gt;:&lt;/span&gt;
                                                &lt;span class="arg-value"&gt;{{$value}}&lt;/span&gt;
                                            &lt;/div&gt;
                                            {{end}}
                                        &lt;/div&gt;
                                        {{end}}
                                    &lt;/div&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                            &lt;/div&gt;
                            {{end}}
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                {{end}}
            {{end}}
            
            {{if .UngroupedRoutes}}
            &lt;div class="collapse-section"&gt;
                &lt;div class="collapse-header" onclick="toggleCollapse('ungrouped')"&gt;
                    &lt;h3&gt;📁 Sem Grupo ({{len .UngroupedRoutes}} rotas)&lt;/h3&gt;
                    &lt;span class="collapse-icon" id="icon-ungrouped"&gt;▼&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="collapse-content" id="content-ungrouped"&gt;
                    &lt;div class="collapse-routes"&gt;
                        {{range .UngroupedRoutes}}
                        &lt;div class="route"&gt;
                            &lt;div class="route-header"&gt;
                                &lt;span class="method method-{{.Method}}"&gt;{{.Method}}&lt;/span&gt;
                                &lt;span class="path"&gt;{{.Path}}&lt;/span&gt;
                                &lt;span class="handler"&gt;{{.FuncName}}&lt;/span&gt;
                            &lt;/div&gt;
                            
                            {{if .Tags}}
                            &lt;div class="route-tags"&gt;
                                {{range .Tags}}
                                &lt;span class="tag"&gt;{{.}}&lt;/span&gt;
                                {{end}}
                            &lt;/div&gt;
                            {{end}}
                            
                            {{if .Description}}
                            &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                            {{end}}
                            
                            {{if .MiddlewareInfo}}
                            &lt;div class="middlewares"&gt;
                                {{range .MiddlewareInfo}}
                                &lt;div class="middleware middleware-{{.Name | lower}}"&gt;
                                    &lt;div class="middleware-header"&gt;
                                        &lt;div class="middleware-icon"&gt;&lt;/div&gt;
                                        &lt;strong&gt;{{.Name}}&lt;/strong&gt;
                                    &lt;/div&gt;
                                    {{if .Description}}
                                    &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                                    {{end}}
                                    {{if .Args}}
                                    &lt;div class="middleware-args"&gt;
                                        {{range $key, $value := .Args}}
                                        &lt;div class="arg-item"&gt;
                                            &lt;span class="arg-key"&gt;{{$key}}&lt;/span&gt;
                                            &lt;span class="arg-separator"&gt;:&lt;/span&gt;
                                            &lt;span class="arg-value"&gt;{{$value}}&lt;/span&gt;
                                        &lt;/div&gt;
                                        {{end}}
                                    &lt;/div&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                            &lt;/div&gt;
                            {{end}}
                        &lt;/div&gt;
                        {{end}}
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            {{end}}
        &lt;/div&gt;
        
        &lt;!-- All Routes --&gt;
        &lt;div id="all-view" class="view-content" style="display: none;"&gt;
            &lt;div class="routes"&gt;
                {{if .Routes}}
                    {{range .Routes}}
                    &lt;div class="route"&gt;
                        &lt;div class="route-header"&gt;
                            &lt;span class="method method-{{.Method}}"&gt;{{.Method}}&lt;/span&gt;
                            &lt;span class="path"&gt;{{.Path}}&lt;/span&gt;
                            &lt;span class="handler"&gt;{{.FuncName}}&lt;/span&gt;
                        &lt;/div&gt;
                        
                        {{if .Tags}}
                        &lt;div class="route-tags"&gt;
                            {{range .Tags}}
                            &lt;span class="tag"&gt;{{.}}&lt;/span&gt;
                            {{end}}
                        &lt;/div&gt;
                        {{end}}
                        
                        {{if .Description}}
                        &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                        {{end}}
                        
                        {{if .MiddlewareInfo}}
                        &lt;div class="middlewares"&gt;
                            {{range .MiddlewareInfo}}
                            &lt;div class="middleware middleware-{{.Name | lower}}"&gt;
                                &lt;div class="middleware-header"&gt;
                                    &lt;div class="middleware-icon"&gt;&lt;/div&gt;
                                    &lt;strong&gt;{{.Name}}&lt;/strong&gt;
                                &lt;/div&gt;
                                {{if .Description}}
                                &lt;div class="description"&gt;{{.Description}}&lt;/div&gt;
                                {{end}}
                                {{if .Args}}
                                &lt;div class="middleware-args"&gt;
                                    {{range $key, $value := .Args}}
                                    &lt;div class="arg-item"&gt;
                                        &lt;span class="arg-key"&gt;{{$key}}&lt;/span&gt;
                                        &lt;span class="arg-separator"&gt;:&lt;/span&gt;
                                        &lt;span class="arg-value"&gt;{{$value}}&lt;/span&gt;
                                    &lt;/div&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                            &lt;/div&gt;
                            {{end}}
                        &lt;/div&gt;
                        {{end}}
                    &lt;/div&gt;
                    {{end}}
                {{else}}
                    &lt;div class="empty-state"&gt;
                        &lt;h3&gt;No registered routes&lt;/h3&gt;
                        &lt;p&gt;Add @Route annotations to your handlers to see them here.&lt;/p&gt;
                    &lt;/div&gt;
                {{end}}
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;a href="/decorators/docs.json" class="json-link"&gt;📄 JSON&lt;/a&gt;
    
    &lt;script&gt;
        // Toggle collapse functionality
        function toggleCollapse(id) {
            const content = document.getElementById('content-' + id);
            const icon = document.getElementById('icon-' + id);
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.classList.add('collapsed');
            } else {
                content.classList.add('expanded');
                icon.classList.remove('collapsed');
            }
        }
        
        // Switch between different views
        function switchView(view) {
            // Hide all views
            document.getElementById('tags-view').style.display = 'none';
            document.getElementById('groups-view').style.display = 'none';
            document.getElementById('all-view').style.display = 'none';
            
            // Show selected view
            document.getElementById(view + '-view').style.display = 'block';
            
            // Update button states
            document.querySelectorAll('.view-toggle').forEach(btn =&gt; {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        // Expand all collapses in current view
        function expandAll() {
            const currentView = document.querySelector('.view-content[style*="block"]') || document.getElementById('tags-view');
            const collapses = currentView.querySelectorAll('.collapse-content');
            const icons = currentView.querySelectorAll('.collapse-icon');
            
            collapses.forEach(collapse =&gt; {
                collapse.classList.add('expanded');
            });
            icons.forEach(icon =&gt; {
                icon.classList.remove('collapsed');
            });
        }
        
        // Collapse all in current view
        function collapseAll() {
            const currentView = document.querySelector('.view-content[style*="block"]') || document.getElementById('tags-view');
            const collapses = currentView.querySelectorAll('.collapse-content');
            const icons = currentView.querySelectorAll('.collapse-icon');
            
            collapses.forEach(collapse =&gt; {
                collapse.classList.remove('expanded');
            });
            icons.forEach(icon =&gt; {
                icon.classList.add('collapsed');
            });
        }
        
        // Initialize - expand first collapse in each view
        document.addEventListener('DOMContentLoaded', function() {
            // Expand first collapse in tags view
            const firstTagCollapse = document.querySelector('#tags-view .collapse-content');
            if (firstTagCollapse) {
                firstTagCollapse.classList.add('expanded');
                const firstIcon = document.querySelector('#tags-view .collapse-icon');
                if (firstIcon) {
                    firstIcon.classList.remove('collapsed');
                }
            }
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`

        tmpl, err := template.New("docs").Funcs(template.FuncMap{
                "lower": strings.ToLower,
        }).Parse(htmlTemplate)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Error processing template"})
                return
        }</span>

        <span class="cov0" title="0">c.Header("Content-Type", "text/html; charset=utf-8")
        if err := tmpl.Execute(c.Writer, data); err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Error rendering template"})
                return
        }</span>
}

// DocsJSONHandler serves documentation in JSON/OpenAPI format
func DocsJSONHandler(c *gin.Context) <span class="cov0" title="0">{
        // Use default configuration if not provided
        config := DefaultConfig()
        spec := GenerateOpenAPISpec(config)
        c.JSON(http.StatusOK, spec)
}</span>

// Removed - RouteInfo now in types.go
</pre>
		
		<pre class="file" id="file8" style="display: none">package decorators

import (
        "fmt"
        "go/ast"
        "go/parser"
        "go/token"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "text/template"
        "time"
)

// escapeGoString escapes a string for safe use in generated Go code
func escapeGoString(s string) string <span class="cov0" title="0">{
        // Use strconv.Quote to properly escape the string
        return strconv.Quote(s)
}</span>

// GenerateInitFile generates the init_decorators.go file for production
func GenerateInitFile(rootDir, outputPath, pkgName string) error <span class="cov0" title="0">{
        return GenerateInitFileWithConfig(rootDir, outputPath, pkgName, nil)
}</span>

// GenerateInitFileWithConfig generates file with specific configuration
func GenerateInitFileWithConfig(rootDir, outputPath, pkgName string, config *Config) error <span class="cov0" title="0">{
        // Parse and prepare data
        routes, genData, err := parseAndPrepareData(rootDir, pkgName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use default configuration if not provided
        <span class="cov0" title="0">if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        // Generate the file
        <span class="cov0" title="0">if err := generateFile(outputPath, genData, config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate if enabled
        <span class="cov0" title="0">if config.Prod.Validate </span><span class="cov0" title="0">{
                if err := ValidateGeneration(outputPath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("validation failed: %v", err)
                }</span>
                <span class="cov0" title="0">LogVerbose("File validado com success")</span>
        }

        // Log statistics
        <span class="cov0" title="0">logGenerationStats(routes, genData, outputPath, config)

        return nil</span>
}

// parseAndPrepareData parses the directory and prepares generation data
func parseAndPrepareData(rootDir, pkgName string) ([]*RouteMeta, *GenData, error) <span class="cov0" title="0">{
        routes, err := ParseDirectory(rootDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error in parsing do directory %s: %v", rootDir, err)
        }</span>

        <span class="cov0" title="0">if err := executeParserHooks(routes); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error nos parser hooks: %v", err)
        }</span>

        <span class="cov0" title="0">genData := &amp;GenData{
                PackageName: pkgName,
                Routes:      routes,
                Imports: []string{
                        `decorators "github.com/RodolfoBonis/deco/pkg/decorators"`,
                },
                Metadata: map[string]interface{}{
                        "generated_at": time.Now().Format(time.RFC3339),
                },
        }

        if err := executeGeneratorHooks(genData); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error nos generator hooks: %v", err)
        }</span>

        <span class="cov0" title="0">return routes, genData, nil</span>
}

// generateFile generates the output file
func generateFile(outputPath string, genData *GenData, config *Config) error <span class="cov0" title="0">{
        tmplContent := getTemplateContent(config)

        tmpl, err := template.New("init_decorators").Funcs(template.FuncMap{
                "escapeString": escapeGoString,
        }).Parse(tmplContent)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error processing template: %v", err)
        }</span>

        <span class="cov0" title="0">if err := createOutputDirectory(outputPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := createGitignoreIfNeeded(outputPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">outputFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating file %s: %v", outputPath, err)
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        if err := tmpl.Execute(outputFile, genData); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error executing template: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getTemplateContent returns the appropriate template content
func getTemplateContent(config *Config) string <span class="cov0" title="0">{
        if config.Prod.Minify </span><span class="cov0" title="0">{
                return GetMinifiedTemplate()
        }</span>
        <span class="cov0" title="0">return getInitTemplate()</span>
}

// createOutputDirectory creates the output directory if necessary
func createOutputDirectory(outputPath string) error <span class="cov0" title="0">{
        outputDir := filepath.Dir(outputPath)
        if err := os.MkdirAll(outputDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating output directory: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// createGitignoreIfNeeded creates .gitignore for .deco folders
func createGitignoreIfNeeded(outputPath string) error <span class="cov0" title="0">{
        outputDir := filepath.Dir(outputPath)
        if !strings.Contains(outputDir, ".deco") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">gitignorePath := filepath.Join(outputDir, ".gitignore")
        if _, err := os.Stat(gitignorePath); err == nil </span><span class="cov0" title="0">{
                return nil // Already exists
        }</span>

        <span class="cov0" title="0">gitignoreContent := `# Files generateds automatically pelo gin-decorators
*.go
!.gitignore

# Files de cache e temporários
*.tmp
*.cache
`
        if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0o600); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Warning: could not criar .gitignore em %s: %v\n", outputDir, err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("📝 Created .gitignore em %s\n", outputDir)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// logGenerationStats logs generation statistics
func logGenerationStats(routes []*RouteMeta, genData *GenData, outputPath string, config *Config) <span class="cov0" title="0">{
        stats := calculateStats(routes)

        LogNormal("Code generated: %d routes, %d websockets, %d middlewares, %d proxies processed",
                len(routes), stats.wsHandlerCount, stats.middlewareCount, stats.proxyCount)

        LogVerbose("✅ File generated successfully: %s", outputPath)
        LogVerbose("🚀 Works in DEV and PROD automatically!")
        LogVerbose("📊 Statistics:")
        LogVerbose("   - %d routes processed", len(routes))
        LogVerbose("   - %d imports added", len(genData.Imports))
        LogVerbose("   - Package: %s", genData.PackageName)

        if config.Prod.Minify </span><span class="cov0" title="0">{
                LogVerbose("📦 Code minified for production")
        }</span>
        <span class="cov0" title="0">if config.Prod.Validate </span><span class="cov0" title="0">{
                LogVerbose("🔍 Syntax validation enabled")
        }</span>
        <span class="cov0" title="0">if strings.Contains(outputPath, ".deco") </span><span class="cov0" title="0">{
                LogVerbose("📁 Files organizados na pasta .deco")
        }</span>
}

// generationStats holds statistics about the generation
type generationStats struct {
        wsHandlerCount  int
        middlewareCount int
        proxyCount      int
}

// calculateStats calculates generation statistics
func calculateStats(routes []*RouteMeta) generationStats <span class="cov0" title="0">{
        var stats generationStats

        for _, route := range routes </span><span class="cov0" title="0">{
                stats.wsHandlerCount += len(route.WebSocketHandlers)
                for _, middleware := range route.MiddlewareCalls </span><span class="cov0" title="0">{
                        if strings.Contains(middleware, "Proxy") </span><span class="cov0" title="0">{
                                stats.proxyCount++
                                LogVerbose("🔍 Found Proxy middleware in route: %s", route.FuncName)
                        }</span>
                        // Count all middleware calls
                        <span class="cov0" title="0">stats.middlewareCount++</span>
                }
        }

        <span class="cov0" title="0">return stats</span>
}

// isMiddlewareMarker checks if a marker is a middleware marker
func isMiddlewareMarker(markerName string) bool <span class="cov0" title="0">{
        nonMiddlewareMarkers := []string{
                "Route", "Summary", "Description", "Tag", "Response",
                "RequestBody", "Schema", "Group", "Param",
        }

        for _, nonMiddleware := range nonMiddlewareMarkers </span><span class="cov0" title="0">{
                if markerName == nonMiddleware </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// getInitTemplate returns the default template for code generation
func getInitTemplate() string <span class="cov0" title="0">{
        return `// Code generated by gin-decorators; DO NOT EDIT.
// This file is automatically generated and works in both dev and prod modes.
package {{ .PackageName }}

import (
        "github.com/gin-gonic/gin"
{{- range .Imports }}
        {{ . }}
{{- end }}
)

func init() {
{{- range .Routes }}
{{- if and .Method .Path }}
        // {{ .Method }} {{ .Path }} -&gt; {{ .FuncName }}
        {{- if .Description }}
        // {{ .Description }}
        {{- end }}
        decorators.RegisterRouteWithMeta(&amp;decorators.RouteEntry{
                Method:      "{{ .Method }}",
                Path:        "{{ .Path }}",
                Handler:     {{ if eq $.PackageName "deco" }}handlers.{{ .FuncName }}{{ else }}{{ .FuncName }}{{ end }},
                {{- if .MiddlewareCalls }}
                Middlewares: []gin.HandlerFunc{
                        {{- range .MiddlewareCalls }}
                        {{ . }},
                        {{- end }}
                },
                {{- end }}
                FuncName:    "{{ .FuncName }}",
                PackageName: "{{ .PackageName }}",
                {{- if .Description }}
                Description: {{ escapeString .Description }},
                {{- end }}
                {{- if .Summary }}
                Summary:     {{ escapeString .Summary }},
                {{- end }}
                {{- if .Tags }}
                Tags:        []string{
                        {{- range .Tags }}
                        "{{ . }}",
                        {{- end }}
                },
                {{- end }}
                {{- if .MiddlewareInfo }}
                MiddlewareInfo: []decorators.MiddlewareInfo{
                        {{- range .MiddlewareInfo }}
                        {
                                Name:        {{ escapeString .Name }},
                                Description: {{ escapeString .Description }},
                                Args: map[string]interface{}{
                                        {{- range $key, $value := .Args }}
                                        {{ escapeString $key }}: {{ escapeString $value }},
                                        {{- end }}
                                },
                        },
                        {{- end }}
                },
                {{- end }}
                {{- if .Parameters }}
                Parameters: []decorators.ParameterInfo{
                        {{- range .Parameters }}
                        {
                                Name:        {{ escapeString .Name }},
                                Type:        {{ escapeString .Type }},
                                Location:    {{ escapeString .Location }},
                                Required:    {{ .Required }},
                                Description: {{ escapeString .Description }},
                                Example:     {{ escapeString .Example }},
                        },
                        {{- end }}
                },
                {{- end }}
                {{- if .Group }}
                Group: &amp;decorators.GroupInfo{
                        Name:        {{ escapeString .Group.Name }},
                        Prefix:      {{ escapeString .Group.Prefix }},
                        Description: {{ escapeString .Group.Description }},
                },
                {{- end }}
                {{- if .Responses }}
                Responses: []decorators.ResponseInfo{
                        {{- range .Responses }}
                        {
                                Code:        {{ escapeString .Code }},
                                Description: {{ escapeString .Description }},
                                Type:        {{ escapeString .Type }},
                                Example:     {{ escapeString .Example }},
                        },
                        {{- end }}
                },
                {{- end }}
        })
{{- else if .WebSocketHandlers }}
        // WebSocket-only handlers for {{ .FuncName }}
        {{- $funcName := .FuncName }}
        {{- range .WebSocketHandlers }}
        decorators.RegisterWebSocketHandler("{{ . }}", {{ if eq $.PackageName "deco" }}handlers.{{ $funcName }}{{ else }}{{ $funcName }}{{ end }})
        {{- end }}
        
        // Register WebSocket handlers as routes for documentation
        decorators.RegisterRouteWithMeta(&amp;decorators.RouteEntry{
                Method:      "WS",
                Path:        "/ws/{{ .FuncName }}",
                Handler:     decorators.WebSocketHandlerWrapper({{ if eq $.PackageName "deco" }}handlers.{{ .FuncName }}{{ else }}{{ .FuncName }}{{ end }}),
                FuncName:    "{{ .FuncName }}",
                PackageName: "{{ .PackageName }}",
                {{- if .Description }}
                Description: {{ escapeString .Description }},
                {{- end }}
                {{- if .Summary }}
                Summary:     {{ escapeString .Summary }},
                {{- end }}
                {{- if .Tags }}
                Tags:        []string{
                        {{- range .Tags }}
                        "{{ . }}",
                        {{- end }}
                },
                {{- end }}
                {{- if .MiddlewareInfo }}
                MiddlewareInfo: []decorators.MiddlewareInfo{
                        {{- range .MiddlewareInfo }}
                        {
                                Name:        {{ escapeString .Name }},
                                Description: {{ escapeString .Description }},
                                Args: map[string]interface{}{
                                        {{- range $key, $value := .Args }}
                                        {{ escapeString $key }}: {{ escapeString $value }},
                                        {{- end }}
                                },
                        },
                        {{- end }}
                },
                {{- end }}
                {{- if .Group }}
                Group: &amp;decorators.GroupInfo{
                        Name:        {{ escapeString .Group.Name }},
                        Prefix:      {{ escapeString .Group.Prefix }},
                        Description: {{ escapeString .Group.Description }},
                },
                {{- end }}
                WebSocketHandlers: []string{
                        {{- range .WebSocketHandlers }}
                        "{{ . }}",
                        {{- end }}
                },
        })
{{- end }}
{{- end }}

        // Initialize WebSocket default handlers
        decorators.RegisterDefaultWebSocketHandlers()
}

// Metadata generated automatically
var GeneratedMetadata = map[string]interface{}{
        "routes_count": {{ len .Routes }},
        "generated_at": "{{ .GeneratedAt }}",
        "package_name": "{{ .PackageName }}",
}
`
}</span>

// GenerateFromTemplate generates code using custom template
func GenerateFromTemplate(rootDir, templatePath, outputPath, pkgName string) error <span class="cov0" title="0">{
        // Parse source directory
        routes, err := ParseDirectory(rootDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in parsing: %v", err)
        }</span>

        // Run hooks
        <span class="cov0" title="0">if err := executeParserHooks(routes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">genData := &amp;GenData{
                PackageName: pkgName,
                Routes:      routes,
                Imports:     []string{},
                Metadata:    make(map[string]interface{}),
        }

        if err := executeGeneratorHooks(genData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load template customizado
        <span class="cov0" title="0">tmplContent, err := os.ReadFile(templatePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading template %s: %v", templatePath, err)
        }</span>

        <span class="cov0" title="0">tmpl, err := template.New("custom").Parse(string(tmplContent))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error processing template: %v", err)
        }</span>

        // Create output file
        <span class="cov0" title="0">outputFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating file: %v", err)
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        // Run template
        return tmpl.Execute(outputFile, genData)</span>
}

// ValidateGeneration validates if the generated file is correct
func ValidateGeneration(generatedPath string) error <span class="cov0" title="0">{
        // Check if file exists
        if _, err := os.Stat(generatedPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("generated file not found: %s", generatedPath)
        }</span>

        // Check if file is not empty
        <span class="cov0" title="0">info, err := os.Stat(generatedPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if info.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("generated file is empty: %s", generatedPath)
        }</span>

        // Complete Go syntax validation
        <span class="cov0" title="0">if err := validateGoSyntax(generatedPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("syntax error no generated file: %v", err)
        }</span>

        // Structural validation
        <span class="cov0" title="0">if err := validateStructure(generatedPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("structural error no generated file: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateGoSyntax validates the Go syntax of the file
func validateGoSyntax(filePath string) error <span class="cov0" title="0">{
        fset := token.NewFileSet()

        // Parse file
        file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("syntax error: %v", err)
        }</span>

        // Check if there are parsing errors
        <span class="cov0" title="0">if file == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file could not be parsed")
        }</span>

        // Validate basic AST structure
        <span class="cov0" title="0">if file.Name == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("package declaration not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateStructure validates the expected structure of the generated file
func validateStructure(filePath string) error <span class="cov0" title="0">{
        fset := token.NewFileSet()
        file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">structure := validateFileStructure(file)

        // Validate minimum expected structure
        if !structure.hasImports </span><span class="cov0" title="0">{
                return fmt.Errorf("necessary imports not founds")
        }</span>

        <span class="cov0" title="0">if !structure.hasInitFunc </span><span class="cov0" title="0">{
                return fmt.Errorf("init() function not found")
        }</span>

        // Allow files without route registrations if they have WebSocket handlers
        <span class="cov0" title="0">if !structure.hasRegistrations &amp;&amp; !structure.hasWebSocketHandlers </span><span class="cov0" title="0">{
                return fmt.Errorf("route registrations not founds na init() function")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type fileStructure struct {
        hasImports           bool
        hasInitFunc          bool
        hasRegistrations     bool
        hasWebSocketHandlers bool
}

func validateFileStructure(file *ast.File) fileStructure <span class="cov0" title="0">{
        structure := fileStructure{
                hasImports: len(file.Imports) &gt; 0,
        }

        // Verify declarations
        for _, decl := range file.Decls </span><span class="cov0" title="0">{
                if fnDecl, ok := decl.(*ast.FuncDecl); ok </span><span class="cov0" title="0">{
                        if fnDecl.Name.Name == "init" </span><span class="cov0" title="0">{
                                structure.hasInitFunc = true
                                structure = validateInitFunction(fnDecl, structure)
                        }</span>
                }
        }

        <span class="cov0" title="0">return structure</span>
}

func validateInitFunction(fnDecl *ast.FuncDecl, structure fileStructure) fileStructure <span class="cov0" title="0">{
        ast.Inspect(fnDecl, func(n ast.Node) bool </span><span class="cov0" title="0">{
                if callExpr, ok := n.(*ast.CallExpr); ok </span><span class="cov0" title="0">{
                        if selExpr, ok := callExpr.Fun.(*ast.SelectorExpr); ok </span><span class="cov0" title="0">{
                                switch selExpr.Sel.Name </span>{
                                case "RegisterRouteWithMeta":<span class="cov0" title="0">
                                        structure.hasRegistrations = true</span>
                                case "RegisterDefaultWebSocketHandlers":<span class="cov0" title="0">
                                        structure.hasWebSocketHandlers = true</span>
                                }
                        }
                }
                <span class="cov0" title="0">return true</span>
        })
        <span class="cov0" title="0">return structure</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package decorators

import (
        "net/http"
        "strings"
        "time"
)

// HealthCheckerImpl implements health checking for service instances
type HealthCheckerImpl struct {
        config ProxyConfig
        client *http.Client
}

// NewHealthChecker creates a new health checker
func NewHealthChecker(config *ProxyConfig) *HealthCheckerImpl <span class="cov10" title="37">{
        timeout, _ := time.ParseDuration(config.Timeout)
        if timeout == 0 </span><span class="cov5" title="5">{
                timeout = 5 * time.Second
        }</span>

        <span class="cov10" title="37">client := &amp;http.Client{
                Timeout: timeout,
        }

        return &amp;HealthCheckerImpl{
                config: *config,
                client: client,
        }</span>
}

// Check performs a health check on the given instance
func (hc *HealthCheckerImpl) Check(instance *ProxyInstance) bool <span class="cov8" title="22">{
        if hc.config.HealthCheck == "" </span><span class="cov1" title="1">{
                // No health check configured, assume healthy
                return true
        }</span>

        // Build health check URL
        <span class="cov8" title="21">healthURL := instance.URL
        if !strings.HasSuffix(healthURL, "/") </span><span class="cov8" title="20">{
                healthURL += "/"
        }</span>
        <span class="cov8" title="21">healthURL += strings.TrimPrefix(hc.config.HealthCheck, "/")

        // Perform HTTP health check
        resp, err := hc.client.Get(healthURL)
        if err != nil </span><span class="cov3" title="3">{
                return false
        }</span>
        <span class="cov8" title="18">defer resp.Body.Close()

        // Consider healthy if status code is 2xx
        return resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300</span>
}

// createHealthChecker creates a health checker from configuration
func createHealthChecker(config *ProxyConfig) HealthChecker <span class="cov7" title="15">{
        return NewHealthChecker(config)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package decorators

import (
        "crypto/sha256"
        "sync/atomic"

        "github.com/gin-gonic/gin"
)

// RoundRobinLoadBalancer implements round-robin load balancing
type RoundRobinLoadBalancer struct {
        current uint64
}

// Select selects the next instance in round-robin fashion
func (lb *RoundRobinLoadBalancer) Select(instances []*ProxyInstance, _ *gin.Context) *ProxyInstance <span class="cov8" title="32">{
        if len(instances) == 0 </span><span class="cov2" title="2">{
                return nil
        }</span>

        // Filter healthy instances
        <span class="cov8" title="30">var healthyInstances []*ProxyInstance
        for _, instance := range instances </span><span class="cov10" title="71">{
                instance.mu.RLock()
                if instance.Healthy </span><span class="cov9" title="67">{
                        healthyInstances = append(healthyInstances, instance)
                }</span>
                <span class="cov10" title="71">instance.mu.RUnlock()</span>
        }

        <span class="cov8" title="30">if len(healthyInstances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Get next index
        <span class="cov8" title="29">next := atomic.AddUint64(&amp;lb.current, 1)
        // Safe conversion: len() returns int, which is always positive and small
        // This conversion is safe because len() is always &gt;= 0 and typically small
        instanceCount := len(healthyInstances)
        if instanceCount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Safe conversion: instanceCount is always positive and small
        <span class="cov8" title="29">index := int(next % uint64(instanceCount)) // nolint:gosec // Safe: instanceCount is small

        return healthyInstances[index]</span>
}

// LeastConnectionsLoadBalancer implements least connections load balancing
type LeastConnectionsLoadBalancer struct{}

// Select selects the instance with the least active connections
func (lb *LeastConnectionsLoadBalancer) Select(instances []*ProxyInstance, _ *gin.Context) *ProxyInstance <span class="cov4" title="5">{
        if len(instances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="4">var selected *ProxyInstance
        minConns := int(^uint(0) &gt;&gt; 1) // Max int

        for _, instance := range instances </span><span class="cov5" title="9">{
                instance.mu.RLock()
                if instance.Healthy &amp;&amp; instance.ActiveConns &lt; minConns </span><span class="cov4" title="5">{
                        minConns = instance.ActiveConns
                        selected = instance
                }</span>
                <span class="cov5" title="9">instance.mu.RUnlock()</span>
        }

        <span class="cov3" title="4">return selected</span>
}

// IPHashLoadBalancer implements IP hash load balancing
type IPHashLoadBalancer struct{}

// Select selects instance based on client IP hash
func (lb *IPHashLoadBalancer) Select(instances []*ProxyInstance, c *gin.Context) *ProxyInstance <span class="cov4" title="5">{
        if len(instances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Filter healthy instances
        <span class="cov3" title="4">var healthyInstances []*ProxyInstance
        for _, instance := range instances </span><span class="cov5" title="8">{
                instance.mu.RLock()
                if instance.Healthy </span><span class="cov5" title="8">{
                        healthyInstances = append(healthyInstances, instance)
                }</span>
                <span class="cov5" title="8">instance.mu.RUnlock()</span>
        }

        <span class="cov3" title="4">if len(healthyInstances) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Hash client IP using SHA-256
        <span class="cov3" title="4">clientIP := c.ClientIP()
        hash := sha256.Sum256([]byte(clientIP))
        // Use first 8 bytes of hash for consistency
        hashValue := uint64(hash[0])&lt;&lt;56 | uint64(hash[1])&lt;&lt;48 | uint64(hash[2])&lt;&lt;40 | uint64(hash[3])&lt;&lt;32 |
                uint64(hash[4])&lt;&lt;24 | uint64(hash[5])&lt;&lt;16 | uint64(hash[6])&lt;&lt;8 | uint64(hash[7])

        // Safe conversion: len() returns int, which is always positive and small
        instanceCount := len(healthyInstances)
        if instanceCount == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Safe conversion: instanceCount is always positive and small
        <span class="cov3" title="4">index := int(hashValue % uint64(instanceCount)) // nolint:gosec // Safe: instanceCount is small
        return healthyInstances[index]</span>
}

// WeightedRoundRobinLoadBalancer implements weighted round-robin load balancing
type WeightedRoundRobinLoadBalancer struct {
        current uint64
}

// Select selects instance based on weighted round-robin
func (lb *WeightedRoundRobinLoadBalancer) Select(instances []*ProxyInstance, _ *gin.Context) *ProxyInstance <span class="cov6" title="16">{
        if len(instances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Filter healthy instances
        <span class="cov6" title="15">var healthyInstances []*ProxyInstance
        totalWeight := 0

        for _, instance := range instances </span><span class="cov8" title="41">{
                instance.mu.RLock()
                if instance.Healthy </span><span class="cov8" title="39">{
                        healthyInstances = append(healthyInstances, instance)
                        totalWeight += instance.Weight
                }</span>
                <span class="cov8" title="41">instance.mu.RUnlock()</span>
        }

        <span class="cov6" title="15">if len(healthyInstances) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Get next index
        <span class="cov6" title="14">next := atomic.AddUint64(&amp;lb.current, 1)
        // Safe conversion: totalWeight is always positive and typically small
        if totalWeight &lt;= 0 </span><span class="cov2" title="2">{
                return healthyInstances[0]
        }</span>
        // Safe conversion: totalWeight is always positive and small
        <span class="cov6" title="12">weightedIndex := int(next % uint64(totalWeight)) // nolint:gosec // Safe: totalWeight is small

        // Find instance based on weight
        currentWeight := 0
        for _, instance := range healthyInstances </span><span class="cov7" title="22">{
                currentWeight += instance.Weight
                if weightedIndex &lt; currentWeight </span><span class="cov6" title="12">{
                        return instance
                }</span>
        }

        // Fallback to first instance
        <span class="cov0" title="0">return healthyInstances[0]</span>
}

// createLoadBalancer creates a load balancer based on the algorithm name
func createLoadBalancer(algorithm string) LoadBalancer <span class="cov7" title="24">{
        switch algorithm </span>{
        case "round_robin":<span class="cov6" title="11">
                return &amp;RoundRobinLoadBalancer{}</span>
        case "least_connections":<span class="cov2" title="2">
                return &amp;LeastConnectionsLoadBalancer{}</span>
        case "ip_hash":<span class="cov2" title="2">
                return &amp;IPHashLoadBalancer{}</span>
        case "weighted":<span class="cov2" title="2">
                return &amp;WeightedRoundRobinLoadBalancer{}</span>
        default:<span class="cov5" title="7">
                // Default to round-robin
                return &amp;RoundRobinLoadBalancer{}</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package decorators

import (
        "log"
        "sync"
)

// LogLevel defines logging level
type LogLevel int

const (
        // LogLevelSilent indicates that no logs should be produced
        LogLevelSilent LogLevel = iota
        // LogLevelNormal indicates normal logging level
        LogLevelNormal
        // LogLevelVerbose indicates verbose logging level
        LogLevelVerbose
)

// Logger controla o logging do framework
type Logger struct {
        level LogLevel
        mu    sync.RWMutex
}

var globalLogger = &amp;Logger{level: LogLevelNormal}

// SetLogLevel defines logging level globally
func SetLogLevel(level LogLevel) <span class="cov7" title="52">{
        globalLogger.mu.Lock()
        defer globalLogger.mu.Unlock()
        globalLogger.level = level
}</span>

// GetLogLevel returns current logging level
func GetLogLevel() LogLevel <span class="cov10" title="303">{
        globalLogger.mu.RLock()
        defer globalLogger.mu.RUnlock()
        return globalLogger.level
}</span>

// SetVerbose ativa/desativa logs verbose
func SetVerbose(verbose bool) <span class="cov6" title="24">{
        if verbose </span><span class="cov4" title="12">{
                SetLogLevel(LogLevelVerbose)
        }</span> else<span class="cov4" title="12"> {
                SetLogLevel(LogLevelNormal)
        }</span>
}

// LogVerbose imprime log apenas em modo verbose
func LogVerbose(format string, args ...interface{}) <span class="cov9" title="239">{
        if GetLogLevel() &gt;= LogLevelVerbose </span><span class="cov9" title="195">{
                log.Printf(format, args...)
        }</span>
}

// LogNormal imprime log em modo normal e verbose
func LogNormal(format string, args ...interface{}) <span class="cov5" title="19">{
        if GetLogLevel() &gt;= LogLevelNormal </span><span class="cov5" title="17">{
                log.Printf(format, args...)
        }</span>
}

// LogSilent always prints log (used for important errors)
func LogSilent(format string, args ...interface{}) <span class="cov5" title="14">{
        log.Printf(format, args...)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package decorators

import (
        "net/http"
        "regexp"
        "strconv"
        "strings"

        "github.com/gin-gonic/gin"
)

// MarkerFactory function that creates a middleware based on arguments
type MarkerFactory func(args []string) gin.HandlerFunc

// MarkerConfig configuration of a marker
type MarkerConfig struct {
        Name        string                              // Marker name (ex: "Auth")
        Pattern     *regexp.Regexp                      // Regex to detect the marker
        Factory     func(args []string) gin.HandlerFunc // Factory to create middleware
        Description string                              // Marker description
}

// global markers registry
var markers = make(map[string]MarkerConfig)

// init registers default markers automatically
func init() <span class="cov1" title="1">{
        initDefaultMarkers()
}</span>

// RegisterMarker registers a new marker in the framework
func RegisterMarker(config MarkerConfig) <span class="cov10" title="39">{
        markers[config.Name] = config
        LogVerbose("Marker registered: %s", config.Name)
}</span>

// GetMarkers returns all registered markers
func GetMarkers() map[string]MarkerConfig <span class="cov5" title="7">{
        return markers
}</span>

// initDefaultMarkers registers framework default markers
func initDefaultMarkers() <span class="cov1" title="1">{
        // Middleware markers
        RegisterMarker(MarkerConfig{
                Name:    "Auth",
                Pattern: regexp.MustCompile(`@Auth\s*\(([^)]*)\)`),
                Factory: createAuthMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "Cache",
                Pattern: regexp.MustCompile(`@Cache\s*\(([^)]*)\)`),
                Factory: createCacheMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "CacheByURL",
                Pattern: regexp.MustCompile(`@CacheByURL\s*\(([^)]*)\)`),
                Factory: createCacheByURLMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "CacheByUser",
                Pattern: regexp.MustCompile(`@CacheByUser\s*\(([^)]*)\)`),
                Factory: createCacheByUserMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "CacheByEndpoint",
                Pattern: regexp.MustCompile(`@CacheByEndpoint\s*\(([^)]*)\)`),
                Factory: createCacheByEndpointMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "RateLimit",
                Pattern: regexp.MustCompile(`@RateLimit\s*\(([^)]*)\)`),
                Factory: createRateLimitMiddlewareInternal,
        })

        RegisterMarker(MarkerConfig{
                Name:    "RateLimitByIP",
                Pattern: regexp.MustCompile(`@RateLimitByIP\s*\(([^)]*)\)`),
                Factory: createRateLimitByIPMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "RateLimitByUser",
                Pattern: regexp.MustCompile(`@RateLimitByUser\s*\(([^)]*)\)`),
                Factory: createRateLimitByUserMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "RateLimitByEndpoint",
                Pattern: regexp.MustCompile(`@RateLimitByEndpoint\s*\(([^)]*)\)`),
                Factory: createRateLimitByEndpointMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "Metrics",
                Pattern: regexp.MustCompile(`@Metrics\s*\(([^)]*)\)`),
                Factory: createMetricsMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "Prometheus",
                Pattern: regexp.MustCompile(`@Prometheus\s*\(([^)]*)\)`),
                Factory: createPrometheusMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "HealthCheck",
                Pattern: regexp.MustCompile(`@HealthCheck\s*\(([^)]*)\)`),
                Factory: createHealthCheckMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "CacheStats",
                Pattern: regexp.MustCompile(`@CacheStats\s*\(([^)]*)\)`),
                Factory: createCacheStatsMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "InvalidateCache",
                Pattern: regexp.MustCompile(`@InvalidateCache\s*\(([^)]*)\)`),
                Factory: createInvalidateCacheMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "WebSocketStats",
                Pattern: regexp.MustCompile(`@WebSocketStats\s*\(([^)]*)\)`),
                Factory: createWebSocketStatsMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "TracingStats",
                Pattern: regexp.MustCompile(`@TracingStats\s*\(([^)]*)\)`),
                Factory: createTracingStatsMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "OpenAPIJSON",
                Pattern: regexp.MustCompile(`@OpenAPIJSON\s*\(([^)]*)\)`),
                Factory: createOpenAPIJSONMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "OpenAPIYAML",
                Pattern: regexp.MustCompile(`@OpenAPIYAML\s*\(([^)]*)\)`),
                Factory: createOpenAPIYAMLMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "SwaggerUI",
                Pattern: regexp.MustCompile(`@SwaggerUI\s*\(([^)]*)\)`),
                Factory: createSwaggerUIMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "TraceMiddleware",
                Pattern: regexp.MustCompile(`@TraceMiddleware\s*\(([^)]*)\)`),
                Factory: createTraceMiddlewareWrapper,
        })

        RegisterMarker(MarkerConfig{
                Name:    "HealthCheckWithTracing",
                Pattern: regexp.MustCompile(`@HealthCheckWithTracing\s*\(([^)]*)\)`),
                Factory: createHealthCheckWithTracingMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "InstrumentedHandler",
                Pattern: regexp.MustCompile(`@InstrumentedHandler\s*\(([^)]*)\)`),
                Factory: createInstrumentedHandlerMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "Validate",
                Pattern: regexp.MustCompile(`@Validate\s*\(([^)]*)\)`),
                Factory: createValidateMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "ValidateJSON",
                Pattern: regexp.MustCompile(`@ValidateJSON\s*\(([^)]*)\)`),
                Factory: createValidateJSONMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "ValidateQuery",
                Pattern: regexp.MustCompile(`@ValidateQuery\s*\(([^)]*)\)`),
                Factory: createValidateQueryMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "ValidateParams",
                Pattern: regexp.MustCompile(`@ValidateParams\s*\(([^)]*)\)`),
                Factory: createValidateParamsMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "Proxy",
                Pattern: regexp.MustCompile(`@Proxy\s*\(([^)]*)\)`),
                Factory: createProxyMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "Security",
                Pattern: regexp.MustCompile(`@Security\s*\(([^)]*)\)`),
                Factory: createSecurityMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "CORS",
                Pattern: regexp.MustCompile(`@CORS\s*\(([^)]*)\)`),
                Factory: createCORSMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "Telemetry",
                Pattern: regexp.MustCompile(`@Telemetry\s*\(([^)]*)\)`),
                Factory: createTelemetryMiddleware,
        })

        RegisterMarker(MarkerConfig{
                Name:    "WebSocket",
                Pattern: regexp.MustCompile(`@WebSocket\s*\(([^)]*)\)`),
                Factory: createWebSocketMiddleware,
        })

        // Documentation markers
        RegisterMarker(MarkerConfig{
                Name:    "Group",
                Pattern: regexp.MustCompile(`@Group\s*\(([^)]*)\)`),
                Factory: nil, // Does not generate middleware
        })

        RegisterMarker(MarkerConfig{
                Name:    "Param",
                Pattern: regexp.MustCompile(`@Param\s*\(([^)]*)\)`),
                Factory: nil, // Does not generate middleware
        })

        RegisterMarker(MarkerConfig{
                Name:    "Description",
                Pattern: regexp.MustCompile(`@Description\s*\(([^)]*)\)`),
                Factory: nil, // Does not generate middleware
        })

        RegisterMarker(MarkerConfig{
                Name:    "Summary",
                Pattern: regexp.MustCompile(`@Summary\s*\(([^)]*)\)`),
                Factory: nil, // Does not generate middleware
        })

        RegisterMarker(MarkerConfig{
                Name:    "Schema",
                Pattern: regexp.MustCompile(`@Schema\s*\(([^)]*)\)`),
                Factory: nil, // Documentation only - does not generate middleware
        })

        RegisterMarker(MarkerConfig{
                Name:    "Tag",
                Pattern: regexp.MustCompile(`@Tag\s*\(([^)]*)\)`),
                Factory: nil, // Does not generate middleware
        })

        RegisterMarker(MarkerConfig{
                Name:    "Response",
                Pattern: regexp.MustCompile(`@Response\s*\(([^)]*)\)`),
                Factory: nil, // Does not generate middleware
        })
}</span>

// createAuthMiddleware creates authentication middleware
func createAuthMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        var role string
        if len(args) &gt; 0 &amp;&amp; args[0] != "" </span><span class="cov2" title="2">{
                role = parseKeyValue(args[0], "role")
        }</span>

        <span class="cov4" title="4">return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov4" title="4">{
                token := c.GetHeader("Authorization")
                if token == "" </span><span class="cov4" title="4">{
                        c.JSON(401, gin.H{"error": "Token de autorização requerido"})
                        c.Abort()
                        return
                }</span>

                // Basic token validation (in production use JWT)
                <span class="cov0" title="0">if !strings.HasPrefix(token, "Bearer ") </span><span class="cov0" title="0">{
                        c.JSON(401, gin.H{"error": "Token inválido"})
                        c.Abort()
                        return
                }</span>

                // If role specified, validate
                <span class="cov0" title="0">if role != "" </span><span class="cov0" title="0">{
                        // Role validation logic (simulated)
                        c.Set("user_role", role)
                }</span>

                <span class="cov0" title="0">c.Set("authenticated", true)
                c.Next()</span>
        })
}

// createCacheMiddleware creates cache middleware
func createCacheMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        duration, cacheType, keyGen := ParseCacheArgs(args)

        config := &amp;CacheConfig{
                Type:       cacheType,
                DefaultTTL: duration.String(),
                MaxSize:    1000,
        }

        return CacheMiddleware(config, keyGen)
}</span>

// createCORSMiddleware creates CORS middleware
func createCORSMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        origins := "*"
        if len(args) &gt; 0 &amp;&amp; args[0] != "" </span><span class="cov1" title="1">{
                origins = parseKeyValue(args[0], "origins")
        }</span>

        <span class="cov2" title="2">return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov2" title="2">{
                c.Header("Access-Control-Allow-Origin", origins)
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov2" title="2">c.Next()</span>
        })
}

// parseKeyValue extracts value from a key=value string
func parseKeyValue(input, key string) string <span class="cov7" title="13">{
        pairs := strings.Split(input, ",")
        for _, pair := range pairs </span><span class="cov7" title="15">{
                kv := strings.Split(strings.TrimSpace(pair), "=")
                if len(kv) == 2 &amp;&amp; strings.TrimSpace(kv[0]) == key </span><span class="cov6" title="8">{
                        return strings.Trim(strings.TrimSpace(kv[1]), `"'`)
                }</span>
        }
        <span class="cov4" title="5">return ""</span>
}

// createValidateMiddleware creates general validation middleware
// Cannot customize required fields via args, as it depends on the validated struct
func createValidateMiddleware(_ []string) gin.HandlerFunc <span class="cov3" title="3">{
        // Args ignored, as validation depends on the struct
        config := DefaultConfig().Validation
        return ValidateStruct(&amp;config)
}</span>

// createValidateJSONMiddleware creates JSON validation middleware with support for required fields via args
func createValidateJSONMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        var requiredFields []string
        for _, arg := range args </span><span class="cov2" title="2">{
                if strings.HasPrefix(arg, "required=") </span><span class="cov0" title="0">{
                        fields := strings.TrimPrefix(arg, "required=")
                        requiredFields = strings.Split(fields, ",")
                }</span>
        }
        <span class="cov4" title="4">return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov4" title="4">{
                var data map[string]interface{}
                if err := c.ShouldBindJSON(&amp;data); err != nil </span><span class="cov4" title="4">{
                        response := ValidationResponse{
                                Error:   "validation_failed",
                                Message: "Invalid JSON format",
                                Fields: []ValidationField{{
                                        Field:   "json",
                                        Message: err.Error(),
                                }},
                        }
                        c.AbortWithStatusJSON(http.StatusBadRequest, response)
                        return
                }</span>
                // Check custom required fields
                <span class="cov0" title="0">for _, field := range requiredFields </span><span class="cov0" title="0">{
                        if _, ok := data[field]; !ok </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusBadRequest, ValidationResponse{
                                        Error:   "validation_failed",
                                        Message: "Required field missing: " + field,
                                })
                                return
                        }</span>
                }
                <span class="cov0" title="0">c.Set("validated_data", data)
                c.Next()</span>
        })
}

// createValidateQueryMiddleware creates query string validation middleware with support for required fields via args
func createValidateQueryMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        var requiredFields []string
        for _, arg := range args </span><span class="cov2" title="2">{
                if strings.HasPrefix(arg, "required=") </span><span class="cov0" title="0">{
                        fields := strings.TrimPrefix(arg, "required=")
                        requiredFields = strings.Split(fields, ",")
                }</span>
        }
        <span class="cov4" title="4">return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov4" title="4">{
                query := c.Request.URL.Query()
                validatedQuery := make(map[string]string)
                for key, values := range query </span><span class="cov0" title="0">{
                        if len(values) &gt; 0 </span><span class="cov0" title="0">{
                                validatedQuery[key] = values[0]
                        }</span>
                }
                // Check required fields
                <span class="cov4" title="4">for _, field := range requiredFields </span><span class="cov0" title="0">{
                        if _, ok := validatedQuery[field]; !ok </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusBadRequest, ValidationResponse{
                                        Error:   "validation_failed",
                                        Message: "Required field missing in query: " + field,
                                })
                                return
                        }</span>
                }
                <span class="cov4" title="4">c.Set("validated_query", validatedQuery)
                c.Next()</span>
        })
}

// createValidateParamsMiddleware creates path parameter validation middleware
func createValidateParamsMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        config := DefaultConfig().Validation

        // Extract rules from arguments
        rules := make(map[string]string)
        for _, arg := range args </span><span class="cov2" title="2">{
                if strings.Contains(arg, "=") </span><span class="cov2" title="2">{
                        parts := strings.SplitN(arg, "=", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"'`)
                        rules[key] = value
                }</span>
        }

        <span class="cov4" title="4">return ValidateParams(rules, &amp;config)</span>
}

// createWebSocketMiddleware creates WebSocket middleware with configuration support via args
func createWebSocketMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig().WebSocket
        for _, arg := range args </span><span class="cov1" title="1">{
                if strings.HasPrefix(arg, "pingInterval=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "pingInterval=")
                        config.PingInterval = v // string
                }</span>
                // MaxConnections doesn't exist in config, ignore
        }
        <span class="cov2" title="2">return CreateWebSocketHandler(&amp;config)</span>
}

// createCacheByURLMiddleware creates URL-based cache middleware with customizable TTL via args
func createCacheByURLMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        config := DefaultConfig().Cache
        for _, arg := range args </span><span class="cov2" title="2">{
                if strings.HasPrefix(arg, "ttl=") </span><span class="cov1" title="1">{
                        v := strings.TrimPrefix(arg, "ttl=")
                        config.DefaultTTL = v // string
                }</span>
        }
        <span class="cov4" title="4">return CacheByURL(&amp;config)</span>
}

// createCacheByUserMiddleware creates user+URL-based cache middleware with customizable TTL via args
func createCacheByUserMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        config := DefaultConfig().Cache
        for _, arg := range args </span><span class="cov2" title="2">{
                if strings.HasPrefix(arg, "ttl=") </span><span class="cov1" title="1">{
                        v := strings.TrimPrefix(arg, "ttl=")
                        config.DefaultTTL = v // string
                }</span>
        }
        <span class="cov4" title="4">return CacheByUserURL(&amp;config)</span>
}

// createPrometheusMiddleware creates Prometheus metrics middleware (no customizable args at the moment)
func createPrometheusMiddleware(_ []string) gin.HandlerFunc <span class="cov2" title="2">{
        return PrometheusHandler()
}</span>

// createHealthCheckMiddleware creates health check middleware (no customizable args at the moment)
func createHealthCheckMiddleware(_ []string) gin.HandlerFunc <span class="cov3" title="3">{
        return HealthCheckHandler()
}</span>

// createCacheStatsMiddleware creates cache statistics middleware with customizable maxSize via args
func createCacheStatsMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig().Cache
        for _, arg := range args </span><span class="cov1" title="1">{
                if strings.HasPrefix(arg, "maxSize=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "maxSize=")
                        if n, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                config.MaxSize = n
                        }</span>
                }
        }
        <span class="cov2" title="2">store := NewMemoryCache(config.MaxSize)
        return CacheStatsHandler(store)</span>
}

// createInvalidateCacheMiddleware creates cache invalidation middleware with customizable maxSize via args
func createInvalidateCacheMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig().Cache
        for _, arg := range args </span><span class="cov1" title="1">{
                if strings.HasPrefix(arg, "maxSize=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "maxSize=")
                        if n, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                config.MaxSize = n
                        }</span>
                }
        }
        <span class="cov2" title="2">store := NewMemoryCache(config.MaxSize)
        return InvalidateCacheHandler(store)</span>
}

// createWebSocketStatsMiddleware creates WebSocket statistics middleware (no customizable args at the moment)
func createWebSocketStatsMiddleware(_ []string) gin.HandlerFunc <span class="cov2" title="2">{
        return WebSocketStatsHandler()
}</span>

// createTracingStatsMiddleware creates tracing statistics middleware (no customizable args at the moment)
func createTracingStatsMiddleware(_ []string) gin.HandlerFunc <span class="cov2" title="2">{
        return TracingStatsHandler()
}</span>

// createOpenAPIJSONMiddleware creates OpenAPI JSON middleware (no customizable args at the moment)
func createOpenAPIJSONMiddleware(_ []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig()
        return OpenAPIJSONHandler(config)
}</span>

// createOpenAPIYAMLMiddleware creates OpenAPI YAML middleware (no customizable args at the moment)
func createOpenAPIYAMLMiddleware(_ []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig()
        return OpenAPIYAMLHandler(config)
}</span>

// createSwaggerUIMiddleware creates Swagger UI middleware (no customizable args at the moment)
func createSwaggerUIMiddleware(_ []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig()
        return SwaggerUIHandler(config)
}</span>

// createTraceMiddlewareWrapper creates trace middleware wrapper
func createTraceMiddlewareWrapper(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        middlewareName := "middleware"
        if len(args) &gt; 0 &amp;&amp; args[0] != "" </span><span class="cov1" title="1">{
                middlewareName = strings.Trim(args[0], `"'`)
        }</span>
        <span class="cov2" title="2">return TraceMiddleware(middlewareName)</span>
}

// createCacheByEndpointMiddleware creates endpoint-based cache middleware with customizable TTL via args
func createCacheByEndpointMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig().Cache
        for _, arg := range args </span><span class="cov1" title="1">{
                if strings.HasPrefix(arg, "ttl=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "ttl=")
                        config.DefaultTTL = v // string
                }</span>
        }
        <span class="cov2" title="2">return CacheByEndpoint(&amp;config)</span>
}

// createRateLimitByIPMiddleware creates IP-based rate limiting middleware with customizable limit via args
func createRateLimitByIPMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        config := DefaultConfig().RateLimit
        for _, arg := range args </span><span class="cov2" title="2">{
                if strings.HasPrefix(arg, "limit=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "limit=")
                        if n, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                config.DefaultRPS = n
                        }</span>
                }
        }
        <span class="cov4" title="4">return RateLimitByIP(&amp;config)</span>
}

// createRateLimitByUserMiddleware creates user-based rate limiting middleware with customizable limit via args
func createRateLimitByUserMiddleware(args []string) gin.HandlerFunc <span class="cov4" title="4">{
        config := DefaultConfig().RateLimit
        for _, arg := range args </span><span class="cov2" title="2">{
                if strings.HasPrefix(arg, "limit=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "limit=")
                        if n, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                config.DefaultRPS = n
                        }</span>
                }
        }
        <span class="cov4" title="4">return RateLimitByUser(&amp;config)</span>
}

// createRateLimitByEndpointMiddleware creates endpoint-based rate limiting middleware with customizable limit via args
func createRateLimitByEndpointMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        config := DefaultConfig().RateLimit
        for _, arg := range args </span><span class="cov1" title="1">{
                if strings.HasPrefix(arg, "limit=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "limit=")
                        if n, err := strconv.Atoi(v); err == nil </span><span class="cov0" title="0">{
                                config.DefaultRPS = n
                        }</span>
                }
        }
        <span class="cov2" title="2">return RateLimitByEndpoint(&amp;config)</span>
}

// createHealthCheckWithTracingMiddleware creates health check with tracing (no customizable args at the moment)
func createHealthCheckWithTracingMiddleware(_ []string) gin.HandlerFunc <span class="cov2" title="2">{
        return HealthCheckWithTracing()
}</span>

// createInstrumentedHandlerMiddleware creates instrumented handler middleware
func createInstrumentedHandlerMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        handlerName := "handler"
        if len(args) &gt; 0 &amp;&amp; args[0] != "" </span><span class="cov1" title="1">{
                handlerName = strings.Trim(args[0], `"'`)
        }</span>
        // Return a middleware that instruments the next handler
        <span class="cov2" title="2">return InstrumentedHandler(handlerName, func(c *gin.Context) </span><span class="cov2" title="2">{
                c.Next()
        }</span>)
}

// createSecurityMiddleware creates security middleware
func createSecurityMiddleware(args []string) gin.HandlerFunc <span class="cov2" title="2">{
        // Default to localhost only
        config := DefaultSecurityConfig()

        for _, arg := range args </span><span class="cov1" title="1">{
                switch </span>{
                case strings.HasPrefix(arg, "networks="):<span class="cov0" title="0">
                        networks := strings.TrimPrefix(arg, "networks=")
                        config.AllowedNetworks = strings.Split(networks, ",")</span>
                case strings.HasPrefix(arg, "ips="):<span class="cov0" title="0">
                        ips := strings.TrimPrefix(arg, "ips=")
                        config.AllowedIPs = strings.Split(ips, ",")</span>
                case strings.HasPrefix(arg, "hosts="):<span class="cov0" title="0">
                        hosts := strings.TrimPrefix(arg, "hosts=")
                        config.AllowedHosts = strings.Split(hosts, ",")</span>
                case arg == "private":<span class="cov0" title="0">
                        config.AllowPrivateNetworks = true</span>
                case arg == "localhost":<span class="cov0" title="0">
                        config.AllowLocalhost = true</span>
                case strings.HasPrefix(arg, "message="):<span class="cov0" title="0">
                        config.ErrorMessage = strings.TrimPrefix(arg, "message=")</span>
                case arg == "nolog":<span class="cov0" title="0">
                        config.LogBlockedAttempts = false</span>
                }
        }

        <span class="cov2" title="2">return SecureInternalEndpoints(config)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package decorators

import (
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// MetricsCollector collects custom metrics
type MetricsCollector struct {
        // HTTP request metrics
        httpRequestsTotal   *prometheus.CounterVec
        httpRequestDuration *prometheus.HistogramVec
        httpRequestSize     *prometheus.HistogramVec
        httpResponseSize    *prometheus.HistogramVec
        httpActiveRequests  *prometheus.GaugeVec

        // Middleware metrics
        middlewareExecutionTime *prometheus.HistogramVec
        middlewareErrors        *prometheus.CounterVec

        // Cache metrics
        cacheHits   *prometheus.CounterVec
        cacheMisses *prometheus.CounterVec
        cacheSize   *prometheus.GaugeVec

        // Rate limiting metrics
        rateLimitHits     *prometheus.CounterVec
        rateLimitExceeded *prometheus.CounterVec

        // Validation metrics
        validationErrors *prometheus.CounterVec
        validationTime   *prometheus.HistogramVec

        // System metrics
        gorutines       prometheus.Gauge
        memoryAllocated prometheus.Gauge
}

// DefaultMetricsCollector global instance default
var (
        defaultMetricsCollector *MetricsCollector
        metricsInitMutex        sync.RWMutex
        metricsInitialized      bool
)

// InitMetrics initializes metrics system
func InitMetrics(config *MetricsConfig) *MetricsCollector <span class="cov4" title="4">{
        metricsInitMutex.Lock()
        defer metricsInitMutex.Unlock()

        // Check if already initialized
        if metricsInitialized &amp;&amp; defaultMetricsCollector != nil </span><span class="cov0" title="0">{
                return defaultMetricsCollector
        }</span>

        <span class="cov4" title="4">collector := &amp;MetricsCollector{
                // HTTP metrics
                httpRequestsTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "http_requests_total",
                                Help:      "Total number of HTTP requests",
                        },
                        []string{"method", "endpoint", "status", "handler"},
                ),

                httpRequestDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "http_request_duration_seconds",
                                Help:      "Duration of HTTP requests in seconds",
                                Buckets:   config.Buckets,
                        },
                        []string{"method", "endpoint", "status"},
                ),

                httpRequestSize: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "http_request_size_bytes",
                                Help:      "Size of HTTP requests in bytes",
                                Buckets:   prometheus.ExponentialBuckets(100, 10, 5),
                        },
                        []string{"method", "endpoint"},
                ),

                httpResponseSize: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "http_response_size_bytes",
                                Help:      "Size of HTTP responses in bytes",
                                Buckets:   prometheus.ExponentialBuckets(100, 10, 5),
                        },
                        []string{"method", "endpoint", "status"},
                ),

                httpActiveRequests: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "http_active_requests",
                                Help:      "Number of active HTTP requests",
                        },
                        []string{"method", "endpoint"},
                ),

                // Middleware metrics
                middlewareExecutionTime: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "middleware_execution_time_seconds",
                                Help:      "Time spent executing middlewares",
                                Buckets:   prometheus.DefBuckets,
                        },
                        []string{"middleware", "endpoint"},
                ),

                middlewareErrors: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "middleware_errors_total",
                                Help:      "Total number of middleware errors",
                        },
                        []string{"middleware", "error_type"},
                ),

                // Cache metrics
                cacheHits: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "cache_hits_total",
                                Help:      "Total number of cache hits",
                        },
                        []string{"cache_type", "key_type"},
                ),

                cacheMisses: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "cache_misses_total",
                                Help:      "Total number of cache misses",
                        },
                        []string{"cache_type", "key_type"},
                ),

                cacheSize: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "cache_size",
                                Help:      "Current cache size",
                        },
                        []string{"cache_type"},
                ),

                // Rate limiting metrics
                rateLimitHits: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "rate_limit_hits_total",
                                Help:      "Total number of rate limit checks",
                        },
                        []string{"endpoint", "limit_type"},
                ),

                rateLimitExceeded: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "rate_limit_exceeded_total",
                                Help:      "Total number of rate limit exceeded",
                        },
                        []string{"endpoint", "limit_type"},
                ),

                // Validation metrics
                validationErrors: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "validation_errors_total",
                                Help:      "Total number of validation errors",
                        },
                        []string{"validation_type", "field"},
                ),

                validationTime: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "validation_time_seconds",
                                Help:      "Time spent validating requests",
                                Buckets:   prometheus.DefBuckets,
                        },
                        []string{"validation_type"},
                ),

                // System metrics
                gorutines: prometheus.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "goroutines",
                                Help:      "Number of goroutines",
                        },
                ),

                memoryAllocated: prometheus.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: config.Namespace,
                                Subsystem: config.Subsystem,
                                Name:      "memory_allocated_bytes",
                                Help:      "Memory allocated in bytes",
                        },
                ),
        }

        // Register metrics only if not already registered
        if !metricsInitialized </span><span class="cov4" title="4">{
                // Use Register instead of MustRegister to avoid panic on duplicate registration
                metrics := []prometheus.Collector{
                        collector.httpRequestsTotal,
                        collector.httpRequestDuration,
                        collector.httpRequestSize,
                        collector.httpResponseSize,
                        collector.httpActiveRequests,
                        collector.middlewareExecutionTime,
                        collector.middlewareErrors,
                        collector.cacheHits,
                        collector.cacheMisses,
                        collector.cacheSize,
                        collector.rateLimitHits,
                        collector.rateLimitExceeded,
                        collector.validationErrors,
                        collector.validationTime,
                        collector.gorutines,
                        collector.memoryAllocated,
                }

                for _, metric := range metrics </span><span class="cov10" title="64">{
                        if err := prometheus.Register(metric); err != nil </span><span class="cov9" title="48">{
                                // If metric is already registered, unregister and register again
                                if are, ok := err.(prometheus.AlreadyRegisteredError); ok </span><span class="cov9" title="48">{
                                        prometheus.Unregister(are.ExistingCollector)
                                        if err := prometheus.Register(metric); err != nil </span><span class="cov0" title="0">{
                                                // Log error but continue with other metrics
                                                LogNormal("Failed to register metric after unregister: %v", err)
                                        }</span>
                                }
                        }
                }
                <span class="cov4" title="4">metricsInitialized = true</span>
        }

        <span class="cov4" title="4">defaultMetricsCollector = collector
        return collector</span>
}

// MetricsMiddleware main middleware for metrics collection
func MetricsMiddleware(config *MetricsConfig) gin.HandlerFunc <span class="cov5" title="10">{
        if !config.Enabled </span><span class="cov5" title="7">{
                return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov4" title="5">{
                        c.Next()
                }</span>)
        }

        // Initialize collector if not exist
        <span class="cov3" title="3">metricsInitMutex.RLock()
        if defaultMetricsCollector == nil </span><span class="cov2" title="2">{
                metricsInitMutex.RUnlock()
                InitMetrics(config)
        }</span> else<span class="cov1" title="1"> {
                metricsInitMutex.RUnlock()
        }</span>

        <span class="cov3" title="3">return func(c *gin.Context) </span><span class="cov2" title="2">{
                start := time.Now()

                // Increment active requests
                endpoint := getEndpointPattern(c)
                method := c.Request.Method

                defaultMetricsCollector.httpActiveRequests.WithLabelValues(method, endpoint).Inc()

                // Register request size
                if c.Request.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        defaultMetricsCollector.httpRequestSize.WithLabelValues(method, endpoint).Observe(float64(c.Request.ContentLength))
                }</span>

                // Capture response
                <span class="cov2" title="2">writer := &amp;metricsResponseWriter{
                        ResponseWriter: c.Writer,
                        size:           0,
                }
                c.Writer = writer

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(start)
                status := strconv.Itoa(writer.status)

                // Register metrics
                defaultMetricsCollector.httpRequestsTotal.WithLabelValues(method, endpoint, status, "unknown").Inc()
                defaultMetricsCollector.httpRequestDuration.WithLabelValues(method, endpoint, status).Observe(duration.Seconds())
                defaultMetricsCollector.httpResponseSize.WithLabelValues(method, endpoint, status).Observe(float64(writer.size))

                // Decrement active requests
                defaultMetricsCollector.httpActiveRequests.WithLabelValues(method, endpoint).Dec()</span>
        }
}

// metricsResponseWriter wrapper to capture response size
type metricsResponseWriter struct {
        gin.ResponseWriter
        size   int
        status int
}

func (w *metricsResponseWriter) Write(data []byte) (int, error) <span class="cov2" title="2">{
        size, err := w.ResponseWriter.Write(data)
        w.size += size
        return size, err
}</span>

func (w *metricsResponseWriter) WriteHeader(statusCode int) <span class="cov2" title="2">{
        w.status = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

// getEndpointPattern extracts endpoint pattern
func getEndpointPattern(c *gin.Context) string <span class="cov4" title="5">{
        // Use FullPath() if available, otherwise use Path
        if fullPath := c.FullPath(); fullPath != "" </span><span class="cov1" title="1">{
                return fullPath
        }</span>

        // If no FullPath, try to reconstruct from params
        <span class="cov4" title="4">path := c.Request.URL.Path
        if len(c.Params) &gt; 0 </span><span class="cov2" title="2">{
                // Replace actual values with parameter names
                for _, param := range c.Params </span><span class="cov3" title="3">{
                        path = strings.Replace(path, param.Value, ":"+param.Key, 1)
                }</span>
        }

        <span class="cov4" title="4">return path</span>
}

// RecordCacheHit registra hit de cache
func RecordCacheHit(cacheType, keyType string) <span class="cov6" title="12">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov6" title="12">{
                defaultMetricsCollector.cacheHits.WithLabelValues(cacheType, keyType).Inc()
        }</span>
}

// RecordCacheMiss registra miss de cache
func RecordCacheMiss(cacheType, keyType string) <span class="cov6" title="12">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov6" title="12">{
                defaultMetricsCollector.cacheMisses.WithLabelValues(cacheType, keyType).Inc()
        }</span>
}

// RecordCacheSize registra tamanho do cache
func RecordCacheSize(cacheType string, size float64) <span class="cov2" title="2">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov2" title="2">{
                defaultMetricsCollector.cacheSize.WithLabelValues(cacheType).Set(size)
        }</span>
}

// RecordRateLimitHit records rate limit check
func RecordRateLimitHit(endpoint, limitType string) <span class="cov6" title="12">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov6" title="12">{
                defaultMetricsCollector.rateLimitHits.WithLabelValues(endpoint, limitType).Inc()
        }</span>
}

// RecordRateLimitExceeded registra rate limit excedido
func RecordRateLimitExceeded(endpoint, limitType string) <span class="cov2" title="2">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov2" title="2">{
                defaultMetricsCollector.rateLimitExceeded.WithLabelValues(endpoint, limitType).Inc()
        }</span>
}

// RecordValidationError records validation error
func RecordValidationError(validationType, field string) <span class="cov6" title="12">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov6" title="12">{
                defaultMetricsCollector.validationErrors.WithLabelValues(validationType, field).Inc()
        }</span>
}

// RecordValidationTime records validation time
func RecordValidationTime(validationType string, duration time.Duration) <span class="cov2" title="2">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov2" title="2">{
                defaultMetricsCollector.validationTime.WithLabelValues(validationType).Observe(duration.Seconds())
        }</span>
}

// RecordMiddlewareTime records middleware execution time
func RecordMiddlewareTime(middleware, endpoint string, duration time.Duration) <span class="cov2" title="2">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov2" title="2">{
                defaultMetricsCollector.middlewareExecutionTime.WithLabelValues(middleware, endpoint).Observe(duration.Seconds())
        }</span>
}

// RecordMiddlewareError records middleware error
func RecordMiddlewareError(middleware, errorType string) <span class="cov2" title="2">{
        metricsInitMutex.RLock()
        defer metricsInitMutex.RUnlock()
        if defaultMetricsCollector != nil </span><span class="cov2" title="2">{
                defaultMetricsCollector.middlewareErrors.WithLabelValues(middleware, errorType).Inc()
        }</span>
}

// PrometheusHandler returns Prometheus handler
func PrometheusHandler() gin.HandlerFunc <span class="cov3" title="3">{
        handler := promhttp.Handler()
        return func(c *gin.Context) </span><span class="cov1" title="1">{
                handler.ServeHTTP(c.Writer, c.Request)
        }</span>
}

// HealthCheckHandler health check handler with metrics
func HealthCheckHandler() gin.HandlerFunc <span class="cov4" title="4">{
        return func(c *gin.Context) </span><span class="cov4" title="4">{
                // Basic health information
                health := gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().Unix(),
                        "service":   "gin-decorators",
                }

                // Add metrics if available
                metricsInitMutex.RLock()
                if defaultMetricsCollector != nil </span><span class="cov1" title="1">{
                        // Get some basic metrics via registry
                        metricFamilies, err := prometheus.DefaultGatherer.Gather()
                        if err == nil </span><span class="cov1" title="1">{
                                metrics := make(map[string]interface{})

                                for _, mf := range metricFamilies </span><span class="cov9" title="53">{
                                        if strings.Contains(mf.GetName(), "http_requests_total") </span><span class="cov1" title="1">{
                                                var total float64
                                                for _, metric := range mf.GetMetric() </span><span class="cov1" title="1">{
                                                        total += metric.GetCounter().GetValue()
                                                }</span>
                                                <span class="cov1" title="1">metrics["total_requests"] = total</span>
                                        }
                                }

                                <span class="cov1" title="1">health["metrics"] = metrics</span>
                        }
                }
                <span class="cov4" title="4">metricsInitMutex.RUnlock()

                c.JSON(http.StatusOK, health)</span>
        }
}

// createMetricsMiddleware creates metrics middleware with customizable settings via args
func createMetricsMiddleware(args []string) gin.HandlerFunc <span class="cov5" title="7">{
        config := DefaultConfig().Metrics

        // Parse custom settings from args
        for _, arg := range args </span><span class="cov4" title="6">{
                if strings.HasPrefix(arg, "namespace=") </span><span class="cov1" title="1">{
                        v := strings.TrimPrefix(arg, "namespace=")
                        config.Namespace = v
                }</span>
                <span class="cov4" title="6">if strings.HasPrefix(arg, "subsystem=") </span><span class="cov1" title="1">{
                        v := strings.TrimPrefix(arg, "subsystem=")
                        config.Subsystem = v
                }</span>
                <span class="cov4" title="6">if strings.HasPrefix(arg, "endpoint=") </span><span class="cov1" title="1">{
                        v := strings.TrimPrefix(arg, "endpoint=")
                        config.Endpoint = v
                }</span>
                <span class="cov4" title="6">if strings.HasPrefix(arg, "enabled=") </span><span class="cov1" title="1">{
                        v := strings.TrimPrefix(arg, "enabled=")
                        if enabled, err := strconv.ParseBool(v); err == nil </span><span class="cov1" title="1">{
                                config.Enabled = enabled
                        }</span>
                }
        }

        <span class="cov5" title="7">return MetricsMiddleware(&amp;config)</span>
}

// MetricsInfo information about available metrics
type MetricsInfo struct {
        Enabled   bool     `json:"enabled"`
        Endpoint  string   `json:"endpoint"`
        Namespace string   `json:"namespace"`
        Subsystem string   `json:"subsystem"`
        Metrics   []string `json:"metrics"`
}

// GetMetricsInfo returns information about metrics
func GetMetricsInfo(config *MetricsConfig) MetricsInfo <span class="cov1" title="1">{
        metrics := []string{
                "http_requests_total",
                "http_request_duration_seconds",
                "http_request_size_bytes",
                "http_response_size_bytes",
                "http_active_requests",
                "middleware_execution_time_seconds",
                "middleware_errors_total",
                "cache_hits_total",
                "cache_misses_total",
                "cache_size",
                "rate_limit_hits_total",
                "rate_limit_exceeded_total",
                "validation_errors_total",
                "validation_time_seconds",
                "goroutines",
                "memory_allocated_bytes",
        }

        return MetricsInfo{
                Enabled:   config.Enabled,
                Endpoint:  config.Endpoint,
                Namespace: config.Namespace,
                Subsystem: config.Subsystem,
                Metrics:   metrics,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package decorators

import (
        "fmt"
        "go/ast"
        "go/format"
        "go/parser"
        "go/token"
        "os"
        "regexp"
        "strings"
)

// MinifyCode minifies Go code by removing comments and unnecessary spaces
func MinifyCode(inputPath, outputPath string, enabled bool) error <span class="cov3" title="4">{
        if !enabled </span><span class="cov1" title="1">{
                // If minification is disabled, just copy the file
                return copyFile(inputPath, outputPath)
        }</span>

        // Read file original
        <span class="cov3" title="3">content, err := os.ReadFile(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading file: %v", err)
        }</span>

        // Apply minification
        <span class="cov3" title="3">minifiedContent, err := minifyGoCode(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in minification: %v", err)
        }</span>

        // Escrever file minificado
        <span class="cov3" title="3">if err := os.WriteFile(outputPath, []byte(minifiedContent), 0o600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error ao escrever file minificado: %v", err)
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// minifyGoCode minifies Go code while maintaining functionality
func minifyGoCode(code string) (string, error) <span class="cov4" title="6">{
        // Method 1: Use AST to remove comments and format
        minified, err := minifyWithAST(code)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback: Simple regex-based minification
                return minifyWithRegex(code), nil
        }</span>

        // Apply additional minification
        <span class="cov4" title="6">return applyAdditionalMinification(minified), nil</span>
}

// minifyWithAST uses AST to remove comments and reformat
func minifyWithAST(code string) (string, error) <span class="cov5" title="9">{
        fset := token.NewFileSet()

        // Parse code
        file, err := parser.ParseFile(fset, "", code, parser.ParseComments)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        // Remove comments (except build and generation comments)
        <span class="cov5" title="8">file.Comments = filterComments(file.Comments)

        // Reformat code
        var buf strings.Builder
        if err := format.Node(&amp;buf, fset, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov5" title="8">return buf.String(), nil</span>
}

// filterComments filters comments keeping only essential ones
func filterComments(comments []*ast.CommentGroup) []*ast.CommentGroup <span class="cov5" title="8">{
        var filtered []*ast.CommentGroup

        for _, group := range comments </span><span class="cov6" title="19">{
                for _, comment := range group.List </span><span class="cov6" title="20">{
                        text := comment.Text

                        // Keep important comments
                        if strings.Contains(text, "Code generated") ||
                                strings.Contains(text, "DO NOT EDIT") ||
                                strings.Contains(text, "//go:build") ||
                                strings.Contains(text, "+build") </span><span class="cov3" title="4">{
                                filtered = append(filtered, group)
                                break</span>
                        }
                }
        }

        <span class="cov5" title="8">return filtered</span>
}

// minifyWithRegex simple regex-based minification application
func minifyWithRegex(code string) string <span class="cov3" title="3">{
        lines := strings.Split(code, "\n")
        minified := make([]string, 0, len(lines))

        for _, line := range lines </span><span class="cov6" title="18">{
                trimmed := strings.TrimSpace(line)

                // Pular linhas vazias
                if trimmed == "" </span><span class="cov3" title="4">{
                        continue</span>
                }

                // Keep important comments
                <span class="cov6" title="14">if strings.HasPrefix(trimmed, "//") </span><span class="cov2" title="2">{
                        if strings.Contains(trimmed, "Code generated") ||
                                strings.Contains(trimmed, "DO NOT EDIT") ||
                                strings.Contains(trimmed, "go:build") ||
                                strings.Contains(trimmed, "+build") </span><span class="cov1" title="1">{
                                minified = append(minified, line)
                        }</span>
                        <span class="cov2" title="2">continue</span>
                }

                // Keep important block comments
                <span class="cov5" title="12">if strings.HasPrefix(trimmed, "/*") &amp;&amp;
                        (strings.Contains(trimmed, "Code generated") ||
                                strings.Contains(trimmed, "DO NOT EDIT")) </span><span class="cov0" title="0">{
                        minified = append(minified, line)
                        continue</span>
                }

                // Add code line
                <span class="cov5" title="12">minified = append(minified, line)</span>
        }

        <span class="cov3" title="3">return strings.Join(minified, "\n")</span>
}

// applyAdditionalMinification applies additional minifications
func applyAdditionalMinification(code string) string <span class="cov5" title="8">{
        // Remove multiple consecutive empty lines
        multipleNewlines := regexp.MustCompile(`\n\s*\n\s*\n`)
        code = multipleNewlines.ReplaceAllString(code, "\n\n")

        // Remove excess spaces in lines
        lines := strings.Split(code, "\n")
        cleaned := make([]string, 0, len(lines))

        for _, line := range lines </span><span class="cov9" title="84">{
                // Keep indentation but clean unnecessary spaces at the end
                cleaned = append(cleaned, strings.TrimRight(line, " \t"))
        }</span>

        // Compact imports when possible
        <span class="cov5" title="8">code = strings.Join(cleaned, "\n")
        code = compactImports(code)

        return code</span>
}

// compactImports compacts import section when possible
func compactImports(code string) string <span class="cov5" title="10">{
        lines := strings.Split(code, "\n")
        var result []string
        inImports := false
        var importLines []string

        for _, line := range lines </span><span class="cov10" title="104">{
                trimmed := strings.TrimSpace(line)

                if trimmed == "import (" </span><span class="cov3" title="3">{
                        inImports = true
                        result = append(result, line)
                        continue</span>
                }

                <span class="cov9" title="101">if inImports &amp;&amp; trimmed == ")" </span><span class="cov3" title="3">{
                        // Process imports coletados
                        if len(importLines) &gt; 0 </span><span class="cov3" title="3">{
                                // Remove empty lines between imports
                                var compactImports []string
                                for _, imp := range importLines </span><span class="cov5" title="10">{
                                        if strings.TrimSpace(imp) != "" </span><span class="cov5" title="8">{
                                                compactImports = append(compactImports, imp)
                                        }</span>
                                }
                                <span class="cov3" title="3">result = append(result, compactImports...)</span>
                        }
                        <span class="cov3" title="3">result = append(result, line)
                        inImports = false
                        importLines = nil
                        continue</span>
                }

                <span class="cov9" title="98">if inImports </span><span class="cov5" title="10">{
                        importLines = append(importLines, line)
                }</span> else<span class="cov9" title="88"> {
                        result = append(result, line)
                }</span>
        }

        <span class="cov5" title="10">return strings.Join(result, "\n")</span>
}

// copyFile copies file when minification is disabled
func copyFile(src, dst string) error <span class="cov3" title="3">{
        input, err := os.ReadFile(src)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov2" title="2">return os.WriteFile(dst, input, 0o600)</span>
}

// GetMinifiedTemplate returns minified template for generation
func GetMinifiedTemplate() string <span class="cov1" title="1">{
        return `// Code generated by gin-decorators; DO NOT EDIT.
package {{ .PackageName }}
import ("github.com/gin-gonic/gin"
{{- range .Imports }}
{{ . }}
{{- end }}
)
func init() {
{{- range .Routes }}
deco.RegisterRouteWithMeta(deco.RouteEntry{Method:"{{ .Method }}",Path:"{{ .Path }}",Handler:{{ if eq $.PackageName "deco" }}handlers.{{ .FuncName }}{{ else }}{{ .FuncName }}{{ end }},
{{- if .MiddlewareCalls }}
Middlewares:[]gin.HandlerFunc{
{{- range .MiddlewareCalls }}
{{ . }},
{{- end }}
},
{{- end }}
FuncName:"{{ .FuncName }}",PackageName:"{{ .PackageName }}",
{{- if .Description }}
Description:"{{ .Description }}",
{{- end }}
{{- if .Summary }}
Summary:"{{ .Summary }}",
{{- end }}
{{- if .Tags }}
Tags:[]string{
{{- range .Tags }}
"{{ . }}",
{{- end }}
},
{{- end }}
{{- if .MiddlewareInfo }}
MiddlewareInfo:[]deco.MiddlewareInfo{
{{- range .MiddlewareInfo }}
{Name:"{{ .Name }}",Description:"{{ .Description }}",Args:map[string]interface{}{
{{- range $key, $value := .Args }}
"{{ $key }}":"{{ $value }}",
{{- end }}
}},
{{- end }}
},
{{- end }}
{{- if .Parameters }}
Parameters:[]deco.ParameterInfo{
{{- range .Parameters }}
{Name:"{{ .Name }}",Type:"{{ .Type }}",Location:"{{ .Location }}",Required:{{ .Required }},Description:"{{ .Description }}",Example:"{{ .Example }}"},
{{- end }}
},
{{- end }}
{{- if .Group }}
Group:&amp;deco.GroupInfo{Name:"{{ .Group.Name }}",Prefix:"{{ .Group.Prefix }}",Description:"{{ .Group.Description }}"},
{{- end }}
{{- if .Responses }}
Responses:[]decorators.ResponseInfo{
{{- range .Responses }}
{Code:"{{ .Code }}",Description:"{{ .Description }}",Type:"{{ .Type }}",Example:"{{ .Example }}"},
{{- end }}
},
{{- end }}
})
{{- end }}
}
var GeneratedMetadata=map[string]interface{}{"routes_count":{{ len .Routes }},"generated_at":"{{ .GeneratedAt }}","package_name":"{{ .PackageName }}"}
`
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package decorators

import (
        "fmt"
        "net/http"
        "regexp"
        "strings"

        "github.com/gin-gonic/gin"
        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

// OpenAPISpec complete OpenAPI 3.0 specification structure
type OpenAPISpec struct {
        OpenAPI      string                 `json:"openapi"`
        Info         OpenAPIInfo            `json:"info"`
        Servers      []OpenAPIServer        `json:"servers,omitempty"`
        Paths        map[string]OpenAPIPath `json:"paths"`
        Components   *OpenAPIComponents     `json:"components,omitempty"`
        Security     []SecurityRequirement  `json:"security,omitempty"`
        Tags         []OpenAPITag           `json:"tags,omitempty"`
        ExternalDocs *ExternalDocs          `json:"externalDocs,omitempty"`
}

// OpenAPIInfo basic API information
type OpenAPIInfo struct {
        Title          string   `json:"title"`
        Description    string   `json:"description,omitempty"`
        TermsOfService string   `json:"termsOfService,omitempty"`
        Contact        *Contact `json:"contact,omitempty"`
        License        *License `json:"license,omitempty"`
        Version        string   `json:"version"`
}

// Contact contact information
type Contact struct {
        Name  string `json:"name,omitempty"`
        URL   string `json:"url,omitempty"`
        Email string `json:"email,omitempty"`
}

// License license information
type License struct {
        Name string `json:"name"`
        URL  string `json:"url,omitempty"`
}

// OpenAPIServer server information
type OpenAPIServer struct {
        URL         string                    `json:"url"`
        Description string                    `json:"description,omitempty"`
        Variables   map[string]ServerVariable `json:"variables,omitempty"`
}

// ServerVariable server variable
type ServerVariable struct {
        Enum        []string `json:"enum,omitempty"`
        Default     string   `json:"default"`
        Description string   `json:"description,omitempty"`
}

// OpenAPIPath operations available on a path
type OpenAPIPath map[string]*OpenAPIOperation

// OpenAPIOperation individual operation
type OpenAPIOperation struct {
        Tags        []string                   `json:"tags,omitempty"`
        Summary     string                     `json:"summary,omitempty"`
        Description string                     `json:"description,omitempty"`
        OperationID string                     `json:"operationId,omitempty"`
        Parameters  []OpenAPIParameter         `json:"parameters,omitempty"`
        RequestBody *OpenAPIRequestBody        `json:"requestBody,omitempty"`
        Responses   map[string]OpenAPIResponse `json:"responses"`
        Callbacks   map[string]interface{}     `json:"callbacks,omitempty"`
        Deprecated  bool                       `json:"deprecated,omitempty"`
        Security    []SecurityRequirement      `json:"security,omitempty"`
        Servers     []OpenAPIServer            `json:"servers,omitempty"`
        Extensions  map[string]interface{}     `json:"-"`
}

// OpenAPIParameter operation parameter
type OpenAPIParameter struct {
        Name            string               `json:"name"`
        In              string               `json:"in"` // query, header, path, cookie
        Description     string               `json:"description,omitempty"`
        Required        bool                 `json:"required,omitempty"`
        Deprecated      bool                 `json:"deprecated,omitempty"`
        AllowEmptyValue bool                 `json:"allowEmptyValue,omitempty"`
        Style           string               `json:"style,omitempty"`
        Explode         bool                 `json:"explode,omitempty"`
        AllowReserved   bool                 `json:"allowReserved,omitempty"`
        Schema          *OpenAPISchema       `json:"schema,omitempty"`
        Example         interface{}          `json:"example,omitempty"`
        Examples        map[string]Example   `json:"examples,omitempty"`
        Content         map[string]MediaType `json:"content,omitempty"`
}

// OpenAPIRequestBody corpo da request
type OpenAPIRequestBody struct {
        Description string               `json:"description,omitempty"`
        Content     map[string]MediaType `json:"content"`
        Required    bool                 `json:"required,omitempty"`
}

// OpenAPIResponse operation response
type OpenAPIResponse struct {
        Description string               `json:"description"`
        Headers     map[string]Header    `json:"headers,omitempty"`
        Content     map[string]MediaType `json:"content,omitempty"`
        Links       map[string]Link      `json:"links,omitempty"`
}

// MediaType media type
type MediaType struct {
        Schema   *OpenAPISchema      `json:"schema,omitempty"`
        Example  interface{}         `json:"example,omitempty"`
        Examples map[string]Example  `json:"examples,omitempty"`
        Encoding map[string]Encoding `json:"encoding,omitempty"`
}

// OpenAPISchema data schema
type OpenAPISchema struct {
        Type                 string                    `json:"type,omitempty"`
        AllOf                []*OpenAPISchema          `json:"allOf,omitempty"`
        OneOf                []*OpenAPISchema          `json:"oneOf,omitempty"`
        AnyOf                []*OpenAPISchema          `json:"anyOf,omitempty"`
        Not                  *OpenAPISchema            `json:"not,omitempty"`
        Items                *OpenAPISchema            `json:"items,omitempty"`
        Properties           map[string]*OpenAPISchema `json:"properties,omitempty"`
        AdditionalProperties interface{}               `json:"additionalProperties,omitempty"`
        Description          string                    `json:"description,omitempty"`
        Format               string                    `json:"format,omitempty"`
        Default              interface{}               `json:"default,omitempty"`
        Title                string                    `json:"title,omitempty"`
        MultipleOf           float64                   `json:"multipleOf,omitempty"`
        Maximum              float64                   `json:"maximum,omitempty"`
        ExclusiveMaximum     bool                      `json:"exclusiveMaximum,omitempty"`
        Minimum              float64                   `json:"minimum,omitempty"`
        ExclusiveMinimum     bool                      `json:"exclusiveMinimum,omitempty"`
        MaxLength            int                       `json:"maxLength,omitempty"`
        MinLength            int                       `json:"minLength,omitempty"`
        Pattern              string                    `json:"pattern,omitempty"`
        MaxItems             int                       `json:"maxItems,omitempty"`
        MinItems             int                       `json:"minItems,omitempty"`
        UniqueItems          bool                      `json:"uniqueItems,omitempty"`
        MaxProperties        int                       `json:"maxProperties,omitempty"`
        MinProperties        int                       `json:"minProperties,omitempty"`
        Required             []string                  `json:"required,omitempty"`
        Enum                 []interface{}             `json:"enum,omitempty"`
        Example              interface{}               `json:"example,omitempty"`
        Nullable             bool                      `json:"nullable,omitempty"`
        ReadOnly             bool                      `json:"readOnly,omitempty"`
        WriteOnly            bool                      `json:"writeOnly,omitempty"`
        XML                  *XML                      `json:"xml,omitempty"`
        ExternalDocs         *ExternalDocs             `json:"externalDocs,omitempty"`
        Deprecated           bool                      `json:"deprecated,omitempty"`
        Discriminator        *Discriminator            `json:"discriminator,omitempty"`
        Ref                  string                    `json:"$ref,omitempty"`
}

// OpenAPIComponents reusable components
type OpenAPIComponents struct {
        Schemas         map[string]*OpenAPISchema     `json:"schemas,omitempty"`
        Responses       map[string]OpenAPIResponse    `json:"responses,omitempty"`
        Parameters      map[string]OpenAPIParameter   `json:"parameters,omitempty"`
        Examples        map[string]Example            `json:"examples,omitempty"`
        RequestBodies   map[string]OpenAPIRequestBody `json:"requestBodies,omitempty"`
        Headers         map[string]Header             `json:"headers,omitempty"`
        SecuritySchemes map[string]SecurityScheme     `json:"securitySchemes,omitempty"`
        Links           map[string]Link               `json:"links,omitempty"`
        Callbacks       map[string]interface{}        `json:"callbacks,omitempty"`
}

// SecurityRequirement security requirement
type SecurityRequirement map[string][]string

// SecurityScheme security scheme
type SecurityScheme struct {
        Type             string      `json:"type"`
        Description      string      `json:"description,omitempty"`
        Name             string      `json:"name,omitempty"`
        In               string      `json:"in,omitempty"`
        Scheme           string      `json:"scheme,omitempty"`
        BearerFormat     string      `json:"bearerFormat,omitempty"`
        Flows            *OAuthFlows `json:"flows,omitempty"`
        OpenIDConnectURL string      `json:"openIdConnectUrl,omitempty"`
}

// OAuthFlows fluxos OAuth2
type OAuthFlows struct {
        Implicit          *OAuthFlow `json:"implicit,omitempty"`
        Password          *OAuthFlow `json:"password,omitempty"`
        ClientCredentials *OAuthFlow `json:"clientCredentials,omitempty"`
        AuthorizationCode *OAuthFlow `json:"authorizationCode,omitempty"`
}

// OAuthFlow fluxo OAuth2
type OAuthFlow struct {
        AuthorizationURL string            `json:"authorizationUrl,omitempty"`
        TokenURL         string            `json:"tokenUrl,omitempty"`
        RefreshURL       string            `json:"refreshUrl,omitempty"`
        Scopes           map[string]string `json:"scopes"`
}

// OpenAPITag tag for grouping
type OpenAPITag struct {
        Name         string        `json:"name"`
        Description  string        `json:"description,omitempty"`
        ExternalDocs *ExternalDocs `json:"externalDocs,omitempty"`
}

// ExternalDocs external documentation
type ExternalDocs struct {
        Description string `json:"description,omitempty"`
        URL         string `json:"url"`
}

// Example exemplo
type Example struct {
        Summary       string      `json:"summary,omitempty"`
        Description   string      `json:"description,omitempty"`
        Value         interface{} `json:"value,omitempty"`
        ExternalValue string      `json:"externalValue,omitempty"`
}

// Header header
type Header struct {
        Description     string               `json:"description,omitempty"`
        Required        bool                 `json:"required,omitempty"`
        Deprecated      bool                 `json:"deprecated,omitempty"`
        AllowEmptyValue bool                 `json:"allowEmptyValue,omitempty"`
        Style           string               `json:"style,omitempty"`
        Explode         bool                 `json:"explode,omitempty"`
        AllowReserved   bool                 `json:"allowReserved,omitempty"`
        Schema          *OpenAPISchema       `json:"schema,omitempty"`
        Example         interface{}          `json:"example,omitempty"`
        Examples        map[string]Example   `json:"examples,omitempty"`
        Content         map[string]MediaType `json:"content,omitempty"`
}

// Link link to other operations
type Link struct {
        OperationRef string                 `json:"operationRef,omitempty"`
        OperationID  string                 `json:"operationId,omitempty"`
        Parameters   map[string]interface{} `json:"parameters,omitempty"`
        RequestBody  interface{}            `json:"requestBody,omitempty"`
        Description  string                 `json:"description,omitempty"`
        Server       *OpenAPIServer         `json:"server,omitempty"`
}

// Encoding encoding
type Encoding struct {
        ContentType   string            `json:"contentType,omitempty"`
        Headers       map[string]Header `json:"headers,omitempty"`
        Style         string            `json:"style,omitempty"`
        Explode       bool              `json:"explode,omitempty"`
        AllowReserved bool              `json:"allowReserved,omitempty"`
}

// XML metadata
type XML struct {
        Name      string `json:"name,omitempty"`
        Namespace string `json:"namespace,omitempty"`
        Prefix    string `json:"prefix,omitempty"`
        Attribute bool   `json:"attribute,omitempty"`
        Wrapped   bool   `json:"wrapped,omitempty"`
}

// Discriminator discriminator for polymorphism
type Discriminator struct {
        PropertyName string            `json:"propertyName"`
        Mapping      map[string]string `json:"mapping,omitempty"`
}

// GenerateOpenAPISpec generates complete OpenAPI 3.0 specification
func GenerateOpenAPISpec(config *Config) *OpenAPISpec <span class="cov8" title="22">{
        routes := GetRoutes()
        groups := GetGroups()

        spec := createBaseSpec(config)
        configureSpecInfo(spec, config)
        configureSpecServers(spec, config)
        configureSpecSecurity(spec, config)
        configureSpecComponents(spec)
        configureSpecTags(spec, groups)
        configureSpecPaths(spec, routes)

        return spec
}</span>

func createBaseSpec(config *Config) *OpenAPISpec <span class="cov8" title="22">{
        info := getSpecInfo(config)

        return &amp;OpenAPISpec{
                OpenAPI: "3.0.0",
                Info:    info,
                Paths:   make(map[string]OpenAPIPath),
                Components: &amp;OpenAPIComponents{
                        Schemas:         make(map[string]*OpenAPISchema),
                        Responses:       make(map[string]OpenAPIResponse),
                        Parameters:      make(map[string]OpenAPIParameter),
                        SecuritySchemes: make(map[string]SecurityScheme),
                },
                Tags: make([]OpenAPITag, 0),
        }
}</span>

func getSpecInfo(config *Config) OpenAPIInfo <span class="cov8" title="22">{
        title := "gin-decorators API"
        description := "API generated by gin-decorators framework"
        version := "1.0.0"

        if config != nil </span><span class="cov8" title="21">{
                if config.OpenAPI.Title != "" </span><span class="cov7" title="20">{
                        title = config.OpenAPI.Title
                }</span>
                <span class="cov8" title="21">if config.OpenAPI.Description != "" </span><span class="cov5" title="8">{
                        description = config.OpenAPI.Description
                }</span>
                <span class="cov8" title="21">if config.OpenAPI.Version != "" </span><span class="cov7" title="20">{
                        version = config.OpenAPI.Version
                }</span>
        }

        <span class="cov8" title="22">return OpenAPIInfo{
                Title:       title,
                Description: description,
                Version:     version,
        }</span>
}

func configureSpecInfo(spec *OpenAPISpec, config *Config) <span class="cov8" title="22">{
        if config == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov8" title="21">configureContact(spec, config)
        configureLicense(spec, config)</span>
}

func configureContact(spec *OpenAPISpec, config *Config) <span class="cov8" title="21">{
        if len(config.OpenAPI.Contact) == 0 </span><span class="cov8" title="21">{
                return
        }</span>

        <span class="cov0" title="0">contact := config.OpenAPI.Contact
        spec.Info.Contact = &amp;Contact{}

        if name, ok := contact["name"].(string); ok </span><span class="cov0" title="0">{
                spec.Info.Contact.Name = name
        }</span>
        <span class="cov0" title="0">if url, ok := contact["url"].(string); ok </span><span class="cov0" title="0">{
                spec.Info.Contact.URL = url
        }</span>
        <span class="cov0" title="0">if email, ok := contact["email"].(string); ok </span><span class="cov0" title="0">{
                spec.Info.Contact.Email = email
        }</span>
}

func configureLicense(spec *OpenAPISpec, config *Config) <span class="cov8" title="21">{
        if len(config.OpenAPI.License) == 0 </span><span class="cov8" title="21">{
                return
        }</span>

        <span class="cov0" title="0">license := config.OpenAPI.License
        spec.Info.License = &amp;License{}

        if name, ok := license["name"].(string); ok </span><span class="cov0" title="0">{
                spec.Info.License.Name = name
        }</span>
        <span class="cov0" title="0">if url, ok := license["url"].(string); ok </span><span class="cov0" title="0">{
                spec.Info.License.URL = url
        }</span>
}

func configureSpecServers(spec *OpenAPISpec, config *Config) <span class="cov8" title="22">{
        if config == nil || config.OpenAPI.Host == "" </span><span class="cov7" title="16">{
                return
        }</span>

        <span class="cov5" title="6">for _, scheme := range config.OpenAPI.Schemes </span><span class="cov6" title="11">{
                spec.Servers = append(spec.Servers, OpenAPIServer{
                        URL:         fmt.Sprintf("%s://%s%s", scheme, config.OpenAPI.Host, config.OpenAPI.BasePath),
                        Description: fmt.Sprintf("Server %s", strings.ToUpper(scheme)),
                })
        }</span>
}

func configureSpecSecurity(spec *OpenAPISpec, config *Config) <span class="cov8" title="22">{
        if config == nil || len(config.OpenAPI.Security) == 0 </span><span class="cov8" title="22">{
                return
        }</span>

        <span class="cov0" title="0">for _, secReq := range config.OpenAPI.Security </span><span class="cov0" title="0">{
                spec.Security = append(spec.Security, SecurityRequirement(secReq))
        }</span>
}

func configureSpecComponents(spec *OpenAPISpec) <span class="cov8" title="22">{
        addDefaultSecuritySchemes(spec.Components)
        addRegisteredSchemas(spec.Components)
}</span>

func configureSpecTags(spec *OpenAPISpec, groups map[string]*GroupInfo) <span class="cov8" title="22">{
        for _, group := range groups </span><span class="cov0" title="0">{
                spec.Tags = append(spec.Tags, OpenAPITag{
                        Name:        group.Name,
                        Description: group.Description,
                })
        }</span>
}

func configureSpecPaths(spec *OpenAPISpec, routes []RouteEntry) <span class="cov8" title="22">{
        for i := range routes </span><span class="cov5" title="8">{
                route := &amp;routes[i]
                path := route.Path

                if spec.Paths[path] == nil </span><span class="cov5" title="8">{
                        spec.Paths[path] = make(OpenAPIPath)
                }</span>

                <span class="cov5" title="8">operation := convertRouteToOperation(route, spec.Components)
                spec.Paths[path][strings.ToLower(route.Method)] = operation</span>
        }
}

// convertRouteToOperation converts RouteEntry to OpenAPIOperation
func convertRouteToOperation(route *RouteEntry, components *OpenAPIComponents) *OpenAPIOperation <span class="cov6" title="9">{
        operation := &amp;OpenAPIOperation{
                Summary:     route.Summary,
                Description: route.Description,
                OperationID: generateOperationID(route),
                Responses:   make(map[string]OpenAPIResponse),
                Extensions:  make(map[string]interface{}),
        }

        // Add tags
        if route.Group != nil </span><span class="cov0" title="0">{
                operation.Tags = append(operation.Tags, route.Group.Name)
        }</span>
        <span class="cov6" title="9">operation.Tags = append(operation.Tags, route.Tags...)

        // Separate body parameters from other parameters
        var bodyParams []ParameterInfo
        var otherParams []ParameterInfo

        for _, param := range route.Parameters </span><span class="cov6" title="11">{
                if param.Location == "body" </span><span class="cov5" title="7">{
                        bodyParams = append(bodyParams, param)
                }</span> else<span class="cov4" title="4"> {
                        otherParams = append(otherParams, param)
                }</span>
        }

        // Process non-body parameters
        <span class="cov6" title="9">for _, param := range otherParams </span><span class="cov4" title="4">{
                operation.Parameters = append(operation.Parameters, convertToOpenAPIParameter(&amp;param, components))
        }</span>

        // Process request body if there are body parameters
        <span class="cov6" title="9">if len(bodyParams) &gt; 0 </span><span class="cov3" title="3">{
                operation.RequestBody = createRequestBodyFromParameters(bodyParams, components)
        }</span>

        // Process responses with schema support
        <span class="cov6" title="9">if len(route.Responses) &gt; 0 </span><span class="cov5" title="6">{
                for _, response := range route.Responses </span><span class="cov6" title="12">{
                        apiResponse := createResponseWithSchemaAndType(response, components)
                        operation.Responses[response.Code] = apiResponse
                }</span>
        } else<span class="cov3" title="3"> {
                // Default response
                defaultResponse := ResponseInfo{
                        Code:        "200",
                        Description: "Success",
                        Type:        "",
                }
                operation.Responses["200"] = createResponseWithSchemaAndType(defaultResponse, components)
        }</span>

        // Add middleware information as extension
        <span class="cov6" title="9">if len(route.MiddlewareInfo) &gt; 0 </span><span class="cov0" title="0">{
                middlewares := make([]map[string]interface{}, 0)
                for _, mw := range route.MiddlewareInfo </span><span class="cov0" title="0">{
                        middlewares = append(middlewares, map[string]interface{}{
                                "name":        mw.Name,
                                "description": mw.Description,
                                "args":        mw.Args,
                        })
                }</span>
                <span class="cov0" title="0">operation.Extensions["x-middlewares"] = middlewares</span>
        }

        // Add rate limiting if present
        <span class="cov6" title="9">for _, mw := range route.MiddlewareInfo </span><span class="cov0" title="0">{
                if mw.Name == "RateLimit" </span><span class="cov0" title="0">{
                        operation.Extensions["x-rate-limit"] = mw.Args
                }</span>
        }

        <span class="cov6" title="9">return operation</span>
}

// createRequestBodyFromParameters creates an OpenAPIRequestBody from a slice of ParameterInfo
func createRequestBodyFromParameters(params []ParameterInfo, _ *OpenAPIComponents) *OpenAPIRequestBody <span class="cov4" title="4">{
        if len(params) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="4">requestBody := &amp;OpenAPIRequestBody{
                Content:  make(map[string]MediaType),
                Required: true,
        }

        // Check if any parameter references an existing schema
        for _, param := range params </span><span class="cov6" title="10">{
                schemaRef := findSchemaByName(param.Type)
                if schemaRef != nil </span><span class="cov0" title="0">{
                        // Reference existing schema
                        requestBody.Content["application/json"] = MediaType{
                                Schema: &amp;OpenAPISchema{
                                        Ref: fmt.Sprintf("#/components/schemas/%s", param.Type),
                                },
                        }
                        requestBody.Description = param.Description
                }</span> else<span class="cov6" title="10"> {
                        // Create inline schema
                        mediaType := MediaType{
                                Schema: convertTypeToSchema(param.Type),
                        }
                        if param.Example != "" </span><span class="cov0" title="0">{
                                mediaType.Example = param.Example
                        }</span>
                        <span class="cov6" title="10">requestBody.Content["application/json"] = mediaType</span>
                }
        }

        <span class="cov4" title="4">return requestBody</span>
}

// createResponseWithSchemaAndType creates an OpenAPIResponse using ResponseInfo
func createResponseWithSchemaAndType(responseInfo ResponseInfo, _ *OpenAPIComponents) OpenAPIResponse <span class="cov7" title="16">{
        response := OpenAPIResponse{
                Description: responseInfo.Description,
                Content:     make(map[string]MediaType),
        }

        // If a specific type is provided, use it
        if responseInfo.Type != "" </span><span class="cov6" title="13">{
                if schema := findSchemaByName(responseInfo.Type); schema != nil </span><span class="cov1" title="1">{
                        response.Content["application/json"] = MediaType{
                                Schema: &amp;OpenAPISchema{
                                        Ref: fmt.Sprintf("#/components/schemas/%s", responseInfo.Type),
                                },
                        }
                }</span> else<span class="cov6" title="12"> {
                        // If schema not found, create inline schema with the type
                        response.Content["application/json"] = MediaType{
                                Schema: convertTypeToSchema(responseInfo.Type),
                        }
                }</span>
        } else<span class="cov3" title="3"> {
                // Fall back to the old logic for automatic schema detection
                var schemaName string
                switch responseInfo.Code </span>{
                case "200", "201":<span class="cov3" title="3">
                        // Try to find common response schemas
                        if schema := findSchemaByPattern("Response"); schema != nil </span><span class="cov2" title="2">{
                                schemaName = schema.Name
                        }</span> else<span class="cov1" title="1"> if schema := findSchemaByPattern("UserResponse"); schema != nil </span><span class="cov0" title="0">{
                                schemaName = schema.Name
                        }</span>
                case "400", "401", "403", "404", "500":<span class="cov0" title="0">
                        // Try to find error response schema
                        if schema := findSchemaByPattern("ErrorResponse"); schema != nil </span><span class="cov0" title="0">{
                                schemaName = schema.Name
                        }</span> else<span class="cov0" title="0"> if schema := findSchemaByPattern("Error"); schema != nil </span><span class="cov0" title="0">{
                                schemaName = schema.Name
                        }</span>
                }

                <span class="cov3" title="3">if schemaName != "" </span><span class="cov2" title="2">{
                        response.Content["application/json"] = MediaType{
                                Schema: &amp;OpenAPISchema{
                                        Ref: fmt.Sprintf("#/components/schemas/%s", schemaName),
                                },
                        }
                }</span> else<span class="cov1" title="1"> {
                        // Create a generic response schema
                        response.Content["application/json"] = MediaType{
                                Schema: &amp;OpenAPISchema{
                                        Type: "object",
                                        Properties: map[string]*OpenAPISchema{
                                                "message": {Type: "string"},
                                                "data":    {Type: "object"},
                                        },
                                },
                        }
                }</span>
        }

        // Add example if provided
        <span class="cov7" title="16">if responseInfo.Example != "" </span><span class="cov0" title="0">{
                mediaType := response.Content["application/json"]
                mediaType.Example = responseInfo.Example
                response.Content["application/json"] = mediaType
        }</span>

        <span class="cov7" title="16">return response</span>
}

// findSchemaByName finds a registered schema by exact name
func findSchemaByName(name string) *SchemaInfo <span class="cov10" title="48">{
        schemas := GetSchemas()
        return schemas[name]
}</span>

// findSchemaByPattern finds a registered schema by name pattern
func findSchemaByPattern(pattern string) *SchemaInfo <span class="cov5" title="6">{
        schemas := GetSchemas()

        // First try exact match
        if schema, exists := schemas[pattern]; exists </span><span class="cov2" title="2">{
                return schema
        }</span>

        // Then try pattern match
        <span class="cov4" title="4">for name, schema := range schemas </span><span class="cov4" title="4">{
                if strings.Contains(name, pattern) </span><span class="cov2" title="2">{
                        return schema
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// convertToOpenAPIParameter converts ParameterInfo to OpenAPIParameter
func convertToOpenAPIParameter(param *ParameterInfo, _ *OpenAPIComponents) OpenAPIParameter <span class="cov4" title="5">{
        openAPIParam := OpenAPIParameter{
                Name:        param.Name,
                In:          param.Location,
                Description: param.Description,
                Required:    param.Required,
                Schema:      convertTypeToSchema(param.Type),
        }

        if param.Example != "" </span><span class="cov0" title="0">{
                openAPIParam.Example = param.Example
        }</span>

        <span class="cov4" title="5">return openAPIParam</span>
}

// convertTypeToSchema converts Go type to OpenAPI Schema
func convertTypeToSchema(goType string) *OpenAPISchema <span class="cov9" title="42">{
        schema := &amp;OpenAPISchema{}

        switch goType </span>{
        case "string":<span class="cov6" title="10">
                schema.Type = "string"</span>
        case "int", "int32", "int64":<span class="cov4" title="4">
                schema.Type = "integer"
                if goType == "int64" </span><span class="cov1" title="1">{
                        schema.Format = "int64"
                }</span> else<span class="cov3" title="3"> {
                        schema.Format = "int32"
                }</span>
        case "float32", "float64":<span class="cov1" title="1">
                schema.Type = "number"
                if goType == "float32" </span><span class="cov0" title="0">{
                        schema.Format = "float"
                }</span> else<span class="cov1" title="1"> {
                        schema.Format = "double"
                }</span>
        case "bool", "boolean":<span class="cov1" title="1">
                schema.Type = "boolean"</span>
        case "time.Time":<span class="cov1" title="1">
                schema.Type = "string"
                schema.Format = "date-time"</span>
        case "uuid.UUID":<span class="cov1" title="1">
                schema.Type = "string"
                schema.Format = "uuid"</span>
        case "[]string":<span class="cov1" title="1">
                schema.Type = "array"
                schema.Items = &amp;OpenAPISchema{Type: "string"}</span>
        case "[]int":<span class="cov0" title="0">
                schema.Type = "array"
                schema.Items = &amp;OpenAPISchema{Type: "integer", Format: "int32"}</span>
        default:<span class="cov8" title="23">
                // Complex or custom types
                if strings.HasPrefix(goType, "[]") </span><span class="cov1" title="1">{
                        schema.Type = "array"
                        itemType := strings.TrimPrefix(goType, "[]")

                        // Check if the array item type is a registered schema
                        if registeredSchema := findSchemaByName(itemType); registeredSchema != nil </span><span class="cov0" title="0">{
                                schema.Items = &amp;OpenAPISchema{
                                        Ref: fmt.Sprintf("#/components/schemas/%s", itemType),
                                }
                        }</span> else<span class="cov1" title="1"> {
                                schema.Items = convertTypeToSchema(itemType)
                        }</span>
                } else<span class="cov8" title="22"> {
                        // Check if this is a registered schema
                        if registeredSchema := findSchemaByName(goType); registeredSchema != nil </span><span class="cov0" title="0">{
                                schema.Ref = fmt.Sprintf("#/components/schemas/%s", goType)
                        }</span> else<span class="cov8" title="22"> {
                                schema.Type = "object"
                        }</span>
                }
        }

        <span class="cov9" title="42">return schema</span>
}

// generateOperationID generates unique ID for the operation
func generateOperationID(route *RouteEntry) string <span class="cov7" title="15">{
        // Clean characters especiais do path
        cleanPath := regexp.MustCompile(`[^a-zA-Z0-9]+`).ReplaceAllString(route.Path, "")

        // Use cases.Title instead of deprecated strings.Title
        caser := cases.Title(language.English)
        operationID := strings.ToLower(route.Method) + caser.String(cleanPath)

        if route.FuncName != "" </span><span class="cov5" title="8">{
                operationID = route.FuncName
        }</span>

        <span class="cov7" title="15">return operationID</span>
}

// addDefaultSecuritySchemes adds default security schemes
func addDefaultSecuritySchemes(components *OpenAPIComponents) <span class="cov8" title="23">{
        components.SecuritySchemes["BearerAuth"] = SecurityScheme{
                Type:         "http",
                Scheme:       "bearer",
                BearerFormat: "JWT",
                Description:  "Authentication via Bearer Token (JWT)",
        }

        components.SecuritySchemes["ApiKeyAuth"] = SecurityScheme{
                Type:        "apiKey",
                In:          "header",
                Name:        "X-API-Key",
                Description: "Authentication via API Key in header",
        }

        components.SecuritySchemes["BasicAuth"] = SecurityScheme{
                Type:        "http",
                Scheme:      "basic",
                Description: "HTTP Basic Authentication",
        }

        components.SecuritySchemes["OAuth2"] = SecurityScheme{
                Type:        "oauth2",
                Description: "OAuth 2.0",
                Flows: &amp;OAuthFlows{
                        AuthorizationCode: &amp;OAuthFlow{
                                AuthorizationURL: "/oauth/authorize",
                                TokenURL:         "/oauth/token",
                                Scopes: map[string]string{
                                        "read":  "Read permission",
                                        "write": "Write permission",
                                        "admin": "Administrative permissions",
                                },
                        },
                },
        }
}</span>

// addRegisteredSchemas adds schemas registered via RegisterSchema to OpenAPI components
func addRegisteredSchemas(components *OpenAPIComponents) <span class="cov8" title="22">{
        // First resolve schema references now that all schemas are registered
        resolveSchemaReferences()

        registeredSchemas := GetSchemas()

        for _, schemaInfo := range registeredSchemas </span><span class="cov9" title="34">{
                openAPISchema := convertSchemaInfoToOpenAPISchema(schemaInfo)
                components.Schemas[schemaInfo.Name] = openAPISchema
                LogVerbose("Added schema to OpenAPI spec: %s", schemaInfo.Name)
        }</span>
}

// convertSchemaInfoToOpenAPISchema converts SchemaInfo to OpenAPISchema
func convertSchemaInfoToOpenAPISchema(schemaInfo *SchemaInfo) *OpenAPISchema <span class="cov9" title="35">{
        schema := &amp;OpenAPISchema{
                Type:        schemaInfo.Type,
                Description: schemaInfo.Description,
                Properties:  make(map[string]*OpenAPISchema),
                Required:    schemaInfo.Required,
        }

        // Add example if provided
        if schemaInfo.Example != nil </span><span class="cov0" title="0">{
                schema.Example = schemaInfo.Example
        }</span>

        // Convert properties
        <span class="cov9" title="35">for propName, propInfo := range schemaInfo.Properties </span><span class="cov3" title="3">{
                propSchema := &amp;OpenAPISchema{
                        Type:        propInfo.Type,
                        Description: propInfo.Description,
                }

                // Handle schema reference
                if propInfo.Ref != "" </span><span class="cov0" title="0">{
                        propSchema = &amp;OpenAPISchema{
                                Ref: propInfo.Ref,
                        }
                }</span> else<span class="cov3" title="3"> {
                        // Set format if available
                        if propInfo.Format != "" </span><span class="cov1" title="1">{
                                propSchema.Format = propInfo.Format
                        }</span>

                        // Set example if available
                        <span class="cov3" title="3">if propInfo.Example != nil </span><span class="cov0" title="0">{
                                propSchema.Example = propInfo.Example
                        }</span>

                        // Handle array items
                        <span class="cov3" title="3">if propInfo.Items != nil </span><span class="cov0" title="0">{
                                if propInfo.Items.Ref != "" </span><span class="cov0" title="0">{
                                        propSchema.Items = &amp;OpenAPISchema{
                                                Ref: propInfo.Items.Ref,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        propSchema.Items = &amp;OpenAPISchema{
                                                Type:   propInfo.Items.Type,
                                                Format: propInfo.Items.Format,
                                        }
                                }</span>
                        }

                        // Set validation constraints
                        <span class="cov3" title="3">if propInfo.MinLength != nil </span><span class="cov0" title="0">{
                                propSchema.MinLength = *propInfo.MinLength
                        }</span>
                        <span class="cov3" title="3">if propInfo.MaxLength != nil </span><span class="cov0" title="0">{
                                propSchema.MaxLength = *propInfo.MaxLength
                        }</span>
                        <span class="cov3" title="3">if propInfo.Minimum != nil </span><span class="cov0" title="0">{
                                propSchema.Minimum = *propInfo.Minimum
                        }</span>
                        <span class="cov3" title="3">if propInfo.Maximum != nil </span><span class="cov0" title="0">{
                                propSchema.Maximum = *propInfo.Maximum
                        }</span>
                        <span class="cov3" title="3">if len(propInfo.Enum) &gt; 0 </span><span class="cov0" title="0">{
                                for _, enumVal := range propInfo.Enum </span><span class="cov0" title="0">{
                                        propSchema.Enum = append(propSchema.Enum, enumVal)
                                }</span>
                        }
                }

                <span class="cov3" title="3">schema.Properties[propName] = propSchema</span>
        }

        <span class="cov9" title="35">return schema</span>
}

// OpenAPIJSONHandler serves OpenAPI 3.0 documentation in JSON
func OpenAPIJSONHandler(config *Config) gin.HandlerFunc <span class="cov5" title="7">{
        return func(c *gin.Context) </span><span class="cov4" title="5">{
                spec := GenerateOpenAPISpec(config)
                c.JSON(http.StatusOK, spec)
        }</span>
}

// OpenAPIYAMLHandler serves OpenAPI 3.0 documentation in YAML
func OpenAPIYAMLHandler(config *Config) gin.HandlerFunc <span class="cov4" title="5">{
        return func(c *gin.Context) </span><span class="cov3" title="3">{
                spec := GenerateOpenAPISpec(config)
                c.YAML(http.StatusOK, spec)
        }</span>
}

// SwaggerUIHandler creates Swagger UI handler with customizable settings via config
func SwaggerUIHandler(_ *Config) gin.HandlerFunc <span class="cov4" title="5">{
        return func(c *gin.Context) </span><span class="cov3" title="3">{
                // Use config to customize Swagger UI settings
                swaggerURL := "/decorators/openapi.json"
                // Don't add BasePath for internal endpoints

                // Customize Swagger UI HTML based on config
                htmlTemplate := `
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;API Documentation&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="swagger-ui"&gt;&lt;/div&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-bundle.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@4.15.5/swagger-ui-standalone-preset.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        window.onload = function() {
            const ui = SwaggerUIBundle({
                url: '{{SWAGGER_URL}}',
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout",
                validatorUrl: null,
                docExpansion: "list",
                filter: true,
                showRequestHeaders: true,
                tryItOutEnabled: true,
                requestInterceptor: function(request) {
                    // Add custom headers if needed
                    return request;
                }
            });
        };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`

                // Replace placeholder with actual URL
                html := strings.Replace(htmlTemplate, "{{SWAGGER_URL}}", swaggerURL, 1)

                c.Header("Content-Type", "text/html; charset=utf-8")
                c.String(http.StatusOK, html)
        }</span>
}

// SwaggerRedirectHandler redirects to swagger UI (convenience endpoint)
func SwaggerRedirectHandler(c *gin.Context) <span class="cov1" title="1">{
        c.Redirect(http.StatusMovedPermanently, "/decorators/swagger-ui")
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package decorators

import (
        "fmt"
        "go/ast"
        "go/parser"
        "go/token"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/gin-gonic/gin"
)

var (
        // Regex to extract route: @Route("METHOD", "path")
        routeRegex = regexp.MustCompile(`@Route\s*\(\s*"([^"]+)"\s*,\s*"([^"]+)"\s*\)`)
)

// ParseDirectory analyzes a directory and extracts route metadata
func ParseDirectory(rootDir string) ([]*RouteMeta, error) <span class="cov0" title="0">{
        var routes []*RouteMeta
        var parseErrors []ValidationError

        // Parse directory
        fset := token.NewFileSet()
        pkgs, err := parser.ParseDir(fset, rootDir, nil, parser.ParseComments)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing do directory %s: %v", rootDir, err)
        }</span>

        // Process each package
        <span class="cov0" title="0">for pkgName, pkg := range pkgs </span><span class="cov0" title="0">{
                // Process each file in package
                for fileName, file := range pkg.Files </span><span class="cov0" title="0">{
                        fileRoutes, errs := parseFileWithValidation(fset, fileName, file, pkgName)

                        routes = append(routes, fileRoutes...)
                        parseErrors = append(parseErrors, errs...)
                }</span>
        }

        // Report any parsing errors found
        <span class="cov0" title="0">if len(parseErrors) &gt; 0 </span><span class="cov0" title="0">{
                return routes, &amp;MultipleValidationError{Errors: parseErrors}
        }</span>

        // Process middlewares for each route
        <span class="cov0" title="0">for _, route := range routes </span><span class="cov0" title="0">{
                if err := processMiddlewares(route); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error processing middlewares para %s: %v", route.FuncName, err)
                }</span>
        }

        <span class="cov0" title="0">return routes, nil</span>
}

// parseFileWithValidation analyzes a specific file and validates decorators
func parseFileWithValidation(fset *token.FileSet, fileName string, file *ast.File, pkgName string) ([]*RouteMeta, []ValidationError) <span class="cov0" title="0">{
        var routes []*RouteMeta
        var parseErrors []ValidationError

        // Process each declaration in the file
        for _, decl := range file.Decls </span><span class="cov0" title="0">{
                // Look for functions
                if funcDecl, ok := decl.(*ast.FuncDecl); ok </span><span class="cov0" title="0">{
                        route, err := parseFunctionWithValidation(fset, fileName, funcDecl, pkgName)
                        if route != nil </span><span class="cov0" title="0">{
                                routes = append(routes, route)
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                parseErrors = append(parseErrors, *err)
                        }</span>
                }

                // Look for structs with @Schema annotations
                <span class="cov0" title="0">if genDecl, ok := decl.(*ast.GenDecl); ok </span><span class="cov0" title="0">{
                        entity := parseEntityFromStruct(fset, fileName, genDecl, pkgName)
                        if entity != nil </span><span class="cov0" title="0">{
                                // Convert entity to schema and register it
                                schema := convertEntityToSchema(entity)
                                RegisterSchema(schema)
                                LogVerbose("Schema detected and registered: %s", schema.Name)
                        }</span>
                }
        }

        <span class="cov0" title="0">return routes, parseErrors</span>
}

// parseFunctionWithValidation analyzes a function and extracts metadata with validation
func parseFunctionWithValidation(fset *token.FileSet, fileName string, funcDecl *ast.FuncDecl, pkgName string) (*RouteMeta, *ValidationError) <span class="cov0" title="0">{
        // Check if it has comments
        if funcDecl.Doc == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Join all comments
        <span class="cov0" title="0">comments := make([]string, 0, len(funcDecl.Doc.List))
        for _, comment := range funcDecl.Doc.List </span><span class="cov0" title="0">{
                comments = append(comments, comment.Text)
        }</span>
        <span class="cov0" title="0">commentText := strings.Join(comments, "\n")

        // Check if has any decorator annotations
        if !hasDecoratorAnnotations(commentText) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Validate decorator syntax first
        <span class="cov0" title="0">if err := validateDecoratorSyntax(fset, fileName, funcDecl, commentText); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Extract all markers with validation first
        <span class="cov0" title="0">markers, err := extractMarkersWithValidation(fset, fileName, funcDecl, commentText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Look for @Route
        <span class="cov0" title="0">routeMatches := routeRegex.FindStringSubmatch(commentText)

        if len(routeMatches) != 3 </span><span class="cov0" title="0">{
                if strings.Contains(commentText, "@Route") </span><span class="cov0" title="0">{
                        pos := fset.Position(funcDecl.Pos())
                        return nil, &amp;ValidationError{
                                File:    filepath.Base(fileName),
                                Line:    pos.Line,
                                Message: fmt.Sprintf("Invalid @Route syntax in function %s. Use: @Route(\"METHOD\", \"/path\")", funcDecl.Name.Name),
                                Code:    "INVALID_ROUTE_SYNTAX",
                        }
                }</span>

                // Markers already extracted above

                // Check if it's a WebSocket handler without route
                <span class="cov0" title="0">hasWebSocketWithArgs := false
                for _, marker := range markers </span><span class="cov0" title="0">{
                        if marker.Name == "WebSocket" &amp;&amp; len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                                hasWebSocketWithArgs = true
                                break</span>
                        }
                }

                // If it has @WebSocket with args but no @Route, create a WebSocket-only meta
                <span class="cov0" title="0">if hasWebSocketWithArgs </span><span class="cov0" title="0">{
                        route := &amp;RouteMeta{
                                Method:      "", // No HTTP method for pure WebSocket handlers
                                Path:        "", // No HTTP path for pure WebSocket handlers
                                FuncName:    funcDecl.Name.Name,
                                PackageName: pkgName,
                                FileName:    filepath.Base(fileName),
                                Markers:     markers,
                        }
                        return route, nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span> // Not a handler
        }

        <span class="cov0" title="0">method := routeMatches[1]
        path := routeMatches[2]
        funcName := funcDecl.Name.Name

        // Validate method
        validMethods := []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"}
        if !contains(validMethods, method) </span><span class="cov0" title="0">{
                pos := fset.Position(funcDecl.Pos())
                return nil, &amp;ValidationError{
                        File:    filepath.Base(fileName),
                        Line:    pos.Line,
                        Message: fmt.Sprintf("Invalid HTTP method '%s' in function %s. Valid methods: %v", method, funcName, validMethods),
                        Code:    "INVALID_HTTP_METHOD",
                }
        }</span>

        // Validate path
        <span class="cov0" title="0">if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                pos := fset.Position(funcDecl.Pos())
                return nil, &amp;ValidationError{
                        File:    filepath.Base(fileName),
                        Line:    pos.Line,
                        Message: fmt.Sprintf("Invalid path '%s' in function %s. Path must start with '/'", path, funcName),
                        Code:    "INVALID_PATH",
                }
        }</span>

        // Markers already extracted above

        <span class="cov0" title="0">route := &amp;RouteMeta{
                Method:      method,
                Path:        path,
                FuncName:    funcName,
                PackageName: pkgName,
                FileName:    filepath.Base(fileName),
                Markers:     markers,
        }

        return route, nil</span>
}

// hasDecoratorAnnotations checks if comment text contains any decorator annotations
func hasDecoratorAnnotations(commentText string) bool <span class="cov3" title="2">{
        decorators := []string{"@Route", "@Middleware", "@Response", "@RequestBody", "@Schema", "@Summary", "@Description", "@Tag", "@Validate", "@WebSocket", "@WebSocketStats"}
        for _, decorator := range decorators </span><span class="cov10" title="12">{
                if strings.Contains(commentText, decorator) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// validateDecoratorSyntax validates the overall syntax of decorators in comments
func validateDecoratorSyntax(fset *token.FileSet, fileName string, funcDecl *ast.FuncDecl, commentText string) *ValidationError <span class="cov0" title="0">{
        pos := fset.Position(funcDecl.Pos())

        // Check for common syntax errors
        lines := strings.Split(commentText, "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "//") </span><span class="cov0" title="0">{
                        trimmed = strings.TrimSpace(trimmed[2:])
                }</span>

                // Check for malformed decorators
                <span class="cov0" title="0">if strings.HasPrefix(trimmed, "@") </span><span class="cov0" title="0">{
                        // Check for missing parentheses in decorators that require them
                        if (strings.Contains(trimmed, "@Route") || strings.Contains(trimmed, "@Response") ||
                                strings.Contains(trimmed, "@RequestBody") || strings.Contains(trimmed, "@Middleware")) &amp;&amp;
                                !strings.Contains(trimmed, "(") </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        File:    filepath.Base(fileName),
                                        Line:    pos.Line + i,
                                        Message: fmt.Sprintf("Malformed decorator: '%s'. Missing parentheses", trimmed),
                                        Code:    "MALFORMED_DECORATOR",
                                }
                        }</span>

                        // Check for unmatched quotes
                        <span class="cov0" title="0">quoteCount := strings.Count(trimmed, "\"")
                        if quoteCount%2 != 0 </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        File:    filepath.Base(fileName),
                                        Line:    pos.Line + i,
                                        Message: fmt.Sprintf("Unmatched quotes in: '%s'", trimmed),
                                        Code:    "UNMATCHED_QUOTES",
                                }
                        }</span>

                        // Check for unmatched parentheses
                        <span class="cov0" title="0">openParen := strings.Count(trimmed, "(")
                        closeParen := strings.Count(trimmed, ")")
                        if openParen != closeParen </span><span class="cov0" title="0">{
                                return &amp;ValidationError{
                                        File:    filepath.Base(fileName),
                                        Line:    pos.Line + i,
                                        Message: fmt.Sprintf("Unmatched parentheses in: '%s'", trimmed),
                                        Code:    "UNMATCHED_PARENTHESES",
                                }
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// extractMarkersWithValidation extracts all markers from a comment with validation
func extractMarkersWithValidation(fset *token.FileSet, fileName string, funcDecl *ast.FuncDecl, commentText string) ([]MarkerInstance, *ValidationError) <span class="cov0" title="0">{
        var markers []MarkerInstance
        pos := fset.Position(funcDecl.Pos())

        // Look for each registered marker
        for name, config := range GetMarkers() </span><span class="cov0" title="0">{
                matches := config.Pattern.FindAllStringSubmatch(commentText, -1)
                for _, match := range matches </span><span class="cov0" title="0">{
                        marker := MarkerInstance{
                                Name: name,
                                Raw:  match[0],
                        }

                        // Extract arguments if they exist
                        if len(match) &gt; 1 &amp;&amp; match[1] != "" </span><span class="cov0" title="0">{
                                args, err := parseArgumentsWithValidation(match[1], name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, &amp;ValidationError{
                                                File:    filepath.Base(fileName),
                                                Line:    pos.Line,
                                                Message: fmt.Sprintf("Error in @%s decorator arguments: %s", name, err.Error()),
                                                Code:    "INVALID_ARGUMENTS",
                                        }
                                }</span>
                                <span class="cov0" title="0">marker.Args = args</span>
                        }

                        <span class="cov0" title="0">markers = append(markers, marker)</span>
                }
        }

        <span class="cov0" title="0">return markers, nil</span>
}

// parseArgumentsWithValidation converts argument string to slice with validation
func parseArgumentsWithValidation(argsStr, decoratorName string) ([]string, error) <span class="cov0" title="0">{
        if argsStr == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var args []string
        parts := strings.Split(argsStr, ",")
        for _, part := range parts </span><span class="cov0" title="0">{
                arg := strings.TrimSpace(part)
                if arg != "" </span><span class="cov0" title="0">{
                        // Remove quotes if present
                        if (strings.HasPrefix(arg, "\"") &amp;&amp; strings.HasSuffix(arg, "\"")) ||
                                (strings.HasPrefix(arg, "'") &amp;&amp; strings.HasSuffix(arg, "'")) </span><span class="cov0" title="0">{
                                arg = arg[1 : len(arg)-1]
                        }</span>

                        // Validate argument is not empty after processing
                        <span class="cov0" title="0">if arg == "" </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("empty argument found")
                        }</span>

                        <span class="cov0" title="0">args = append(args, arg)</span>
                }
        }

        // Validate argument count for specific decorators
        <span class="cov0" title="0">if err := validateArgumentCount(decoratorName, args); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return args, nil</span>
}

// validateArgumentCount validates the number of arguments for specific decorators
func validateArgumentCount(decoratorName string, args []string) error <span class="cov0" title="0">{
        switch decoratorName </span>{
        case "Route":<span class="cov0" title="0">
                if len(args) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("@Route requires exactly 2 arguments (method, path), found %d", len(args))
                }</span>
        case "Response":<span class="cov0" title="0">
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("@Response requires at least 1 argument (status code)")
                }</span>
        case "RequestBody":<span class="cov0" title="0">
                if len(args) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("@RequestBody requires at least 1 argument (type)")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// contains checks if slice contains string
func contains(slice []string, item string) bool <span class="cov4" title="3">{
        for _, s := range slice </span><span class="cov7" title="6">{
                if s == item </span><span class="cov3" title="2">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// MultipleValidationError represents multiple validation errors
type MultipleValidationError struct {
        Errors []ValidationError
}

func (e *MultipleValidationError) Error() string <span class="cov0" title="0">{
        messages := make([]string, 0, len(e.Errors))
        for _, err := range e.Errors </span><span class="cov0" title="0">{
                messages = append(messages, err.Error())
        }</span>
        <span class="cov0" title="0">return strings.Join(messages, "\n")</span>
}

// parseArguments converts string of arguments to slice
func parseArguments(argsStr string) []string <span class="cov1" title="1">{
        if argsStr == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">var args []string
        parts := strings.Split(argsStr, ",")
        for _, part := range parts </span><span class="cov3" title="2">{
                arg := strings.TrimSpace(part)
                if arg != "" </span><span class="cov3" title="2">{
                        args = append(args, arg)
                }</span>
        }

        <span class="cov1" title="1">return args</span>
}

// processMiddlewares generates middleware calls for a route
func processMiddlewares(route *RouteMeta) error <span class="cov0" title="0">{
        var middlewareCalls []string
        var middlewareInfo []MiddlewareInfo
        var parameters []ParameterInfo
        var tags []string
        var responses []ResponseInfo
        var groupInfo *GroupInfo

        // Process each marker
        for _, marker := range route.Markers </span><span class="cov0" title="0">{
                processMarker(marker, route, &amp;middlewareCalls, &amp;middlewareInfo, &amp;parameters, &amp;tags, &amp;responses, &amp;groupInfo)
        }</span>

        <span class="cov0" title="0">route.MiddlewareCalls = middlewareCalls
        route.MiddlewareInfo = middlewareInfo
        route.Parameters = parameters
        route.Tags = tags
        route.Responses = responses
        route.Group = groupInfo

        return nil</span>
}

// processMarker processes a single marker to reduce complexity
func processMarker(marker MarkerInstance, route *RouteMeta, middlewareCalls *[]string, middlewareInfo *[]MiddlewareInfo, parameters *[]ParameterInfo, tags *[]string, responses *[]ResponseInfo, groupInfo **GroupInfo) <span class="cov0" title="0">{
        switch marker.Name </span>{
        case "Auth", "Cache", "RateLimit", "Metrics", "CORS", "WebSocketStats", "Proxy", "Security":<span class="cov0" title="0">
                processTraditionalMiddleware(marker, middlewareCalls, middlewareInfo)</span>
        case "WebSocket":<span class="cov0" title="0">
                processWebSocketMarker(marker, route, middlewareCalls, middlewareInfo)</span>
        case "Group":<span class="cov0" title="0">
                *groupInfo = processGroupMarker(marker)</span>
        case "Param":<span class="cov0" title="0">
                processParamMarker(marker, parameters)</span>
        case "Tag":<span class="cov0" title="0">
                processTagMarker(marker, tags)</span>
        case "Response":<span class="cov0" title="0">
                processResponseMarker(marker, responses)</span>
        case "Description":<span class="cov0" title="0">
                processDescriptionMarker(marker, route)</span>
        case "Summary":<span class="cov0" title="0">
                processSummaryMarker(marker, route)</span>
        }
}

// processTraditionalMiddleware processes traditional middleware markers
func processTraditionalMiddleware(marker MarkerInstance, middlewareCalls *[]string, middlewareInfo *[]MiddlewareInfo) <span class="cov0" title="0">{
        call := generateMiddlewareCall(marker)
        if call != "" </span><span class="cov0" title="0">{
                *middlewareCalls = append(*middlewareCalls, call)
                info := MiddlewareInfo{
                        Name:        marker.Name,
                        Args:        parseArgsToMap(marker.Args),
                        Description: getMiddlewareDescription(marker.Name),
                }
                *middlewareInfo = append(*middlewareInfo, info)
        }</span>
}

// processWebSocketMarker processes WebSocket marker
func processWebSocketMarker(marker MarkerInstance, route *RouteMeta, middlewareCalls *[]string, middlewareInfo *[]MiddlewareInfo) <span class="cov0" title="0">{
        // WebSocket can be both middleware and handler registration
        call := generateMiddlewareCall(marker)
        if call != "" </span><span class="cov0" title="0">{
                *middlewareCalls = append(*middlewareCalls, call)
                info := MiddlewareInfo{
                        Name:        marker.Name,
                        Args:        parseArgsToMap(marker.Args),
                        Description: getMiddlewareDescription(marker.Name),
                }
                *middlewareInfo = append(*middlewareInfo, info)
        }</span>

        // If has args, register as WebSocket handler
        <span class="cov0" title="0">if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                for _, arg := range marker.Args </span><span class="cov0" title="0">{
                        messageType := strings.Trim(arg, `"' `)
                        if messageType != "" </span><span class="cov0" title="0">{
                                route.WebSocketHandlers = append(route.WebSocketHandlers, messageType)
                        }</span>
                }
        }
}

// processGroupMarker processes group marker
func processGroupMarker(marker MarkerInstance) *GroupInfo <span class="cov0" title="0">{
        if len(marker.Args) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">groupName := strings.Trim(marker.Args[0], `"`)
        groupInfo := GetGroup(groupName)
        if groupInfo != nil </span><span class="cov0" title="0">{
                return groupInfo
        }</span>

        // Create group if it does not exist
        <span class="cov0" title="0">prefix := "/" + strings.ToLower(groupName)
        description := fmt.Sprintf("Grupo %s", groupName)

        if len(marker.Args) &gt; 1 </span><span class="cov0" title="0">{
                prefix = strings.Trim(marker.Args[1], `"`)
        }</span>
        <span class="cov0" title="0">if len(marker.Args) &gt; 2 </span><span class="cov0" title="0">{
                description = strings.Trim(marker.Args[2], `"`)
        }</span>

        <span class="cov0" title="0">return RegisterGroup(groupName, prefix, description)</span>
}

// processParamMarker processes parameter marker
func processParamMarker(marker MarkerInstance, parameters *[]ParameterInfo) <span class="cov0" title="0">{
        param := parseParameterInfo(marker.Args)
        if param.Name != "" </span><span class="cov0" title="0">{
                *parameters = append(*parameters, param)
        }</span>
}

// processTagMarker processes tag marker
func processTagMarker(marker MarkerInstance, tags *[]string) <span class="cov0" title="0">{
        if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                tag := strings.Trim(marker.Args[0], `"`)
                *tags = append(*tags, tag)
        }</span>
}

// processResponseMarker processes response marker
func processResponseMarker(marker MarkerInstance, responses *[]ResponseInfo) <span class="cov0" title="0">{
        response := parseResponseInfo(marker.Args)
        if response.Code != "" &amp;&amp; response.Description != "" </span><span class="cov0" title="0">{
                *responses = append(*responses, response)
        }</span>
}

// processDescriptionMarker processes description marker
func processDescriptionMarker(marker MarkerInstance, route *RouteMeta) <span class="cov0" title="0">{
        if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                route.Description = strings.Trim(marker.Args[0], `"`)
        }</span>
}

// processSummaryMarker processes summary marker
func processSummaryMarker(marker MarkerInstance, route *RouteMeta) <span class="cov0" title="0">{
        if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                route.Summary = strings.Trim(marker.Args[0], `"`)
        }</span>
}

// parseArgsToMap converts arguments to map[string]interface{}
func parseArgsToMap(args []string) map[string]interface{} <span class="cov1" title="1">{
        result := make(map[string]interface{})

        for _, arg := range args </span><span class="cov3" title="2">{
                if strings.Contains(arg, "=") </span><span class="cov3" title="2">{
                        parts := strings.SplitN(arg, "=", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"`)
                        result[key] = value
                }</span> else<span class="cov0" title="0"> {
                        // Argument without key, use as "value"
                        result["value"] = strings.Trim(arg, `"`)
                }</span>
        }

        <span class="cov1" title="1">return result</span>
}

// parseParameterInfo converts arguments to ParameterInfo
func parseParameterInfo(args []string) ParameterInfo <span class="cov1" title="1">{
        param := ParameterInfo{}

        for _, arg := range args </span><span class="cov4" title="3">{
                if strings.Contains(arg, "=") </span><span class="cov4" title="3">{
                        parts := strings.SplitN(arg, "=", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                        switch key </span>{
                        case "name":<span class="cov1" title="1">
                                param.Name = value</span>
                        case "type":<span class="cov1" title="1">
                                param.Type = value</span>
                        case "location":<span class="cov0" title="0">
                                param.Location = value</span>
                        case "required":<span class="cov1" title="1">
                                param.Required = value == "true"</span>
                        case "description":<span class="cov0" title="0">
                                param.Description = value</span>
                        case "example":<span class="cov0" title="0">
                                param.Example = value</span>
                        }
                }
        }

        <span class="cov1" title="1">return param</span>
}

// parseResponseInfo converts arguments to ResponseInfo
func parseResponseInfo(args []string) ResponseInfo <span class="cov1" title="1">{
        response := ResponseInfo{}

        for _, arg := range args </span><span class="cov3" title="2">{
                if strings.Contains(arg, "=") </span><span class="cov3" title="2">{
                        parts := strings.SplitN(arg, "=", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"`)

                        switch key </span>{
                        case "code":<span class="cov1" title="1">
                                response.Code = value</span>
                        case "description":<span class="cov0" title="0">
                                response.Description = value</span>
                        case "type":<span class="cov1" title="1">
                                response.Type = value</span>
                        case "example":<span class="cov0" title="0">
                                response.Example = value</span>
                        }
                }
        }

        <span class="cov1" title="1">return response</span>
}

// getMiddlewareDescription returns default description for middlewares
func getMiddlewareDescription(name string) string <span class="cov4" title="3">{
        descriptions := map[string]string{
                "Auth":           "Middleware de autenticação e autorização",
                "Cache":          "Middleware de cache de responses",
                "RateLimit":      "Middleware de limitação de taxa",
                "Metrics":        "Middleware de coleta de métricas",
                "CORS":           "Middleware de Cross-Origin Resource Sharing",
                "WebSocket":      "Middleware de upgrade para conexão WebSocket",
                "WebSocketStats": "Middleware de estatísticas WebSocket",
                "Proxy":          "Middleware de proxy reverso com service discovery e load balancing",
        }

        if desc, exists := descriptions[name]; exists </span><span class="cov4" title="3">{
                return desc
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Middleware %s", name)</span>
}

// generateMiddlewareCall generates Go call for a middleware
func generateMiddlewareCall(marker MarkerInstance) string <span class="cov1" title="1">{
        switch marker.Name </span>{
        case "Auth":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateAuthMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateAuthMiddleware("")`</span>

        case "Cache":<span class="cov1" title="1">
                if len(marker.Args) &gt; 0 </span><span class="cov1" title="1">{
                        return fmt.Sprintf(`deco.CreateCacheMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateCacheMiddleware("duration=5m")`</span>

        case "RateLimit":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateRateLimitMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateRateLimitMiddleware("limit=100,window=1m")`</span>

        case "Metrics":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateMetricsMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateMetricsMiddleware("")`</span>

        case "CORS":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateCORSMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateCORSMiddleware("")`</span>

        case "WebSocket":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateWebSocketMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateWebSocketMiddleware("")`</span>

        case "WebSocketStats":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateWebSocketStatsMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateWebSocketStatsMiddleware("")`</span>

        case "Proxy":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateProxyMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateProxyMiddleware("")`</span>

        case "Security":<span class="cov0" title="0">
                if len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf(`deco.CreateSecurityMiddleware(%q)`, strings.Join(marker.Args, ","))
                }</span>
                <span class="cov0" title="0">return `deco.CreateSecurityMiddleware("")`</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// CreateAuthMiddleware creates auth middleware (wrapper for generation)
func CreateAuthMiddleware(args string) func(c *gin.Context) <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["Auth"]
        return config.Factory(argsSlice)
}</span>

// CreateCacheMiddleware creates cache middleware (wrapper for generation)
func CreateCacheMiddleware(args string) func(c *gin.Context) <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["Cache"]
        return config.Factory(argsSlice)
}</span>

// CreateRateLimitMiddleware creates rate limit middleware (wrapper for generation)
func CreateRateLimitMiddleware(args string) func(c *gin.Context) <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["RateLimit"]
        return config.Factory(argsSlice)
}</span>

// CreateMetricsMiddleware creates metrics middleware (wrapper for generation)
func CreateMetricsMiddleware(args string) func(c *gin.Context) <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["Metrics"]
        return config.Factory(argsSlice)
}</span>

// CreateCORSMiddleware creates CORS middleware (wrapper for generation)
func CreateCORSMiddleware(args string) func(c *gin.Context) <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["CORS"]
        return config.Factory(argsSlice)
}</span>

// CreateWebSocketMiddleware creates WebSocket middleware (wrapper for generation)
func CreateWebSocketMiddleware(args string) gin.HandlerFunc <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["WebSocket"]
        return config.Factory(argsSlice)
}</span>

// CreateWebSocketStatsMiddleware creates WebSocket stats middleware (wrapper for generation)
func CreateWebSocketStatsMiddleware(args string) gin.HandlerFunc <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["WebSocketStats"]
        return config.Factory(argsSlice)
}</span>

// CreateProxyMiddleware creates proxy middleware (wrapper for generation)
func CreateProxyMiddleware(args string) gin.HandlerFunc <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["Proxy"]
        return config.Factory(argsSlice)
}</span>

// CreateSecurityMiddleware creates security middleware (wrapper for generation)
func CreateSecurityMiddleware(args string) gin.HandlerFunc <span class="cov0" title="0">{
        argsSlice := parseArguments(args)
        config := GetMarkers()["Security"]
        return config.Factory(argsSlice)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package decorators

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// RouteMeta represents metadata of a route extracted from comments
type RouteMeta struct {
        Method          string           // GET, POST, etc.
        Path            string           // /api/users
        FuncName        string           // GetUsers
        PackageName     string           // handlers
        FileName        string           // user_handlers.go
        Markers         []MarkerInstance // found marker instances
        MiddlewareCalls []string         // generated middleware calls

        // Documentation information
        Description       string           `json:"description"`
        Summary           string           `json:"summary"`
        Tags              []string         `json:"tags"`
        MiddlewareInfo    []MiddlewareInfo `json:"middlewareInfo"`
        Parameters        []ParameterInfo  `json:"parameters"`
        Group             *GroupInfo       `json:"group,omitempty"`
        Responses         []ResponseInfo   `json:"responses,omitempty"`         // Updated to use ResponseInfo
        WebSocketHandlers []string         `json:"websocketHandlers,omitempty"` // WebSocket message types this function handles
}

// MarkerInstance represents a marker instance found
type MarkerInstance struct {
        Name string   // Auth, Cache, etc.
        Args []string // parsed arguments
        Raw  string   // original comment text
}

// GenData data passed to generation template
type GenData struct {
        PackageName string                 // nome do pacote de destino
        Routes      []*RouteMeta           // routes to be generated
        Imports     []string               // necessary imports
        Metadata    map[string]interface{} // additional plugin data
        GeneratedAt string                 // generation timestamp
}

// Hooks for extensibility
type (
        // ParserHook executed after parsing routes
        ParserHook func(routes []*RouteMeta) error

        // GeneratorHook executed before code generation
        GeneratorHook func(data *GenData) error
)

// registries globais de hooks
var (
        parserHooks    []ParserHook
        generatorHooks []GeneratorHook
)

// RegisterParserHook registers a parsing hook
func RegisterParserHook(h ParserHook) <span class="cov9" title="8">{
        parserHooks = append(parserHooks, h)
        LogVerbose("Parser hook registrado")
}</span>

// RegisterGeneratorHook registers a generation hook
func RegisterGeneratorHook(h GeneratorHook) <span class="cov9" title="8">{
        generatorHooks = append(generatorHooks, h)
        LogVerbose("Generator hook registrado")
}</span>

// executeParserHooks executes all parsing hooks
func executeParserHooks(routes []*RouteMeta) error <span class="cov6" title="4">{
        for i, hook := range parserHooks </span><span class="cov7" title="5">{
                if err := hook(routes); err != nil </span><span class="cov3" title="2">{
                        return err
                }</span>
                <span class="cov5" title="3">LogVerbose("Parser hook %d executed successfully", i+1)</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// executeGeneratorHooks executes all generation hooks
func executeGeneratorHooks(data *GenData) error <span class="cov6" title="4">{
        for i, hook := range generatorHooks </span><span class="cov7" title="5">{
                if err := hook(data); err != nil </span><span class="cov3" title="2">{
                        return err
                }</span>
                <span class="cov5" title="3">LogVerbose("Generator hook %d executed successfully", i+1)</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// GetParserHooks returns all parser hooks (for testing)
func GetParserHooks() []ParserHook <span class="cov1" title="1">{
        return parserHooks
}</span>

// GetGeneratorHooks returns all generator hooks (for testing)
func GetGeneratorHooks() []GeneratorHook <span class="cov1" title="1">{
        return generatorHooks
}</span>

// Example plugin that adds automatic logging
func init() <span class="cov1" title="1">{
        registerLoggingPlugin()
        registerImportsPlugin()
}</span>

// registerLoggingPlugin registers the logging plugin
func registerLoggingPlugin() <span class="cov1" title="1">{
        RegisterParserHook(func(routes []*RouteMeta) error </span><span class="cov0" title="0">{
                LogVerbose("Plugin de logging: %d routes processadas", len(routes))
                for _, route := range routes </span><span class="cov0" title="0">{
                        LogVerbose("  - %s %s -&gt; %s", route.Method, route.Path, route.FuncName)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

// registerImportsPlugin registers the imports plugin
func registerImportsPlugin() <span class="cov1" title="1">{
        RegisterGeneratorHook(func(data *GenData) error </span><span class="cov0" title="0">{
                requiredImports := getRequiredImports(data)
                addMissingImports(data, requiredImports)
                LogVerbose("Plugin de imports: %d imports configurados", len(data.Imports))
                return nil
        }</span>)
}

// getRequiredImports returns the list of required imports
func getRequiredImports(data *GenData) []string <span class="cov1" title="1">{
        requiredImports := []string{
                `deco "github.com/RodolfoBonis/deco"`,
        }

        if shouldAddHandlersImport(data) </span><span class="cov0" title="0">{
                if handlerImport := buildHandlersImport(); handlerImport != "" </span><span class="cov0" title="0">{
                        requiredImports = append(requiredImports, handlerImport)
                }</span>
        }

        <span class="cov1" title="1">return requiredImports</span>
}

// shouldAddHandlersImport checks if handlers import should be added
func shouldAddHandlersImport(data *GenData) bool <span class="cov3" title="2">{
        return data.PackageName == "deco" &amp;&amp; len(data.Routes) &gt; 0 &amp;&amp; data.Routes[0].PackageName == "handlers"
}</span>

// buildHandlersImport builds the handlers import path
func buildHandlersImport() string <span class="cov1" title="1">{
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="1">modName := getModuleName(wd)
        if modName == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov1" title="1">return buildImportPath(wd, modName)</span>
}

// buildImportPath builds the import path based on working directory and module name
func buildImportPath(wd, modName string) string <span class="cov3" title="2">{
        if !strings.Contains(wd, modName) </span><span class="cov3" title="2">{
                return fmt.Sprintf(`handlers "%s/handlers"`, modName)
        }</span>

        <span class="cov0" title="0">parts := strings.Split(wd, modName)
        if len(parts) &lt;= 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf(`handlers "%s/handlers"`, modName)
        }</span>

        <span class="cov0" title="0">relativePath := strings.TrimPrefix(parts[1], "/")
        if relativePath == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf(`handlers "%s/handlers"`, modName)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(`handlers "%s/%s/handlers"`, modName, relativePath)</span>
}

// addMissingImports adds missing imports to the data
func addMissingImports(data *GenData, requiredImports []string) <span class="cov1" title="1">{
        for _, imp := range requiredImports </span><span class="cov3" title="2">{
                if !containsImport(data.Imports, imp) </span><span class="cov3" title="2">{
                        data.Imports = append(data.Imports, imp)
                }</span>
        }
}

// containsImport checks if an import already exists
func containsImport(imports []string, imp string) bool <span class="cov7" title="5">{
        for _, existing := range imports </span><span class="cov10" title="9">{
                if existing == imp </span><span class="cov3" title="2">{
                        return true
                }</span>
        }
        <span class="cov5" title="3">return false</span>
}

// getModuleName extracts module name from go.mod
func getModuleName(dir string) string <span class="cov3" title="2">{
        for </span><span class="cov6" title="4">{
                goModPath := filepath.Join(dir, "go.mod")
                if _, err := os.Stat(goModPath); err == nil </span><span class="cov1" title="1">{
                        file, err := os.Open(goModPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return ""
                        }</span>

                        <span class="cov1" title="1">scanner := bufio.NewScanner(file)
                        for scanner.Scan() </span><span class="cov1" title="1">{
                                line := strings.TrimSpace(scanner.Text())
                                if strings.HasPrefix(line, "module ") </span><span class="cov1" title="1">{
                                        file.Close()
                                        return strings.TrimSpace(strings.TrimPrefix(line, "module"))
                                }</span>
                        }
                        <span class="cov0" title="0">file.Close()
                        return ""</span>
                }

                <span class="cov5" title="3">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov1" title="1">{
                        break</span>
                }
                <span class="cov3" title="2">dir = parent</span>
        }
        <span class="cov1" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package decorators

import (
        "crypto/tls"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// ProxyConfig configuration for proxy middleware
type ProxyConfig struct {
        // Service Discovery
        Target    string   `json:"target"`    // Direct URL
        Service   string   `json:"service"`   // Service name for discovery
        Discovery string   `json:"discovery"` // dns, consul, kubernetes, static
        Targets   []string `json:"targets"`   // List of URLs for static discovery

        // Load Balancing
        LoadBalancer   string `json:"load_balancer"`   // round_robin, least_connections, ip_hash, weighted
        HealthCheck    string `json:"health_check"`    // Health check endpoint
        HealthInterval string `json:"health_interval"` // Health check interval

        // Resilience
        Timeout      string `json:"timeout"`
        Retries      int    `json:"retries"`
        RetryBackoff string `json:"retry_backoff"` // linear, exponential
        RetryDelay   string `json:"retry_delay"`

        // Circuit Breaker
        CircuitBreaker   string `json:"circuit_breaker"`
        FailureThreshold int    `json:"failure_threshold"`

        // Advanced
        Path      string            `json:"path"`
        Headers   map[string]string `json:"headers"`
        Transform string            `json:"transform"` // Request/response transformation

        // Service Discovery specific
        ConsulAddress string `json:"consul_address"`
        K8sNamespace  string `json:"k8s_namespace"`
}

// ProxyInstance represents a service instance
type ProxyInstance struct {
        URL          string            `json:"url"`
        Weight       int               `json:"weight"`
        Healthy      bool              `json:"healthy"`
        LastCheck    time.Time         `json:"last_check"`
        ActiveConns  int               `json:"active_conns"`
        FailureCount int               `json:"failure_count"`
        Metadata     map[string]string `json:"metadata"`
        mu           sync.RWMutex
}

// ProxyManager manages proxy operations
type ProxyManager struct {
        instances      []*ProxyInstance
        loadBalancer   LoadBalancer
        circuitBreaker CircuitBreaker
        healthChecker  HealthChecker
        httpClient     *http.Client
        config         ProxyConfig
        mu             sync.RWMutex
}

// LoadBalancer interface for different load balancing algorithms
type LoadBalancer interface {
        Select(instances []*ProxyInstance, c *gin.Context) *ProxyInstance
}

// CircuitBreaker interface for circuit breaker pattern
type CircuitBreaker interface {
        IsOpen() bool
        RecordSuccess()
        RecordFailure()
        GetState() string
}

// HealthChecker interface for health checking
type HealthChecker interface {
        Check(instance *ProxyInstance) bool
}

// ServiceDiscovery interface for different discovery methods
type ServiceDiscovery interface {
        Discover(service string) ([]*ProxyInstance, error)
}

// Global proxy managers registry
var proxyManagers = make(map[string]*ProxyManager)
var proxyManagersMu sync.RWMutex

// clearProxyManagers clears the proxy managers cache (for testing)
func clearProxyManagers() <span class="cov5" title="6">{
        proxyManagersMu.Lock()
        defer proxyManagersMu.Unlock()
        proxyManagers = make(map[string]*ProxyManager)
}</span>

// Default configurations
const (
        DefaultTimeout          = "10s"
        DefaultRetries          = 3
        DefaultRetryDelay       = "1s"
        DefaultHealthInterval   = "30s"
        DefaultFailureThreshold = 5
        DefaultCircuitBreaker   = "30s"
)

// createProxyMiddleware creates proxy middleware with configuration
func createProxyMiddleware(args []string) gin.HandlerFunc <span class="cov6" title="9">{
        config := parseProxyConfig(args)
        manager := getOrCreateProxyManager(&amp;config)

        return func(c *gin.Context) </span><span class="cov6" title="9">{
                // 1. Intercept BEFORE (if handler wants)
                c.Next()

                // 2. If handler didn't abort, do proxy
                if !c.IsAborted() </span><span class="cov5" title="8">{
                        manager.Forward(c, &amp;config)
                }</span>

                // 3. Intercept AFTER (if handler wants)
                <span class="cov6" title="9">c.Next()</span>
        }
}

// parseProxyConfig parses proxy configuration from arguments
func parseProxyConfig(args []string) ProxyConfig <span class="cov7" title="13">{
        config := ProxyConfig{
                Timeout:          DefaultTimeout,
                Retries:          DefaultRetries,
                RetryDelay:       DefaultRetryDelay,
                RetryBackoff:     "exponential",
                LoadBalancer:     "round_robin",
                HealthInterval:   DefaultHealthInterval,
                FailureThreshold: DefaultFailureThreshold,
                CircuitBreaker:   DefaultCircuitBreaker,
                Headers:          make(map[string]string),
        }

        for _, arg := range args </span><span class="cov10" title="45">{
                parts := strings.SplitN(arg, "=", 2)
                if len(parts) != 2 </span><span class="cov2" title="2">{
                        continue</span>
                }

                <span class="cov9" title="43">key := parts[0]
                value := parts[1]

                switch key </span>{
                case "target":<span class="cov6" title="11">
                        config.Target = value</span>
                case "service":<span class="cov0" title="0">
                        config.Service = value</span>
                case "discovery":<span class="cov0" title="0">
                        config.Discovery = value</span>
                case "targets":<span class="cov0" title="0">
                        config.Targets = strings.Split(value, ",")</span>
                case "load_balancer":<span class="cov2" title="2">
                        config.LoadBalancer = value</span>
                case "health_check":<span class="cov1" title="1">
                        config.HealthCheck = value</span>
                case "health_interval":<span class="cov1" title="1">
                        config.HealthInterval = value</span>
                case "timeout":<span class="cov5" title="6">
                        config.Timeout = value</span>
                case "retries":<span class="cov4" title="5">
                        if retries, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="4">{
                                config.Retries = retries
                        }</span>
                case "retry_backoff":<span class="cov1" title="1">
                        config.RetryBackoff = value</span>
                case "retry_delay":<span class="cov1" title="1">
                        config.RetryDelay = value</span>
                case "circuit_breaker":<span class="cov3" title="3">
                        config.CircuitBreaker = value</span>
                case "failure_threshold":<span class="cov4" title="4">
                        if threshold, err := strconv.Atoi(value); err == nil </span><span class="cov3" title="3">{
                                config.FailureThreshold = threshold
                        }</span>
                case "path":<span class="cov4" title="4">
                        config.Path = value</span>
                case "transform":<span class="cov1" title="1">
                        config.Transform = value</span>
                case "consul_address":<span class="cov0" title="0">
                        config.ConsulAddress = value</span>
                case "k8s_namespace":<span class="cov0" title="0">
                        config.K8sNamespace = value</span>
                }
        }

        <span class="cov7" title="13">return config</span>
}

// getOrCreateProxyManager gets or creates a proxy manager
func getOrCreateProxyManager(config *ProxyConfig) *ProxyManager <span class="cov6" title="9">{
        // Create unique key for this configuration
        key := fmt.Sprintf("%s:%s:%s", config.Service, config.Target, config.Discovery)

        proxyManagersMu.RLock()
        if manager, exists := proxyManagers[key]; exists </span><span class="cov1" title="1">{
                proxyManagersMu.RUnlock()
                return manager
        }</span>
        <span class="cov5" title="8">proxyManagersMu.RUnlock()

        // Create new manager
        proxyManagersMu.Lock()
        defer proxyManagersMu.Unlock()

        // Double-check after acquiring lock
        if manager, exists := proxyManagers[key]; exists </span><span class="cov0" title="0">{
                return manager
        }</span>

        <span class="cov5" title="8">manager := NewProxyManager(config)
        proxyManagers[key] = manager

        // Start background tasks
        go manager.startHealthChecks()
        go manager.startServiceDiscovery()

        return manager</span>
}

// NewProxyManager creates a new proxy manager
func NewProxyManager(config *ProxyConfig) *ProxyManager <span class="cov7" title="13">{
        // Parse timeouts
        timeout, _ := time.ParseDuration(config.Timeout)
        if timeout == 0 </span><span class="cov3" title="3">{
                timeout = 10 * time.Second
        }</span>

        // Create HTTP client
        <span class="cov7" title="13">httpClient := &amp;http.Client{
                Timeout: timeout,
                Transport: &amp;http.Transport{
                        MaxIdleConns:        100,
                        MaxIdleConnsPerHost: 10,
                        IdleConnTimeout:     90 * time.Second,
                        TLSClientConfig: &amp;tls.Config{
                                // Secure TLS configuration
                                MinVersion: tls.VersionTLS12,
                                MaxVersion: tls.VersionTLS13,
                                // In production, this should be false and proper certificates should be used
                                // For development/testing, this can be true but should be configurable
                                InsecureSkipVerify: false, // Secure by default
                        },
                },
        }

        manager := &amp;ProxyManager{
                config:     *config,
                httpClient: httpClient,
        }

        // Initialize load balancer
        manager.loadBalancer = createLoadBalancer(config.LoadBalancer)

        // Initialize circuit breaker
        manager.circuitBreaker = createCircuitBreaker(config)

        // Initialize health checker
        manager.healthChecker = createHealthChecker(config)

        // Initialize instances
        manager.initializeInstances()

        return manager</span>
}

// initializeInstances initializes service instances
func (pm *ProxyManager) initializeInstances() <span class="cov7" title="13">{
        if pm.config.Target != "" </span><span class="cov6" title="9">{
                // Single target
                instance := &amp;ProxyInstance{
                        URL:       pm.config.Target,
                        Weight:    1,
                        Healthy:   true,
                        LastCheck: time.Now(),
                        Metadata:  make(map[string]string),
                }
                pm.instances = append(pm.instances, instance)
        }</span> else<span class="cov4" title="4"> if len(pm.config.Targets) &gt; 0 </span><span class="cov0" title="0">{
                // Static targets
                for _, target := range pm.config.Targets </span><span class="cov0" title="0">{
                        instance := &amp;ProxyInstance{
                                URL:       strings.TrimSpace(target),
                                Weight:    1,
                                Healthy:   true,
                                LastCheck: time.Now(),
                                Metadata:  make(map[string]string),
                        }
                        pm.instances = append(pm.instances, instance)
                }</span>
        }
}

// Forward forwards the request to the selected instance
func (pm *ProxyManager) Forward(c *gin.Context, config *ProxyConfig) <span class="cov6" title="9">{
        // Check circuit breaker
        if pm.circuitBreaker.IsOpen() </span><span class="cov0" title="0">{
                c.JSON(503, gin.H{"error": "Service temporarily unavailable"})
                c.Abort()
                return
        }</span>

        // Select instance
        <span class="cov6" title="9">instance := pm.loadBalancer.Select(pm.instances, c)
        if instance == nil </span><span class="cov1" title="1">{
                c.JSON(503, gin.H{"error": "No healthy instances available"})
                c.Abort()
                return
        }</span>

        // Build target URL
        <span class="cov5" title="8">targetURL := pm.buildTargetURL(instance, c)

        // Create request
        req, err := http.NewRequest(c.Request.Method, targetURL, c.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Failed to create request"})
                c.Abort()
                return
        }</span>

        // Copy headers
        <span class="cov5" title="8">for key, values := range c.Request.Header </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        req.Header.Add(key, value)
                }</span>
        }

        // Add custom headers
        <span class="cov5" title="8">for key, value := range config.Headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Add proxy headers
        <span class="cov5" title="8">req.Header.Set("X-Forwarded-For", c.ClientIP())
        req.Header.Set("X-Forwarded-Proto", c.Request.URL.Scheme)
        req.Header.Set("X-Forwarded-Host", c.Request.Host)

        // Execute request with retry logic
        var resp *http.Response
        var lastErr error

        for attempt := 0; attempt &lt;= config.Retries; attempt++ </span><span class="cov8" title="26">{
                // Increment active connections
                instance.mu.Lock()
                instance.ActiveConns++
                instance.mu.Unlock()

                // Execute request
                resp, lastErr = pm.httpClient.Do(req)

                // Decrement active connections
                instance.mu.Lock()
                instance.ActiveConns--
                instance.mu.Unlock()

                if lastErr == nil &amp;&amp; resp.StatusCode &lt; 500 </span><span class="cov2" title="2">{
                        // Success
                        pm.circuitBreaker.RecordSuccess()
                        break</span>
                }

                // Failure
                <span class="cov8" title="24">pm.circuitBreaker.RecordFailure()
                instance.mu.Lock()
                instance.FailureCount++
                instance.mu.Unlock()

                if attempt &lt; config.Retries </span><span class="cov7" title="18">{
                        // Calculate delay
                        delay := pm.calculateRetryDelay(attempt, config)
                        time.Sleep(delay)
                }</span>
        }

        <span class="cov5" title="8">if lastErr != nil </span><span class="cov5" title="6">{
                c.JSON(502, gin.H{"error": "Upstream service error"})
                c.Abort()
                return
        }</span>

        // Copy response
        <span class="cov2" title="2">for key, values := range resp.Header </span><span class="cov6" title="10">{
                for _, value := range values </span><span class="cov6" title="10">{
                        c.Header(key, value)
                }</span>
        }

        // Add proxy headers
        <span class="cov2" title="2">c.Header("X-Proxy-Instance", instance.URL)
        c.Header("X-Proxy-Circuit-Breaker", pm.circuitBreaker.GetState())

        // Copy response body
        body, err := io.ReadAll(resp.Body)
        resp.Body.Close()

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(502, gin.H{"error": "Failed to read response"})
                c.Abort()
                return
        }</span>

        // Set response
        <span class="cov2" title="2">c.Data(resp.StatusCode, resp.Header.Get("Content-Type"), body)</span>
}

// buildTargetURL builds the target URL for the request
func (pm *ProxyManager) buildTargetURL(instance *ProxyInstance, c *gin.Context) string <span class="cov6" title="9">{
        baseURL := instance.URL

        // If path is specified, use it
        if pm.config.Path != "" </span><span class="cov4" title="4">{
                path := pm.config.Path

                // Replace path parameters
                for _, param := range c.Params </span><span class="cov1" title="1">{
                        path = strings.ReplaceAll(path, "{"+param.Key+"}", param.Value)
                }</span>

                // Join with base URL
                <span class="cov4" title="4">baseURL = strings.TrimSuffix(baseURL, "/")
                if !strings.HasPrefix(path, "/") </span><span class="cov0" title="0">{
                        path = "/" + path
                }</span>
                <span class="cov4" title="4">baseURL += path</span>
        } else<span class="cov4" title="5"> if c.Request != nil &amp;&amp; c.Request.URL != nil </span><span class="cov4" title="5">{
                // Use original path if request is available
                baseURL += c.Request.URL.Path
        }</span>

        // Add query parameters if request is available
        <span class="cov6" title="9">if c.Request != nil &amp;&amp; c.Request.URL != nil &amp;&amp; c.Request.URL.RawQuery != "" </span><span class="cov0" title="0">{
                baseURL += "?" + c.Request.URL.RawQuery
        }</span>

        <span class="cov6" title="9">return baseURL</span>
}

// calculateRetryDelay calculates delay for retry attempts
func (pm *ProxyManager) calculateRetryDelay(attempt int, config *ProxyConfig) time.Duration <span class="cov8" title="24">{
        baseDelay, _ := time.ParseDuration(config.RetryDelay)
        if baseDelay == 0 </span><span class="cov0" title="0">{
                baseDelay = time.Second
        }</span>

        <span class="cov8" title="24">if config.RetryBackoff == "exponential" </span><span class="cov8" title="21">{
                return baseDelay * time.Duration(1&lt;&lt;attempt)
        }</span>

        // Linear backoff
        <span class="cov3" title="3">return baseDelay * time.Duration(attempt+1)</span>
}

// startHealthChecks starts background health checks
func (pm *ProxyManager) startHealthChecks() <span class="cov5" title="8">{
        if pm.config.HealthCheck == "" </span><span class="cov5" title="8">{
                return
        }</span>

        <span class="cov0" title="0">interval, _ := time.ParseDuration(pm.config.HealthInterval)
        if interval == 0 </span><span class="cov0" title="0">{
                interval = 30 * time.Second
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                pm.performHealthChecks()
        }</span>
}

// performHealthChecks performs health checks on all instances
func (pm *ProxyManager) performHealthChecks() <span class="cov1" title="1">{
        pm.mu.RLock()
        instances := make([]*ProxyInstance, len(pm.instances))
        copy(instances, pm.instances)
        pm.mu.RUnlock()

        for _, instance := range instances </span><span class="cov0" title="0">{
                healthy := pm.healthChecker.Check(instance)

                instance.mu.Lock()
                instance.Healthy = healthy
                instance.LastCheck = time.Now()
                if healthy </span><span class="cov0" title="0">{
                        instance.FailureCount = 0
                }</span>
                <span class="cov0" title="0">instance.mu.Unlock()</span>
        }
}

// startServiceDiscovery starts background service discovery
func (pm *ProxyManager) startServiceDiscovery() <span class="cov5" title="8">{
        if pm.config.Service == "" || pm.config.Discovery == "" </span><span class="cov5" title="8">{
                return
        }</span>

        <span class="cov0" title="0">interval, _ := time.ParseDuration(pm.config.HealthInterval)
        if interval == 0 </span><span class="cov0" title="0">{
                interval = 30 * time.Second
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                pm.performServiceDiscovery()
        }</span>
}

// performServiceDiscovery performs service discovery
func (pm *ProxyManager) performServiceDiscovery() <span class="cov1" title="1">{
        var discovery ServiceDiscovery

        switch pm.config.Discovery </span>{
        case "consul":<span class="cov0" title="0">
                discovery = NewConsulDiscovery(pm.config.ConsulAddress)</span>
        case "dns":<span class="cov0" title="0">
                discovery = NewDNSDiscovery()</span>
        case "kubernetes":<span class="cov0" title="0">
                discovery = NewK8sDiscovery(pm.config.K8sNamespace)</span>
        default:<span class="cov1" title="1">
                return</span>
        }

        <span class="cov0" title="0">instances, err := discovery.Discover(pm.config.Service)
        if err != nil </span><span class="cov0" title="0">{
                LogVerbose("Service discovery error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">pm.mu.Lock()
        pm.instances = instances
        pm.mu.Unlock()</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package decorators

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
)

// RateLimiter interface for different rate limiting implementations
type RateLimiter interface {
        Allow(ctx context.Context, key string, limit int, window time.Duration) (bool, int, time.Duration, error)
        Reset(ctx context.Context, key string) error
}

// MemoryRateLimiter local in-memory implementation
type MemoryRateLimiter struct {
        buckets map[string]*TokenBucket
}

// TokenBucket represents a token bucket
type TokenBucket struct {
        tokens     int
        lastRefill time.Time
        limit      int
        window     time.Duration
}

// RedisRateLimiter distributed implementation with Redis
type RedisRateLimiter struct {
        client *redis.Client
}

// RateLimitResponse response when rate limit is exceeded
type RateLimitResponse struct {
        Error      string `json:"error"`
        Message    string `json:"message"`
        Limit      int    `json:"limit"`
        Remaining  int    `json:"remaining"`
        RetryAfter int    `json:"retry_after"`
}

// KeyGeneratorFunc function to generate rate limiting keys
type KeyGeneratorFunc func(c *gin.Context) string

// Default key generation functions
var (
        IPKeyGenerator = func(c *gin.Context) string <span class="cov7" title="15">{
                return "ratelimit:ip:" + c.ClientIP()
        }</span>

        UserKeyGenerator = func(c *gin.Context) string <span class="cov3" title="3">{
                userID := c.GetString("user_id")
                if userID == "" </span><span class="cov2" title="2">{
                        return "ratelimit:anonymous:" + c.ClientIP()
                }</span>
                <span class="cov1" title="1">return "ratelimit:user:" + userID</span>
        }

        EndpointKeyGenerator = func(c *gin.Context) string <span class="cov2" title="2">{
                return fmt.Sprintf("ratelimit:endpoint:%s:%s:%s", c.Request.Method, c.FullPath(), c.ClientIP())
        }</span>
)

// NewMemoryRateLimiter creates an in-memory rate limiter
func NewMemoryRateLimiter() *MemoryRateLimiter <span class="cov8" title="33">{
        return &amp;MemoryRateLimiter{
                buckets: make(map[string]*TokenBucket),
        }
}</span>

// Allow checks if the request can proceed (in-memory implementation)
func (m *MemoryRateLimiter) Allow(ctx context.Context, key string, limit int, window time.Duration) (allowed bool, remaining int, retryAfter time.Duration, err error) <span class="cov10" title="58">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return false, 0, 0, ctx.Err()</span>
        default:<span class="cov9" title="57"></span>
        }

        <span class="cov9" title="57">now := time.Now()

        bucket, exists := m.buckets[key]
        if !exists </span><span class="cov7" title="22">{
                bucket = &amp;TokenBucket{
                        tokens:     limit - 1,
                        lastRefill: now,
                        limit:      limit,
                        window:     window,
                }
                m.buckets[key] = bucket
                return true, limit - 1, 0, nil
        }</span>

        // Calculate how many tokens should be added
        <span class="cov8" title="35">elapsed := now.Sub(bucket.lastRefill)
        if elapsed &gt;= window </span><span class="cov1" title="1">{
                // Complete bucket reset
                bucket.tokens = limit
                bucket.lastRefill = now
        }</span> else<span class="cov8" title="34"> {
                // Add tokens proportionally
                tokensToAdd := int(elapsed * time.Duration(limit) / window)
                bucket.tokens = minValue(bucket.limit, bucket.tokens+tokensToAdd)
                if tokensToAdd &gt; 0 </span><span class="cov0" title="0">{
                        bucket.lastRefill = now
                }</span>
        }

        <span class="cov8" title="35">if bucket.tokens &gt; 0 </span><span class="cov8" title="31">{
                bucket.tokens--
                return true, bucket.tokens, 0, nil
        }</span>

        // Calculate time until next token
        <span class="cov4" title="4">timeUntilNextToken := window - elapsed
        return false, 0, timeUntilNextToken, nil</span>
}

// Reset clears the bucket for a key (in-memory implementation)
func (m *MemoryRateLimiter) Reset(ctx context.Context, key string) error <span class="cov3" title="3">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        default:<span class="cov2" title="2"></span>
        }

        <span class="cov2" title="2">delete(m.buckets, key)
        return nil</span>
}

// NewRedisRateLimiter creates a distributed rate limiter with Redis
func NewRedisRateLimiter(config RedisConfig) (*RedisRateLimiter, error) <span class="cov3" title="3">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     config.Address,
                Password: config.Password,
                DB:       config.DB,
                PoolSize: config.PoolSize,
        })

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov3" title="3">{
                return nil, fmt.Errorf("failed to connect to Redis: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;RedisRateLimiter{client: client}, nil</span>
}

// Allow checks if the request can proceed (Redis implementation)
func (r *RedisRateLimiter) Allow(ctx context.Context, key string, limit int, window time.Duration) (allowed bool, remaining int, retryAfter time.Duration, err error) <span class="cov0" title="0">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return false, 0, 0, ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        // Lua script for atomic rate limiting operation
        <span class="cov0" title="0">script := `
                local key = KEYS[1]
                local limit = tonumber(ARGV[1])
                local window = tonumber(ARGV[2])
                local current_time = tonumber(ARGV[3])
                
                -- Get current information
                local bucket = redis.call('HMGET', key, 'count', 'reset_time')
                local count = tonumber(bucket[1]) or 0
                local reset_time = tonumber(bucket[2]) or current_time
                
                -- If window time has passed, reset
                if current_time &gt;= reset_time then
                        count = 0
                        reset_time = current_time + window
                end
                
                -- Check if request can be made
                if count &gt;= limit then
                        local retry_after = reset_time - current_time
                        return {0, count, retry_after}
                end
                
                -- Increment counter
                count = count + 1
                redis.call('HMSET', key, 'count', count, 'reset_time', reset_time)
                redis.call('EXPIRE', key, math.ceil(window))
                
                local remaining = limit - count
                return {1, remaining, 0}
        `

        now := time.Now().Unix()
        windowSeconds := int64(window.Seconds())

        result, err := r.client.Eval(ctx, script, []string{key}, limit, windowSeconds, now).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, 0, fmt.Errorf("redis rate limiting error: %v", err)
        }</span>

        <span class="cov0" title="0">values := result.([]interface{})
        allowed = values[0].(int64) == 1
        remaining = int(values[1].(int64))
        retryAfter = time.Duration(values[2].(int64)) * time.Second

        return allowed, remaining, retryAfter, nil</span>
}

// Reset clears the bucket for a key (Redis implementation)
func (r *RedisRateLimiter) Reset(ctx context.Context, key string) error <span class="cov0" title="0">{
        // Use context for timeout and cancellation
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">return r.client.Del(ctx, key).Err()</span>
}

// RateLimitMiddleware creates rate limiting middleware
func RateLimitMiddleware(config *RateLimitConfig, keyGen KeyGeneratorFunc) gin.HandlerFunc <span class="cov6" title="14">{
        var limiter RateLimiter
        var err error

        // Choose implementation based on configuration
        if config.Type == "redis" </span><span class="cov0" title="0">{
                redisConfig := DefaultConfig().Redis
                limiter, err = NewRedisRateLimiter(redisConfig)
                if err != nil </span><span class="cov0" title="0">{
                        // Fallback to memory if Redis fails
                        limiter = NewMemoryRateLimiter()
                }</span>
        } else<span class="cov6" title="14"> {
                limiter = NewMemoryRateLimiter()
        }</span>

        <span class="cov6" title="14">return func(c *gin.Context) </span><span class="cov6" title="14">{
                if !config.Enabled </span><span class="cov4" title="6">{
                        c.Next()
                        return
                }</span>

                // Generate key for this client/endpoint
                <span class="cov5" title="8">key := keyGen(c)

                // Check rate limit
                allowed, remaining, retryAfter, err := limiter.Allow(
                        c.Request.Context(),
                        key,
                        config.DefaultRPS,
                        time.Minute, // 1 minute window
                )

                if err != nil </span><span class="cov0" title="0">{
                        // In case of error, allow request (fail-open)
                        c.Next()
                        return
                }</span>

                // Add informative headers
                <span class="cov5" title="8">c.Header("X-RateLimit-Limit", strconv.Itoa(config.DefaultRPS))
                c.Header("X-RateLimit-Remaining", strconv.Itoa(remaining))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(time.Now().Add(time.Minute).Unix(), 10))

                if !allowed </span><span class="cov1" title="1">{
                        c.Header("Retry-After", strconv.FormatInt(int64(retryAfter.Seconds()), 10))

                        response := RateLimitResponse{
                                Error:      "rate_limit_exceeded",
                                Message:    "Request rate exceeded. Please try again later.",
                                Limit:      config.DefaultRPS,
                                Remaining:  0,
                                RetryAfter: int(retryAfter.Seconds()),
                        }

                        c.AbortWithStatusJSON(http.StatusTooManyRequests, response)
                        return
                }</span>

                <span class="cov5" title="7">c.Next()</span>
        }
}

// RateLimitByIP rate limiting middleware by IP
func RateLimitByIP(config *RateLimitConfig) gin.HandlerFunc <span class="cov4" title="5">{
        return RateLimitMiddleware(config, IPKeyGenerator)
}</span>

// RateLimitByUser rate limiting middleware by user
func RateLimitByUser(config *RateLimitConfig) gin.HandlerFunc <span class="cov4" title="5">{
        return RateLimitMiddleware(config, UserKeyGenerator)
}</span>

// RateLimitByEndpoint rate limiting middleware by endpoint
func RateLimitByEndpoint(config *RateLimitConfig) gin.HandlerFunc <span class="cov3" title="3">{
        return RateLimitMiddleware(config, EndpointKeyGenerator)
}</span>

// CustomRateLimit customizable rate limiting middleware
func CustomRateLimit(limit int, window time.Duration, keyGen KeyGeneratorFunc, rateLimiterType string) gin.HandlerFunc <span class="cov1" title="1">{
        config := &amp;RateLimitConfig{
                Enabled:    true,
                Type:       rateLimiterType,
                DefaultRPS: limit,
        }

        // Create specific limiter based on type
        var limiter RateLimiter
        if rateLimiterType == "redis" </span><span class="cov0" title="0">{
                redisConfig := DefaultConfig().Redis
                if redisLimiter, err := NewRedisRateLimiter(redisConfig); err == nil </span><span class="cov0" title="0">{
                        limiter = redisLimiter
                }</span> else<span class="cov0" title="0"> {
                        limiter = NewMemoryRateLimiter()
                }</span>
        } else<span class="cov1" title="1"> {
                limiter = NewMemoryRateLimiter()
        }</span>

        <span class="cov1" title="1">return func(c *gin.Context) </span><span class="cov1" title="1">{
                if !config.Enabled </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Generate key for this client/endpoint
                <span class="cov1" title="1">key := keyGen(c)

                // Use context with timeout
                ctx, cancel := context.WithTimeout(c.Request.Context(), 5*time.Second)
                defer cancel()

                // Check rate limit using the custom window
                allowed, remaining, retryAfter, err := limiter.Allow(
                        ctx,
                        key,
                        limit,
                        window, // Use the custom window parameter
                )

                if err != nil </span><span class="cov0" title="0">{
                        // In case of error, allow request (fail-open)
                        c.Next()
                        return
                }</span>

                // Add informative headers
                <span class="cov1" title="1">c.Header("X-RateLimit-Limit", strconv.Itoa(limit))
                c.Header("X-RateLimit-Remaining", strconv.Itoa(remaining))
                c.Header("X-RateLimit-Window", window.String())

                if !allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(retryAfter.Seconds()), 10))

                        response := RateLimitResponse{
                                Error:      "rate_limit_exceeded",
                                Message:    fmt.Sprintf("Request rate exceeded. Limit: %d per %v", limit, window),
                                Limit:      limit,
                                Remaining:  0,
                                RetryAfter: int(retryAfter.Seconds()),
                        }

                        c.AbortWithStatusJSON(http.StatusTooManyRequests, response)
                        return
                }</span>

                <span class="cov1" title="1">c.Next()</span>
        }
}

// ParseRateLimitArgs parses @RateLimit decorator arguments
func ParseRateLimitArgs(args []string) (limit int, window time.Duration, rateLimiterType string, keyGen KeyGeneratorFunc) <span class="cov6" title="13">{
        limit = 100                // default
        window = time.Minute       // default
        rateLimiterType = "memory" // default
        keyGen = IPKeyGenerator    // default

        for _, arg := range args </span><span class="cov6" title="11">{
                if strings.Contains(arg, "=") </span><span class="cov6" title="11">{
                        parts := strings.SplitN(arg, "=", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"'`)

                        switch key </span>{
                        case "limit", "rps":<span class="cov4" title="4">
                                if parsed, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="4">{
                                        limit = parsed
                                }</span>
                        case "window":<span class="cov3" title="3">
                                if parsed, err := time.ParseDuration(value); err == nil </span><span class="cov3" title="3">{
                                        window = parsed
                                }</span>
                        case "type":<span class="cov3" title="3">
                                rateLimiterType = value</span>
                        case "key", "by":<span class="cov0" title="0">
                                switch value </span>{
                                case "ip":<span class="cov0" title="0">
                                        keyGen = IPKeyGenerator</span>
                                case "user":<span class="cov0" title="0">
                                        keyGen = UserKeyGenerator</span>
                                case "endpoint":<span class="cov0" title="0">
                                        keyGen = EndpointKeyGenerator</span>
                                }
                        }
                }
        }

        <span class="cov6" title="13">return limit, window, rateLimiterType, keyGen</span>
}

// createRateLimitMiddlewareInternal creates rate limiting middleware (for markers.go)
func createRateLimitMiddlewareInternal(args []string) gin.HandlerFunc <span class="cov5" title="8">{
        limit, window, rateLimiterType, keyGen := ParseRateLimitArgs(args)

        // Create specific limiter
        var limiter RateLimiter
        if rateLimiterType == "redis" </span><span class="cov0" title="0">{
                redisConfig := DefaultConfig().Redis
                if redisLimiter, err := NewRedisRateLimiter(redisConfig); err == nil </span><span class="cov0" title="0">{
                        limiter = redisLimiter
                }</span> else<span class="cov0" title="0"> {
                        limiter = NewMemoryRateLimiter()
                }</span>
        } else<span class="cov5" title="8"> {
                limiter = NewMemoryRateLimiter()
        }</span>

        <span class="cov5" title="8">return func(c *gin.Context) </span><span class="cov5" title="8">{
                key := keyGen(c)

                allowed, remaining, retryAfter, err := limiter.Allow(
                        c.Request.Context(),
                        key,
                        limit,
                        window,
                )

                if err != nil </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Informative headers
                <span class="cov5" title="8">c.Header("X-RateLimit-Limit", strconv.Itoa(limit))
                c.Header("X-RateLimit-Remaining", strconv.Itoa(remaining))
                c.Header("X-RateLimit-Window", window.String())

                if !allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(retryAfter.Seconds()), 10))

                        response := RateLimitResponse{
                                Error:      "rate_limit_exceeded",
                                Message:    fmt.Sprintf("Request rate exceeded. Limit: %d per %v", limit, window),
                                Limit:      limit,
                                Remaining:  0,
                                RetryAfter: int(retryAfter.Seconds()),
                        }

                        c.AbortWithStatusJSON(http.StatusTooManyRequests, response)
                        return
                }</span>

                <span class="cov5" title="8">c.Next()</span>
        }
}

// minValue helper function
func minValue(a, b int) int <span class="cov9" title="39">{
        if a &lt; b </span><span class="cov2" title="2">{
                return a
        }</span>
        <span class="cov9" title="37">return b</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package decorators

import (
        "log"
        "reflect"
        "strings"
        "sync"

        "github.com/gin-gonic/gin"
)

// ParameterInfo represents information of a route parameter
type ParameterInfo struct {
        Name        string `json:"name"`
        Type        string `json:"type"`     // string, int, bool, etc.
        Location    string `json:"location"` // query, path, body, header
        Required    bool   `json:"required"`
        Description string `json:"description"`
        Example     string `json:"example"`
}

// ResponseInfo represents information of a route response
type ResponseInfo struct {
        Code        string `json:"code"`        // HTTP status code (200, 404, etc.)
        Description string `json:"description"` // Response description
        Type        string `json:"type"`        // Schema type name (UserResponse, ErrorResponse, etc.)
        Example     string `json:"example"`     // Response example
}

// GroupInfo represents information of a route group
type GroupInfo struct {
        Name        string `json:"name"`
        Prefix      string `json:"prefix"`
        Description string `json:"description"`
}

// RouteEntry represents complete information about a route
type RouteEntry struct {
        Method            string            `json:"method"`
        Path              string            `json:"path"`
        Handler           gin.HandlerFunc   `json:"-"`
        Middlewares       []gin.HandlerFunc `json:"-"`
        FuncName          string            `json:"func_name"`
        PackageName       string            `json:"package_name"`
        FileName          string            `json:"file_name"`
        Description       string            `json:"description"`
        Summary           string            `json:"summary"`
        Tags              []string          `json:"tags"`
        MiddlewareInfo    []MiddlewareInfo  `json:"middleware_info"`
        Parameters        []ParameterInfo   `json:"parameters"`
        Group             *GroupInfo        `json:"group,omitempty"`
        Responses         []ResponseInfo    `json:"responses,omitempty"`         // Updated to use ResponseInfo
        WebSocketHandlers []string          `json:"websocketHandlers,omitempty"` // WebSocket message types this function handles
}

// global route registry with mutex protection
var (
        routes        []RouteEntry
        groups        = make(map[string]*GroupInfo)
        registryMutex sync.RWMutex
)

// RegisterGroup registers a new route group
func RegisterGroup(name, prefix, description string) *GroupInfo <span class="cov7" title="9">{
        registryMutex.Lock()
        defer registryMutex.Unlock()

        group := &amp;GroupInfo{
                Name:        name,
                Prefix:      prefix,
                Description: description,
        }
        groups[name] = group
        LogVerbose("Grupo registrado: %s -&gt; %s", name, prefix)
        return group
}</span>

// GetGroup returns information of a group
func GetGroup(name string) *GroupInfo <span class="cov4" title="4">{
        registryMutex.RLock()
        defer registryMutex.RUnlock()
        return groups[name]
}</span>

// GetGroups returns all registered groups
func GetGroups() map[string]*GroupInfo <span class="cov9" title="24">{
        registryMutex.RLock()
        defer registryMutex.RUnlock()

        // Return a copy to avoid race conditions
        groupsCopy := make(map[string]*GroupInfo)
        for k, v := range groups </span><span class="cov4" title="4">{
                groupsCopy[k] = v
        }</span>
        <span class="cov9" title="24">return groupsCopy</span>
}

// RegisterRoute registers a new route in the framework
func RegisterRoute(method, path string, handlers ...gin.HandlerFunc) <span class="cov7" title="9">{
        RegisterRouteWithMeta(&amp;RouteEntry{
                Method:      method,
                Path:        path,
                Middlewares: handlers[:len(handlers)-1],
                Handler:     handlers[len(handlers)-1],
                FuncName:    getFuncName(handlers[len(handlers)-1]),
        })
}</span>

// RegisterRouteWithMeta registers a route with complete metadata
func RegisterRouteWithMeta(entry *RouteEntry) <span class="cov8" title="15">{
        if entry.Handler == nil </span><span class="cov0" title="0">{
                log.Fatalf("RegisterRoute: handler is required for %s %s", entry.Method, entry.Path)
        }</span>

        // If FuncName was not defined, extract from function
        <span class="cov8" title="15">if entry.FuncName == "" </span><span class="cov5" title="5">{
                entry.FuncName = getFuncName(entry.Handler)
        }</span>

        // Apply group prefix if defined
        <span class="cov8" title="15">if entry.Group != nil </span><span class="cov0" title="0">{
                if entry.Group.Prefix != "" &amp;&amp; !strings.HasPrefix(entry.Path, entry.Group.Prefix) </span><span class="cov0" title="0">{
                        entry.Path = entry.Group.Prefix + entry.Path
                }</span>
                // Add tag do grupo
                <span class="cov0" title="0">entry.Tags = append(entry.Tags, entry.Group.Name)</span>
        }

        <span class="cov8" title="15">registryMutex.Lock()
        routes = append(routes, *entry)
        registryMutex.Unlock()

        LogVerbose("Route registrada: %s %s -&gt; %s", entry.Method, entry.Path, entry.FuncName)</span>
}

// Default creates a gin.Engine with all registered routes
func Default() *gin.Engine <span class="cov1" title="1">{
        return DefaultWithSecurity(nil)
}</span>

// DefaultWithSecurity creates a gin.Engine with security configuration for internal endpoints
func DefaultWithSecurity(securityConfig *SecurityConfig) *gin.Engine <span class="cov2" title="2">{
        r := gin.Default()

        // Use default security config if not provided
        if securityConfig == nil </span><span class="cov1" title="1">{
                securityConfig = DefaultSecurityConfig()
        }</span>

        // Create security middleware for internal endpoints
        <span class="cov2" title="2">securityMiddleware := SecureInternalEndpoints(securityConfig)

        // Register documentation routes with security
        config := DefaultConfig()
        r.GET("/decorators/docs", securityMiddleware, DocsHandler)
        r.GET("/decorators/docs.json", securityMiddleware, DocsJSONHandler)
        r.GET("/decorators/openapi.json", securityMiddleware, OpenAPIJSONHandler(config))
        r.GET("/decorators/openapi.yaml", securityMiddleware, OpenAPIYAMLHandler(config))
        r.GET("/decorators/swagger-ui", securityMiddleware, SwaggerUIHandler(config))
        r.GET("/decorators/swagger", securityMiddleware, SwaggerRedirectHandler)

        // Register all framework routes
        registryMutex.RLock()
        routesCopy := make([]RouteEntry, len(routes))
        copy(routesCopy, routes)
        registryMutex.RUnlock()

        for i := range routesCopy </span><span class="cov4" title="4">{
                route := &amp;routesCopy[i]
                // Combine middlewares + main handler
                handlers := make([]gin.HandlerFunc, 0, len(route.Middlewares)+1)
                handlers = append(handlers, route.Middlewares...)
                handlers = append(handlers, route.Handler)
                r.Handle(route.Method, route.Path, handlers...)
        }</span>

        <span class="cov2" title="2">LogNormal("Framework gin-decorators inicializado com %d routes", len(routesCopy))
        return r</span>
}

// GetRoutes returns all registered routes (used for documentation)
func GetRoutes() []RouteEntry <span class="cov10" title="25">{
        registryMutex.RLock()
        defer registryMutex.RUnlock()

        // Return a copy to avoid race conditions
        routesCopy := make([]RouteEntry, len(routes))
        copy(routesCopy, routes)
        return routesCopy
}</span>

// getFuncName extracts function name from a handler
func getFuncName(handler gin.HandlerFunc) string <span class="cov8" title="15">{
        value := reflect.ValueOf(handler)
        if value.Kind() == reflect.Func </span><span class="cov8" title="15">{
                return value.Type().String()
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">//go:build !prod
// +build !prod

package decorators

import (
        "log"
        "os"
        "path/filepath"
        "strings"
)

// GlobalWatcher global file watcher instance
var GlobalWatcher *FileWatcher

// init executes automatic parsing in development (when not production build)
func init() <span class="cov1" title="1">{
        if isProdBuild() </span><span class="cov0" title="0">{
                return
        }</span>

        // Do not execute runtime parsing if we are executing CLI commands
        <span class="cov1" title="1">if isCliCommand() </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov0" title="0">LogVerbose("gin-decorators: Development mode detected, starting automatic parsing...")

        // Load configuration to determine if watcher should start
        config, err := LoadConfig("")
        if err != nil </span><span class="cov0" title="0">{
                LogVerbose("gin-decorators: Error loading config, using default: %v", err)
                config = DefaultConfig()
        }</span>

        // Detect handlers directory automatically
        <span class="cov0" title="0">handlersDir := detectHandlersDirectory()
        if handlersDir == "" </span><span class="cov0" title="0">{
                LogVerbose("gin-decorators: No 'handlers' directory found, skipping automatic parsing")
                return
        }</span>

        // Parse routes
        <span class="cov0" title="0">routes, err := ParseDirectory(handlersDir)
        if err != nil </span><span class="cov0" title="0">{
                LogSilent("gin-decorators: Error in automatic parsing: %v", err)
                return
        }</span>

        // Run hooks de parsing
        <span class="cov0" title="0">if err := executeParserHooks(routes); err != nil </span><span class="cov0" title="0">{
                LogSilent("gin-decorators: Error nos parser hooks: %v", err)
                return
        }</span>

        // Register each found route
        <span class="cov0" title="0">for _, route := range routes </span><span class="cov0" title="0">{
                // Simulate route registration (in development we don't have real handlers)
                // In production this would be done by generated code
                LogVerbose("gin-decorators: Route found %s %s -&gt; %s (middlewares: %d)",
                        route.Method, route.Path, route.FuncName, len(route.MiddlewareCalls))
        }</span>

        <span class="cov0" title="0">LogVerbose("gin-decorators: Automatic parsing completed - %d routes processed", len(routes))

        // Start file watcher if enabled
        if config.Dev.Watch </span><span class="cov0" title="0">{
                GlobalWatcher, err = NewFileWatcher(config)
                if err != nil </span><span class="cov0" title="0">{
                        LogSilent("gin-decorators: Error creating file watcher: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">if err := GlobalWatcher.Start(); err != nil </span><span class="cov0" title="0">{
                        LogSilent("gin-decorators: Error starting file watcher: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">LogVerbose("gin-decorators: File watching active - code will be regenerated automatically")</span>
        }
}

// isProdBuild checks if we are in production build
func isProdBuild() bool <span class="cov1" title="2">{
        // In development, we assume it is not production
        // The build tag //go:build !prod already handles this, but I add extra verification
        return false
}</span>

// isCliCommand checks if we are executing a CLI command
func isCliCommand() bool <span class="cov2" title="4">{
        // Check executable name
        if len(os.Args) &gt; 0 </span><span class="cov2" title="3">{
                execName := filepath.Base(os.Args[0])
                if strings.Contains(execName, "deco") </span><span class="cov1" title="2">{
                        return true
                }</span>
        }

        // Check arguments that indicate CLI command
        <span class="cov1" title="2">if len(os.Args) &gt; 1 </span><span class="cov1" title="1">{
                for _, arg := range os.Args[1:] </span><span class="cov1" title="1">{
                        if arg == "init" || arg == "-init" || arg == "--init" ||
                                arg == "version" || arg == "-version" || arg == "--version" ||
                                arg == "help" || arg == "-help" || arg == "--help" </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov1" title="2">return false</span>
}

// detectHandlersDirectory tries to automatically find handlers directory
func detectHandlersDirectory() string <span class="cov5" title="102">{
        // Possible handler directories in order of preference
        candidates := []string{
                "./handlers",
                "./internal/handlers",
                "./pkg/handlers",
                "./app/handlers",
                "./src/handlers",
                "../handlers", // caso estejamos em subdirectory
                "../../handlers",
        }

        // Get current working directory
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                LogSilent("gin-decorators: Error getting current directory: %v", err)
                return ""
        }</span>

        <span class="cov5" title="102">LogVerbose("gin-decorators: Looking for handlers starting from: %s", wd)

        // Check each candidate
        for _, candidate := range candidates </span><span class="cov7" title="714">{
                absPath, err := filepath.Abs(candidate)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if directory exists
                <span class="cov7" title="714">if info, err := os.Stat(absPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                        // Check if it contains .go files
                        if hasGoFiles(absPath) </span><span class="cov0" title="0">{
                                LogVerbose("gin-decorators: Directory handlers found: %s", absPath)
                                return absPath
                        }</span>
                }
        }

        // Try to search recursively in current directory
        <span class="cov5" title="102">var foundDir string
        if err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="6732">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov10" title="6732">if info.IsDir() &amp;&amp; strings.Contains(strings.ToLower(info.Name()), "handler") </span><span class="cov0" title="0">{
                        if hasGoFiles(path) </span><span class="cov0" title="0">{
                                foundDir = path
                                return filepath.SkipDir // stop search
                        }</span>
                }

                <span class="cov10" title="6732">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                LogSilent("gin-decorators: Error walking directory: %v", err)
        }</span>

        <span class="cov5" title="102">if foundDir != "" </span><span class="cov0" title="0">{
                absPath, _ := filepath.Abs(foundDir)
                log.Printf("gin-decorators: Directory handlers found via search: %s", absPath)
                return absPath
        }</span>

        <span class="cov5" title="102">return ""</span>
}

// hasGoFiles checks if a directory contains .go files
func hasGoFiles(dir string) bool <span class="cov5" title="122">{
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov2" title="4">{
                return false
        }</span>

        <span class="cov5" title="118">for _, entry := range entries </span><span class="cov8" title="1018">{
                if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".go") </span><span class="cov5" title="110">{
                        return true
                }</span>
        }

        <span class="cov3" title="8">return false</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package decorators

import (
        "fmt"
        "go/ast"
        "go/token"
        "regexp"
        "strconv"
        "strings"
        "sync"
)

// global schemas registry with mutex protection
var (
        schemas      = make(map[string]*SchemaInfo)
        schemasMutex sync.RWMutex
)

// RegisterSchema registers a new schema in the framework
func RegisterSchema(schema *SchemaInfo) <span class="cov3" title="5">{
        if schema.Name != "" </span><span class="cov3" title="5">{
                schemasMutex.Lock()
                schemas[schema.Name] = schema
                schemasMutex.Unlock()
                LogVerbose("Schema registered: %s", schema.Name)
        }</span>
}

// GetSchemas returns all registered schemas
func GetSchemas() map[string]*SchemaInfo <span class="cov9" title="98">{
        schemasMutex.RLock()
        defer schemasMutex.RUnlock()

        // Return a copy to avoid race conditions
        schemasCopy := make(map[string]*SchemaInfo)
        for k, v := range schemas </span><span class="cov10" title="138">{
                schemasCopy[k] = v
        }</span>
        <span class="cov9" title="98">return schemasCopy</span>
}

// GetSchema returns a specific schema by name
func GetSchema(name string) *SchemaInfo <span class="cov2" title="2">{
        schemasMutex.RLock()
        defer schemasMutex.RUnlock()
        return schemas[name]
}</span>

// ClearSchemas clears all registered schemas (useful for testing)
func ClearSchemas() <span class="cov2" title="2">{
        schemasMutex.Lock()
        schemas = make(map[string]*SchemaInfo)
        schemasMutex.Unlock()
}</span>

// parseEntityFromStruct extracts entity metadata from a struct declaration
func parseEntityFromStruct(_ *token.FileSet, fileName string, structDecl *ast.GenDecl, pkgName string) *EntityMeta <span class="cov0" title="0">{
        if structDecl.Doc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Join all comments
        <span class="cov0" title="0">comments := make([]string, 0, len(structDecl.Doc.List))
        for _, comment := range structDecl.Doc.List </span><span class="cov0" title="0">{
                comments = append(comments, comment.Text)
        }</span>
        <span class="cov0" title="0">commentText := strings.Join(comments, "\n")

        // Look for @Schema marker
        schemaRegex := regexp.MustCompile(`@Schema\s*\(([^)]*)\)`)
        if !schemaRegex.MatchString(commentText) </span><span class="cov0" title="0">{
                return nil // Not a schema struct
        }</span>

        // Find the struct type
        <span class="cov0" title="0">for _, spec := range structDecl.Specs </span><span class="cov0" title="0">{
                if typeSpec, ok := spec.(*ast.TypeSpec); ok </span><span class="cov0" title="0">{
                        if structType, ok := typeSpec.Type.(*ast.StructType); ok </span><span class="cov0" title="0">{
                                entity := &amp;EntityMeta{
                                        Name:        typeSpec.Name.Name,
                                        PackageName: pkgName,
                                        FileName:    fileName,
                                        Markers:     extractMarkersFromComment(commentText),
                                        Fields:      parseStructFields(structType),
                                }

                                // Extract description from markers
                                for _, marker := range entity.Markers </span><span class="cov0" title="0">{
                                        if marker.Name == "Description" &amp;&amp; len(marker.Args) &gt; 0 </span><span class="cov0" title="0">{
                                                entity.Description = strings.Trim(marker.Args[0], `"`)
                                        }</span>
                                }

                                <span class="cov0" title="0">return entity</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// parseStructFields extracts field information from struct
func parseStructFields(structType *ast.StructType) []FieldMeta <span class="cov1" title="1">{
        var fields []FieldMeta

        for _, field := range structType.Fields.List </span><span class="cov2" title="2">{
                for _, name := range field.Names </span><span class="cov2" title="2">{
                        if !name.IsExported() </span><span class="cov0" title="0">{
                                continue</span> // Skip unexported fields
                        }

                        <span class="cov2" title="2">fieldMeta := FieldMeta{
                                Name: name.Name,
                                Type: extractTypeString(field.Type),
                        }

                        // Extract JSON tag
                        if field.Tag != nil </span><span class="cov2" title="2">{
                                tagValue := field.Tag.Value
                                if jsonTag := extractJSONTag(tagValue); jsonTag != "" </span><span class="cov2" title="2">{
                                        fieldMeta.JSONTag = jsonTag
                                }</span>

                                // Extract validation tags
                                <span class="cov2" title="2">if validateTag := extractValidateTag(tagValue); validateTag != "" </span><span class="cov0" title="0">{
                                        fieldMeta.Validation = validateTag
                                }</span>
                        }

                        // Extract field comment/description
                        <span class="cov2" title="2">if field.Comment != nil </span><span class="cov0" title="0">{
                                var comments []string
                                for _, comment := range field.Comment.List </span><span class="cov0" title="0">{
                                        comments = append(comments, strings.TrimPrefix(comment.Text, "//"))
                                }</span>
                                <span class="cov0" title="0">fieldMeta.Description = strings.TrimSpace(strings.Join(comments, " "))</span>
                        }

                        <span class="cov2" title="2">fields = append(fields, fieldMeta)</span>
                }
        }

        <span class="cov1" title="1">return fields</span>
}

// extractTypeString converts ast.Expr to string representation
func extractTypeString(expr ast.Expr) string <span class="cov6" title="16">{
        switch t := expr.(type) </span>{
        case *ast.Ident:<span class="cov5" title="10">
                return t.Name</span>
        case *ast.StarExpr:<span class="cov2" title="2">
                return "*" + extractTypeString(t.X)</span>
        case *ast.ArrayType:<span class="cov2" title="2">
                return "[]" + extractTypeString(t.Elt)</span>
        case *ast.SelectorExpr:<span class="cov0" title="0">
                pkg := extractTypeString(t.X)
                return pkg + "." + t.Sel.Name</span>
        case *ast.MapType:<span class="cov1" title="1">
                return "map[" + extractTypeString(t.Key) + "]" + extractTypeString(t.Value)</span>
        default:<span class="cov1" title="1">
                return "interface{}"</span>
        }
}

// extractJSONTag extracts JSON tag from struct tag
func extractJSONTag(tag string) string <span class="cov3" title="5">{
        jsonRegex := regexp.MustCompile(`json:"([^"]*)"`)
        matches := jsonRegex.FindStringSubmatch(tag)
        if len(matches) &gt; 1 </span><span class="cov3" title="4">{
                return strings.Split(matches[1], ",")[0] // Get field name, ignore omitempty etc
        }</span>
        <span class="cov1" title="1">return ""</span>
}

// extractValidateTag extracts validation tag from struct tag
func extractValidateTag(tag string) string <span class="cov3" title="4">{
        validateRegex := regexp.MustCompile(`validate:"([^"]*)"`)
        matches := validateRegex.FindStringSubmatch(tag)
        if len(matches) &gt; 1 </span><span class="cov1" title="1">{
                return matches[1]
        }</span>
        <span class="cov3" title="3">return ""</span>
}

// convertEntityToSchema converts EntityMeta to SchemaInfo
func convertEntityToSchema(entity *EntityMeta) *SchemaInfo <span class="cov1" title="1">{
        schema := &amp;SchemaInfo{
                Name:        entity.Name,
                Description: entity.Description,
                Type:        "object",
                Properties:  make(map[string]*PropertyInfo),
                PackageName: entity.PackageName,
                FileName:    entity.FileName,
        }

        var required []string

        for _, field := range entity.Fields </span><span class="cov2" title="2">{
                propInfo := &amp;PropertyInfo{
                        Name:        getFieldNameForJSON(&amp;field),
                        Type:        mapGoTypeToOpenAPIType(field.Type),
                        Description: field.Description,
                }

                // Set format if applicable
                if format := getOpenAPIFormat(field.Type); format != "" </span><span class="cov0" title="0">{
                        propInfo.Format = format
                }</span>

                // Handle array types
                <span class="cov2" title="2">if strings.HasPrefix(field.Type, "[]") </span><span class="cov0" title="0">{
                        itemType := strings.TrimPrefix(field.Type, "[]")
                        propInfo.Items = &amp;PropertyInfo{
                                Type: mapGoTypeToOpenAPIType(itemType),
                        }

                        // Set format for array items if applicable
                        if format := getOpenAPIFormat(itemType); format != "" </span><span class="cov0" title="0">{
                                propInfo.Items.Format = format
                        }</span>

                        // Store the raw item type for later reference resolution
                        <span class="cov0" title="0">propInfo.Items.Name = itemType</span> // Use Name field to store original type
                }

                // Check if field is required based on validation tags
                <span class="cov2" title="2">if isFieldRequired(field.Validation) </span><span class="cov0" title="0">{
                        required = append(required, propInfo.Name)
                        propInfo.Required = true
                }</span>

                // Extract validation constraints
                <span class="cov2" title="2">extractValidationConstraints(field.Validation, propInfo)

                schema.Properties[propInfo.Name] = propInfo</span>
        }

        <span class="cov1" title="1">if len(required) &gt; 0 </span><span class="cov0" title="0">{
                schema.Required = required
        }</span>

        <span class="cov1" title="1">return schema</span>
}

// getFieldNameForJSON returns the field name to use in JSON (considers json tag)
func getFieldNameForJSON(field *FieldMeta) string <span class="cov3" title="3">{
        if field.JSONTag != "" &amp;&amp; field.JSONTag != "-" </span><span class="cov3" title="3">{
                return field.JSONTag
        }</span>
        // Convert field name to camelCase if no json tag
        <span class="cov0" title="0">return strings.ToLower(field.Name[:1]) + field.Name[1:]</span>
}

// mapGoTypeToOpenAPIType maps Go types to OpenAPI types
func mapGoTypeToOpenAPIType(goType string) string <span class="cov5" title="10">{
        switch </span>{
        case goType == "string":<span class="cov2" title="2">
                return "string"</span>
        case goType == "int" || goType == "int32" || goType == "int64":<span class="cov3" title="3">
                return "integer"</span>
        case goType == "float32" || goType == "float64":<span class="cov1" title="1">
                return "number"</span>
        case goType == "bool":<span class="cov1" title="1">
                return "boolean"</span>
        case strings.HasPrefix(goType, "[]"):<span class="cov1" title="1">
                return "array"</span>
        case strings.HasPrefix(goType, "map["):<span class="cov1" title="1">
                return "object"</span>
        case strings.HasPrefix(goType, "*"):<span class="cov0" title="0">
                // Pointer type - recursively map the underlying type
                return mapGoTypeToOpenAPIType(strings.TrimPrefix(goType, "*"))</span>
        default:<span class="cov1" title="1">
                return "object"</span>
        }
}

// getOpenAPIFormat returns OpenAPI format for specific Go types
func getOpenAPIFormat(goType string) string <span class="cov4" title="6">{
        switch goType </span>{
        case "int32":<span class="cov0" title="0">
                return "int32"</span>
        case "int64":<span class="cov0" title="0">
                return "int64"</span>
        case "float32":<span class="cov0" title="0">
                return "float"</span>
        case "float64":<span class="cov0" title="0">
                return "double"</span>
        default:<span class="cov4" title="6">
                return ""</span>
        }
}

// isFieldRequired checks if field is required based on validation tag
func isFieldRequired(validation string) bool <span class="cov3" title="4">{
        return strings.Contains(validation, "required")
}</span>

// resolveSchemaReferences resolves schema references in all registered schemas
// This should be called after all schemas have been registered
func resolveSchemaReferences() <span class="cov6" title="22">{
        registeredSchemas := GetSchemas()

        for _, schema := range registeredSchemas </span><span class="cov7" title="34">{
                for _, property := range schema.Properties </span><span class="cov0" title="0">{
                        resolvePropertyReferences(property)
                }</span>
        }
}

// resolvePropertyReferences resolves references in a single property
func resolvePropertyReferences(prop *PropertyInfo) <span class="cov1" title="1">{
        // Check if this property has items (is an array)
        if prop.Items != nil &amp;&amp; prop.Items.Name != "" </span><span class="cov0" title="0">{
                itemTypeName := prop.Items.Name

                // Check if the item type is a registered schema
                if registeredSchema := findSchemaByName(itemTypeName); registeredSchema != nil </span><span class="cov0" title="0">{
                        // Replace with schema reference
                        prop.Items = &amp;PropertyInfo{
                                Ref: fmt.Sprintf("#/components/schemas/%s", itemTypeName),
                        }
                }</span>
        }
}

// extractValidationConstraints extracts validation constraints and sets them in PropertyInfo
func extractValidationConstraints(validation string, prop *PropertyInfo) <span class="cov3" title="3">{
        if validation == "" </span><span class="cov2" title="2">{
                return
        }</span>

        // Extract min/max length for strings
        <span class="cov1" title="1">if minRegex := regexp.MustCompile(`min=(\d+)`); minRegex.MatchString(validation) </span><span class="cov1" title="1">{
                if matches := minRegex.FindStringSubmatch(validation); len(matches) &gt; 1 </span><span class="cov1" title="1">{
                        if val, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov1" title="1">{
                                switch prop.Type </span>{
                                case "string":<span class="cov0" title="0">
                                        prop.MinLength = &amp;val</span>
                                case "integer", "number":<span class="cov0" title="0">
                                        minVal := float64(val)
                                        prop.Minimum = &amp;minVal</span>
                                }
                        }
                }
        }

        <span class="cov1" title="1">if maxRegex := regexp.MustCompile(`max=(\d+)`); maxRegex.MatchString(validation) </span><span class="cov0" title="0">{
                if matches := maxRegex.FindStringSubmatch(validation); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if val, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov0" title="0">{
                                switch prop.Type </span>{
                                case "string":<span class="cov0" title="0">
                                        prop.MaxLength = &amp;val</span>
                                case "integer", "number":<span class="cov0" title="0">
                                        maxVal := float64(val)
                                        prop.Maximum = &amp;maxVal</span>
                                }
                        }
                }
        }

        // Extract enum values
        <span class="cov1" title="1">if enumRegex := regexp.MustCompile(`oneof=([^,\s]+)`); enumRegex.MatchString(validation) </span><span class="cov0" title="0">{
                if matches := enumRegex.FindStringSubmatch(validation); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        enumValues := strings.Split(matches[1], " ")
                        prop.Enum = enumValues
                }</span>
        }
}

// extractMarkersFromComment extracts markers from comment text (reused from parser.go)
func extractMarkersFromComment(commentText string) []MarkerInstance <span class="cov1" title="1">{
        var markers []MarkerInstance

        // Look for each registered marker
        for name, config := range GetMarkers() </span><span class="cov7" title="39">{
                matches := config.Pattern.FindAllStringSubmatch(commentText, -1)
                for _, match := range matches </span><span class="cov2" title="2">{
                        marker := MarkerInstance{
                                Name: name,
                                Raw:  match[0],
                        }

                        // Extract arguments if they exist
                        if len(match) &gt; 1 &amp;&amp; match[1] != "" </span><span class="cov2" title="2">{
                                marker.Args = parseArgumentsFromString(match[1])
                        }</span>

                        <span class="cov2" title="2">markers = append(markers, marker)</span>
                }
        }

        <span class="cov1" title="1">return markers</span>
}

// parseArgumentsFromString converts argument string to slice
func parseArgumentsFromString(argsStr string) []string <span class="cov3" title="3">{
        if argsStr == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="3">var args []string
        parts := strings.Split(argsStr, ",")
        for _, part := range parts </span><span class="cov4" title="6">{
                arg := strings.TrimSpace(part)
                if arg != "" </span><span class="cov4" title="6">{
                        // Remove surrounding quotes if present
                        if (strings.HasPrefix(arg, `"`) &amp;&amp; strings.HasSuffix(arg, `"`)) ||
                                (strings.HasPrefix(arg, "'") &amp;&amp; strings.HasSuffix(arg, "'")) </span><span class="cov0" title="0">{
                                arg = arg[1 : len(arg)-1]
                        }</span>
                        <span class="cov4" title="6">args = append(args, arg)</span>
                }
        }

        <span class="cov3" title="3">return args</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package decorators

import (
        "fmt"
        "net"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
)

// SecurityConfig holds security configuration for internal endpoints
type SecurityConfig struct {
        // Allowed networks in CIDR notation (e.g., "192.168.1.0/24", "10.0.0.0/8")
        AllowedNetworks []string
        // Allowed IP addresses (individual IPs)
        AllowedIPs []string
        // Allowed hostnames/domains
        AllowedHosts []string
        // Whether to allow localhost/127.0.0.1
        AllowLocalhost bool
        // Whether to allow private networks (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
        AllowPrivateNetworks bool
        // Custom error message
        ErrorMessage string
        // Whether to log blocked attempts
        LogBlockedAttempts bool
}

// DefaultSecurityConfig returns a secure default configuration
func DefaultSecurityConfig() *SecurityConfig <span class="cov5" title="7">{
        return &amp;SecurityConfig{
                AllowedNetworks:      []string{"127.0.0.1/32", "::1/128"}, // Only localhost by default
                AllowedIPs:           []string{},
                AllowedHosts:         []string{},
                AllowLocalhost:       true,
                AllowPrivateNetworks: false, // Disabled by default for security
                ErrorMessage:         "Access denied: This endpoint is restricted to internal networks",
                LogBlockedAttempts:   true,
        }
}</span>

// SecureInternalEndpoints creates a middleware to secure internal gin-decorators endpoints
func SecureInternalEndpoints(config *SecurityConfig) gin.HandlerFunc <span class="cov7" title="15">{
        if config == nil </span><span class="cov1" title="1">{
                config = DefaultSecurityConfig()
        }</span>

        // Build allowed networks list
        <span class="cov7" title="15">allowedNetworks := make([]*net.IPNet, 0)

        // Add configured networks
        for _, network := range config.AllowedNetworks </span><span class="cov7" title="14">{
                if _, ipNet, err := net.ParseCIDR(network); err == nil </span><span class="cov7" title="14">{
                        allowedNetworks = append(allowedNetworks, ipNet)
                }</span>
        }

        // Add localhost if enabled
        <span class="cov7" title="15">if config.AllowLocalhost </span><span class="cov7" title="14">{
                if _, localhostIPv4, err := net.ParseCIDR("127.0.0.1/32"); err == nil </span><span class="cov7" title="14">{
                        allowedNetworks = append(allowedNetworks, localhostIPv4)
                }</span>
                <span class="cov7" title="14">if _, localhostIPv6, err := net.ParseCIDR("::1/128"); err == nil </span><span class="cov7" title="14">{
                        allowedNetworks = append(allowedNetworks, localhostIPv6)
                }</span>
        }

        // Add private networks if enabled
        <span class="cov7" title="15">if config.AllowPrivateNetworks </span><span class="cov2" title="2">{
                privateNetworks := []string{
                        "10.0.0.0/8",     // Class A private
                        "172.16.0.0/12",  // Class B private
                        "192.168.0.0/16", // Class C private
                }
                for _, network := range privateNetworks </span><span class="cov5" title="6">{
                        if _, ipNet, err := net.ParseCIDR(network); err == nil </span><span class="cov5" title="6">{
                                allowedNetworks = append(allowedNetworks, ipNet)
                        }</span>
                }
        }

        <span class="cov7" title="15">return func(c *gin.Context) </span><span class="cov7" title="13">{
                clientIP := getClientIP(c)

                // Check if IP is allowed
                if isIPAllowed(clientIP, allowedNetworks, config.AllowedIPs) </span><span class="cov6" title="8">{
                        c.Next()
                        return
                }</span>

                // Check if hostname is allowed
                <span class="cov5" title="5">if isHostnameAllowed(c.Request.Host, config.AllowedHosts) </span><span class="cov2" title="2">{
                        c.Next()
                        return
                }</span>

                // Log blocked attempt if enabled
                <span class="cov3" title="3">if config.LogBlockedAttempts </span><span class="cov3" title="3">{
                        fmt.Printf("🔒 SECURITY: Blocked access to internal endpoint from %s (Host: %s, Path: %s)\n",
                                clientIP, c.Request.Host, c.Request.URL.Path)
                }</span>

                // Return access denied
                <span class="cov3" title="3">c.JSON(http.StatusForbidden, gin.H{
                        "error":   "access_denied",
                        "message": config.ErrorMessage,
                        "details": "This endpoint is restricted to internal networks only",
                })
                c.Abort()</span>
        }
}

// getClientIP extracts the real client IP from various headers
func getClientIP(c *gin.Context) string <span class="cov8" title="17">{
        // Check X-Forwarded-For header (common in reverse proxies)
        if forwardedFor := c.GetHeader("X-Forwarded-For"); forwardedFor != "" </span><span class="cov1" title="1">{
                // X-Forwarded-For can contain multiple IPs, take the first one
                ips := strings.Split(forwardedFor, ",")
                if len(ips) &gt; 0 </span><span class="cov1" title="1">{
                        return strings.TrimSpace(ips[0])
                }</span>
        }

        // Check X-Real-IP header
        <span class="cov7" title="16">if realIP := c.GetHeader("X-Real-IP"); realIP != "" </span><span class="cov1" title="1">{
                return realIP
        }</span>

        // Check X-Client-IP header
        <span class="cov7" title="15">if clientIP := c.GetHeader("X-Client-IP"); clientIP != "" </span><span class="cov1" title="1">{
                return clientIP
        }</span>

        // Fallback to gin's ClientIP method
        <span class="cov7" title="14">return c.ClientIP()</span>
}

// isIPAllowed checks if an IP address is in the allowed networks or IP list
func isIPAllowed(clientIP string, allowedNetworks []*net.IPNet, allowedIPs []string) bool <span class="cov8" title="17">{
        // Parse client IP
        ip := net.ParseIP(clientIP)
        if ip == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check against allowed networks
        <span class="cov7" title="16">for _, network := range allowedNetworks </span><span class="cov10" title="36">{
                if network.Contains(ip) </span><span class="cov5" title="7">{
                        return true
                }</span>
        }

        // Check against allowed individual IPs
        <span class="cov6" title="9">for _, allowedIP := range allowedIPs </span><span class="cov3" title="3">{
                if allowedIP == clientIP </span><span class="cov3" title="3">{
                        return true
                }</span>
        }

        <span class="cov5" title="6">return false</span>
}

// isHostnameAllowed checks if a hostname is in the allowed hosts list
func isHostnameAllowed(hostname string, allowedHosts []string) bool <span class="cov7" title="11">{
        if len(allowedHosts) == 0 </span><span class="cov4" title="4">{
                return false
        }</span>

        // Remove port if present
        <span class="cov5" title="7">if colonIndex := strings.Index(hostname, ":"); colonIndex != -1 </span><span class="cov1" title="1">{
                hostname = hostname[:colonIndex]
        }</span>

        <span class="cov5" title="7">for _, allowedHost := range allowedHosts </span><span class="cov5" title="7">{
                if allowedHost == hostname </span><span class="cov3" title="3">{
                        return true
                }</span>
                // Support wildcard domains (e.g., "*.example.com")
                <span class="cov4" title="4">if strings.HasPrefix(allowedHost, "*.") </span><span class="cov4" title="4">{
                        domain := strings.TrimPrefix(allowedHost, "*.")
                        if strings.HasSuffix(hostname, "."+domain) || hostname == domain </span><span class="cov3" title="3">{
                                return true
                        }</span>
                }
        }

        <span class="cov1" title="1">return false</span>
}

// Convenience functions for common security configurations

// AllowLocalhostOnly creates a middleware that only allows localhost access
func AllowLocalhostOnly() gin.HandlerFunc <span class="cov1" title="1">{
        config := &amp;SecurityConfig{
                AllowLocalhost:       true,
                AllowPrivateNetworks: false,
                ErrorMessage:         "Access denied: This endpoint is restricted to localhost only",
                LogBlockedAttempts:   true,
        }
        return SecureInternalEndpoints(config)
}</span>

// AllowPrivateNetworks creates a middleware that allows private network access
func AllowPrivateNetworks() gin.HandlerFunc <span class="cov1" title="1">{
        config := &amp;SecurityConfig{
                AllowLocalhost:       true,
                AllowPrivateNetworks: true,
                ErrorMessage:         "Access denied: This endpoint is restricted to private networks only",
                LogBlockedAttempts:   true,
        }
        return SecureInternalEndpoints(config)
}</span>

// AllowSpecificNetworks creates a middleware that allows specific networks
func AllowSpecificNetworks(networks []string) gin.HandlerFunc <span class="cov1" title="1">{
        config := &amp;SecurityConfig{
                AllowedNetworks:      networks,
                AllowLocalhost:       true,
                AllowPrivateNetworks: false,
                ErrorMessage:         "Access denied: This endpoint is restricted to authorized networks only",
                LogBlockedAttempts:   true,
        }
        return SecureInternalEndpoints(config)
}</span>

// AllowSpecificIPs creates a middleware that allows specific IP addresses
func AllowSpecificIPs(ips []string) gin.HandlerFunc <span class="cov1" title="1">{
        config := &amp;SecurityConfig{
                AllowedIPs:           ips,
                AllowLocalhost:       true,
                AllowPrivateNetworks: false,
                ErrorMessage:         "Access denied: This endpoint is restricted to authorized IPs only",
                LogBlockedAttempts:   true,
        }
        return SecureInternalEndpoints(config)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package decorators

import (
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/hashicorp/consul/api"
)

// ConsulDiscovery implements service discovery using Consul
type ConsulDiscovery struct {
        address string
        client  *api.Client
}

// NewConsulDiscovery creates a new Consul service discovery
func NewConsulDiscovery(address string) *ConsulDiscovery <span class="cov7" title="4">{
        if address == "" </span><span class="cov1" title="1">{
                address = "localhost:8500"
        }</span>

        <span class="cov7" title="4">config := api.DefaultConfig()
        config.Address = address

        client, err := api.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                LogVerbose("Failed to create Consul client: %v", err)
                return &amp;ConsulDiscovery{address: address}
        }</span>

        <span class="cov7" title="4">return &amp;ConsulDiscovery{
                address: address,
                client:  client,
        }</span>
}

// Discover discovers service instances using Consul
func (cd *ConsulDiscovery) Discover(service string) ([]*ProxyInstance, error) <span class="cov6" title="3">{
        if cd.client == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("Consul client not available")
        }</span>

        // Query Consul for service instances
        <span class="cov4" title="2">services, _, err := cd.client.Health().Service(service, "", true, nil)
        if err != nil </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("failed to query Consul: %v", err)
        }</span>

        <span class="cov0" title="0">instances := make([]*ProxyInstance, 0, len(services))
        for _, service := range services </span><span class="cov0" title="0">{
                instance := &amp;ProxyInstance{
                        URL:       fmt.Sprintf("http://%s:%d", service.Service.Address, service.Service.Port),
                        Weight:    1,
                        Healthy:   true,
                        LastCheck: time.Now(),
                        Metadata:  make(map[string]string),
                }

                // Add service metadata
                for key, value := range service.Service.Meta </span><span class="cov0" title="0">{
                        instance.Metadata[key] = value
                }</span>

                <span class="cov0" title="0">instances = append(instances, instance)</span>
        }

        <span class="cov0" title="0">return instances, nil</span>
}

// DNSDiscovery implements service discovery using DNS
type DNSDiscovery struct{}

// NewDNSDiscovery creates a new DNS service discovery
func NewDNSDiscovery() *DNSDiscovery <span class="cov7" title="4">{
        return &amp;DNSDiscovery{}
}</span>

// Discover discovers service instances using DNS
func (dd *DNSDiscovery) Discover(service string) ([]*ProxyInstance, error) <span class="cov7" title="4">{
        // Resolve DNS
        ips, err := net.LookupIP(service)
        if err != nil </span><span class="cov6" title="3">{
                return nil, fmt.Errorf("failed to resolve DNS for %s: %v", service, err)
        }</span>

        <span class="cov1" title="1">instances := make([]*ProxyInstance, 0, len(ips))
        for _, ip := range ips </span><span class="cov4" title="2">{
                // Assume HTTP on port 80 for DNS discovery
                instance := &amp;ProxyInstance{
                        URL:       fmt.Sprintf("http://%s:80", ip.String()),
                        Weight:    1,
                        Healthy:   true,
                        LastCheck: time.Now(),
                        Metadata:  make(map[string]string),
                }
                instances = append(instances, instance)
        }</span>

        <span class="cov1" title="1">return instances, nil</span>
}

// K8sDiscovery implements service discovery using Kubernetes
type K8sDiscovery struct {
        namespace string
}

// NewK8sDiscovery creates a new Kubernetes service discovery
func NewK8sDiscovery(namespace string) *K8sDiscovery <span class="cov9" title="6">{
        if namespace == "" </span><span class="cov1" title="1">{
                namespace = "default"
        }</span>

        <span class="cov9" title="6">return &amp;K8sDiscovery{
                namespace: namespace,
        }</span>
}

// Discover discovers service instances using Kubernetes
func (kd *K8sDiscovery) Discover(service string) ([]*ProxyInstance, error) <span class="cov8" title="5">{
        // For now, implement a simple DNS-based approach for Kubernetes
        // In a real implementation, you would use the Kubernetes API
        k8sServiceName := fmt.Sprintf("%s.%s.svc.cluster.local", service, kd.namespace)

        // Resolve the Kubernetes service DNS
        ips, err := net.LookupIP(k8sServiceName)
        if err != nil </span><span class="cov8" title="5">{
                return nil, fmt.Errorf("failed to resolve Kubernetes service %s: %v", k8sServiceName, err)
        }</span>

        <span class="cov0" title="0">instances := make([]*ProxyInstance, 0, len(ips))
        for _, ip := range ips </span><span class="cov0" title="0">{
                // Assume HTTP on port 80 for Kubernetes services
                instance := &amp;ProxyInstance{
                        URL:       fmt.Sprintf("http://%s:80", ip.String()),
                        Weight:    1,
                        Healthy:   true,
                        LastCheck: time.Now(),
                        Metadata: map[string]string{
                                "namespace": kd.namespace,
                                "service":   service,
                        },
                }
                instances = append(instances, instance)
        }</span>

        <span class="cov0" title="0">return instances, nil</span>
}

// StaticDiscovery implements static service discovery
type StaticDiscovery struct {
        targets []string
}

// NewStaticDiscovery creates a new static service discovery
func NewStaticDiscovery(targets []string) *StaticDiscovery <span class="cov9" title="6">{
        return &amp;StaticDiscovery{
                targets: targets,
        }
}</span>

// Discover returns the static targets as instances
func (sd *StaticDiscovery) Discover(_ string) ([]*ProxyInstance, error) <span class="cov8" title="5">{
        instances := make([]*ProxyInstance, 0, len(sd.targets))

        for _, target := range sd.targets </span><span class="cov10" title="7">{
                instance := &amp;ProxyInstance{
                        URL:       strings.TrimSpace(target),
                        Weight:    1,
                        Healthy:   true,
                        LastCheck: time.Now(),
                        Metadata: map[string]string{
                                "discovery": "static",
                        },
                }
                instances = append(instances, instance)
        }</span>

        <span class="cov8" title="5">return instances, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package decorators

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/codes"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
        "go.opentelemetry.io/otel/trace"
)

// TelemetryManager manages OpenTelemetry configuration and instrumentation
type TelemetryManager struct {
        tracer   trace.Tracer
        config   TelemetryConfig
        provider *sdktrace.TracerProvider
}

// TracingInfo information about tracing for documentation
type TracingInfo struct {
        Enabled        bool              `json:"enabled"`
        ServiceName    string            `json:"service_name"`
        ServiceVersion string            `json:"service_version"`
        Environment    string            `json:"environment"`
        Endpoint       string            `json:"endpoint"`
        SampleRate     float64           `json:"sample_rate"`
        Attributes     map[string]string `json:"attributes"`
}

// defaultTelemetryManager global instance
var (
        defaultTelemetryManager *TelemetryManager
        telemetryMutex          sync.RWMutex
)

// InitTelemetry initializes OpenTelemetry
func InitTelemetry(config *TelemetryConfig) (*TelemetryManager, error) <span class="cov3" title="2">{
        if !config.Enabled </span><span class="cov1" title="1">{
                return &amp;TelemetryManager{config: *config}, nil
        }</span>

        // Configure resource
        <span class="cov1" title="1">res, err := resource.New(context.Background(),
                resource.WithAttributes(
                        semconv.ServiceName(config.ServiceName),
                        semconv.ServiceVersion(config.ServiceVersion),
                        semconv.DeploymentEnvironment(config.Environment),
                ),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating resource: %v", err)
        }</span>

        // Configure exporter OTLP
        <span class="cov1" title="1">var opts []otlptracehttp.Option
        opts = append(opts, otlptracehttp.WithEndpoint(config.Endpoint))
        if config.Insecure </span><span class="cov1" title="1">{
                opts = append(opts, otlptracehttp.WithInsecure())
        }</span>

        <span class="cov1" title="1">exporter, err := otlptracehttp.New(context.Background(), opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating exporter: %v", err)
        }</span>

        // Configure trace provider
        <span class="cov1" title="1">provider := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(res),
                sdktrace.WithSampler(sdktrace.TraceIDRatioBased(config.SampleRate)),
        )

        // Configure propagation
        otel.SetTracerProvider(provider)
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        // Create tracer
        tracer := otel.Tracer("gin-decorators")

        manager := &amp;TelemetryManager{
                tracer:   tracer,
                config:   *config,
                provider: provider,
        }

        telemetryMutex.Lock()
        defaultTelemetryManager = manager
        telemetryMutex.Unlock()
        return manager, nil</span>
}

// Shutdown finaliza telemetria
func (tm *TelemetryManager) Shutdown(ctx context.Context) error <span class="cov1" title="1">{
        if tm.provider != nil </span><span class="cov0" title="0">{
                return tm.provider.Shutdown(ctx)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// TracingMiddleware main tracing middleware
func TracingMiddleware(config *TelemetryConfig) gin.HandlerFunc <span class="cov8" title="9">{
        if !config.Enabled </span><span class="cov7" title="6">{
                return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov7" title="6">{
                        c.Next()
                }</span>)
        }

        // Initialize if necessary
        <span class="cov4" title="3">telemetryMutex.RLock()
        manager := defaultTelemetryManager
        telemetryMutex.RUnlock()

        if manager == nil </span><span class="cov0" title="0">{
                telemetryMutex.Lock()
                // Double-check after acquiring lock
                if defaultTelemetryManager == nil </span><span class="cov0" title="0">{
                        var err error
                        manager, err = InitTelemetry(config)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log error and continue without tracing
                                fmt.Printf("Error ao inicializar telemetria: %v\n", err)
                                telemetryMutex.Unlock()
                                return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                                        c.Next()
                                }</span>)
                        }
                        <span class="cov0" title="0">defaultTelemetryManager = manager</span>
                } else<span class="cov0" title="0"> {
                        manager = defaultTelemetryManager
                }</span>
                <span class="cov0" title="0">telemetryMutex.Unlock()</span>
        }

        <span class="cov4" title="3">return func(c *gin.Context) </span><span class="cov4" title="3">{
                // Extract contexto de tracing dos headers
                ctx := otel.GetTextMapPropagator().Extract(
                        c.Request.Context(),
                        propagation.HeaderCarrier(c.Request.Header),
                )

                // Create span
                spanName := fmt.Sprintf("%s %s", c.Request.Method, c.FullPath())
                if c.FullPath() == "" </span><span class="cov0" title="0">{
                        spanName = fmt.Sprintf("%s %s", c.Request.Method, c.Request.URL.Path)
                }</span>

                <span class="cov4" title="3">ctx, span := manager.tracer.Start(ctx, spanName)
                defer span.End()

                // Add atributos ao span
                span.SetAttributes(
                        semconv.HTTPMethod(c.Request.Method),
                        semconv.HTTPTarget(c.Request.URL.Path),
                        semconv.HTTPRoute(c.FullPath()),
                        semconv.HTTPScheme(c.Request.URL.Scheme),
                        attribute.String("http.host", c.Request.Host),
                        semconv.HTTPUserAgent(c.Request.UserAgent()),
                        attribute.String("http.client_ip", c.ClientIP()),
                )

                // Add headers customizados
                if requestID := c.GetHeader("X-Request-ID"); requestID != "" </span><span class="cov1" title="1">{
                        span.SetAttributes(attribute.String("http.request.id", requestID))
                }</span>

                <span class="cov4" title="3">if userID := c.GetString("user_id"); userID != "" </span><span class="cov0" title="0">{
                        span.SetAttributes(attribute.String("user.id", userID))
                }</span>

                // Update context in request
                <span class="cov4" title="3">c.Request = c.Request.WithContext(ctx)

                // Inject tracing headers in response
                otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(c.Writer.Header()))

                // Continue processing
                c.Next()

                // Add response information
                span.SetAttributes(
                        semconv.HTTPStatusCode(c.Writer.Status()),
                        attribute.Int("http.response.size", c.Writer.Size()),
                )

                // Define span status based on HTTP code
                if c.Writer.Status() &gt;= 400 </span><span class="cov1" title="1">{
                        span.SetStatus(codes.Error, http.StatusText(c.Writer.Status()))
                }</span> else<span class="cov3" title="2"> {
                        span.SetStatus(codes.Ok, "")
                }</span>

                // Add errors se houver
                <span class="cov4" title="3">if len(c.Errors) &gt; 0 </span><span class="cov1" title="1">{
                        span.SetStatus(codes.Error, c.Errors.String())
                        span.SetAttributes(attribute.String("error.message", c.Errors.String()))
                }</span>
        }
}

// StartSpan starts a new span
func StartSpan(ctx context.Context, name string) (context.Context, trace.Span) <span class="cov10" title="12">{
        telemetryMutex.RLock()
        manager := defaultTelemetryManager
        telemetryMutex.RUnlock()

        if manager == nil </span><span class="cov6" title="4">{
                return ctx, trace.SpanFromContext(ctx)
        }</span>
        <span class="cov8" title="8">return manager.tracer.Start(ctx, name)</span>
}

// SpanFromContext extracts span from context
func SpanFromContext(ctx context.Context) trace.Span <span class="cov1" title="1">{
        return trace.SpanFromContext(ctx)
}</span>

// AddSpanAttributes adds attributes to current span
func AddSpanAttributes(ctx context.Context, attrs ...attribute.KeyValue) <span class="cov1" title="1">{
        span := trace.SpanFromContext(ctx)
        if span.IsRecording() </span><span class="cov0" title="0">{
                span.SetAttributes(attrs...)
        }</span>
}

// AddSpanEvent adds event to current span
func AddSpanEvent(ctx context.Context, name string, attrs ...attribute.KeyValue) <span class="cov1" title="1">{
        span := trace.SpanFromContext(ctx)
        if span.IsRecording() </span><span class="cov0" title="0">{
                span.AddEvent(name, trace.WithAttributes(attrs...))
        }</span>
}

// SetSpanError marca span como error
func SetSpanError(ctx context.Context, err error) <span class="cov1" title="1">{
        span := trace.SpanFromContext(ctx)
        if span.IsRecording() </span><span class="cov0" title="0">{
                span.SetStatus(codes.Error, err.Error())
                span.SetAttributes(attribute.String("error.message", err.Error()))
        }</span>
}

// TraceMiddleware instrumenta middleware individual
func TraceMiddleware(middlewareName string) gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov4" title="3">{
                if defaultTelemetryManager == nil </span><span class="cov3" title="2">{
                        c.Next()
                        return
                }</span>

                <span class="cov1" title="1">ctx, span := StartSpan(c.Request.Context(), fmt.Sprintf("middleware.%s", middlewareName))
                defer span.End()

                span.SetAttributes(
                        attribute.String("middleware.name", middlewareName),
                        attribute.String("http.method", c.Request.Method),
                        attribute.String("http.route", c.FullPath()),
                )

                c.Request = c.Request.WithContext(ctx)
                start := time.Now()

                c.Next()

                duration := time.Since(start)
                span.SetAttributes(
                        attribute.Float64("middleware.duration_ms", float64(duration.Nanoseconds())/1e6),
                )

                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        SetSpanError(ctx, c.Errors.Last())
                }</span>
        }
}

// TraceCacheOperation instruments cache operations
func TraceCacheOperation(ctx context.Context, operation, cacheType, key string) (context.Context, trace.Span) <span class="cov1" title="1">{
        if defaultTelemetryManager == nil </span><span class="cov0" title="0">{
                return ctx, trace.SpanFromContext(ctx)
        }</span>

        <span class="cov1" title="1">ctx, span := StartSpan(ctx, fmt.Sprintf("cache.%s", operation))
        span.SetAttributes(
                attribute.String("cache.operation", operation),
                attribute.String("cache.type", cacheType),
                attribute.String("cache.key", key),
        )

        return ctx, span</span>
}

// TraceRateLimitOperation instruments rate limit operations
func TraceRateLimitOperation(ctx context.Context, operation, limitType string, allowed bool) (context.Context, trace.Span) <span class="cov1" title="1">{
        if defaultTelemetryManager == nil </span><span class="cov0" title="0">{
                return ctx, trace.SpanFromContext(ctx)
        }</span>

        <span class="cov1" title="1">ctx, span := StartSpan(ctx, fmt.Sprintf("ratelimit.%s", operation))
        span.SetAttributes(
                attribute.String("ratelimit.operation", operation),
                attribute.String("ratelimit.type", limitType),
                attribute.Bool("ratelimit.allowed", allowed),
        )

        return ctx, span</span>
}

// TraceValidationOperation instruments validation operations
func TraceValidationOperation(ctx context.Context, validationType string, fieldCount int) (context.Context, trace.Span) <span class="cov1" title="1">{
        if defaultTelemetryManager == nil </span><span class="cov0" title="0">{
                return ctx, trace.SpanFromContext(ctx)
        }</span>

        <span class="cov1" title="1">ctx, span := StartSpan(ctx, fmt.Sprintf("validation.%s", validationType))
        span.SetAttributes(
                attribute.String("validation.type", validationType),
                attribute.Int("validation.field_count", fieldCount),
        )

        return ctx, span</span>
}

// TraceWebSocketOperation instruments WebSocket operations
func TraceWebSocketOperation(ctx context.Context, operation, connectionID string) (context.Context, trace.Span) <span class="cov1" title="1">{
        if defaultTelemetryManager == nil </span><span class="cov0" title="0">{
                return ctx, trace.SpanFromContext(ctx)
        }</span>

        <span class="cov1" title="1">ctx, span := StartSpan(ctx, fmt.Sprintf("websocket.%s", operation))
        span.SetAttributes(
                attribute.String("websocket.operation", operation),
                attribute.String("websocket.connection_id", connectionID),
        )

        return ctx, span</span>
}

// GetTracingInfo returns information about tracing configuration
func GetTracingInfo(config *TelemetryConfig) TracingInfo <span class="cov1" title="1">{
        info := TracingInfo{
                Enabled:        config.Enabled,
                ServiceName:    config.ServiceName,
                ServiceVersion: config.ServiceVersion,
                Environment:    config.Environment,
                Endpoint:       config.Endpoint,
                SampleRate:     config.SampleRate,
                Attributes:     make(map[string]string),
        }

        // Add atributos default
        info.Attributes["service.name"] = config.ServiceName
        info.Attributes["service.version"] = config.ServiceVersion
        info.Attributes["deployment.environment"] = config.Environment

        return info
}</span>

// TracingStatsHandler handler for tracing statistics
func TracingStatsHandler() gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov4" title="3">{
                stats := map[string]interface{}{
                        "enabled": false,
                }

                if defaultTelemetryManager != nil </span><span class="cov1" title="1">{
                        stats["enabled"] = defaultTelemetryManager.config.Enabled
                        stats["service_name"] = defaultTelemetryManager.config.ServiceName
                        stats["service_version"] = defaultTelemetryManager.config.ServiceVersion
                        stats["environment"] = defaultTelemetryManager.config.Environment
                        stats["sample_rate"] = defaultTelemetryManager.config.SampleRate
                }</span>

                <span class="cov4" title="3">c.JSON(http.StatusOK, gin.H{
                        "tracing_stats": stats,
                })</span>
        }
}

// createTelemetryMiddleware creates telemetry middleware with customizable settings via args
func createTelemetryMiddleware(args []string) gin.HandlerFunc <span class="cov6" title="5">{
        config := DefaultConfig().Telemetry

        // Parse custom settings from args
        for _, arg := range args </span><span class="cov4" title="3">{
                if strings.HasPrefix(arg, "sampleRate=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "sampleRate=")
                        if rate, err := strconv.ParseFloat(v, 64); err == nil &amp;&amp; rate &gt;= 0 &amp;&amp; rate &lt;= 1 </span><span class="cov0" title="0">{
                                config.SampleRate = rate
                        }</span>
                }
                <span class="cov4" title="3">if strings.HasPrefix(arg, "serviceName=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "serviceName=")
                        config.ServiceName = v
                }</span>
                <span class="cov4" title="3">if strings.HasPrefix(arg, "environment=") </span><span class="cov0" title="0">{
                        v := strings.TrimPrefix(arg, "environment=")
                        config.Environment = v
                }</span>
                <span class="cov4" title="3">if strings.HasPrefix(arg, "endpoint=") </span><span class="cov1" title="1">{
                        v := strings.TrimPrefix(arg, "endpoint=")
                        config.Endpoint = v
                }</span>
        }

        <span class="cov6" title="5">return TracingMiddleware(&amp;config)</span>
}

// HealthCheckWithTracing instrumented health check
func HealthCheckWithTracing() gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov4" title="3">{
                ctx, span := StartSpan(c.Request.Context(), "health_check")
                defer span.End()

                c.Request = c.Request.WithContext(ctx)

                // Verify components
                components := map[string]string{
                        "server": "healthy",
                }

                if defaultTelemetryManager != nil </span><span class="cov1" title="1">{
                        components["tracing"] = "healthy"
                        span.SetAttributes(attribute.String("health.tracing", "enabled"))
                }</span> else<span class="cov3" title="2"> {
                        components["tracing"] = "disabled"
                        span.SetAttributes(attribute.String("health.tracing", "disabled"))
                }</span>

                <span class="cov4" title="3">span.SetAttributes(
                        attribute.String("health.status", "healthy"),
                        attribute.Int("health.components", len(components)),
                )

                c.JSON(http.StatusOK, gin.H{
                        "status":     "healthy",
                        "timestamp":  time.Now().Unix(),
                        "components": components,
                        "trace_id":   span.SpanContext().TraceID().String(),
                })</span>
        }
}

// InstrumentedHandler wrapper to instrument custom handlers
func InstrumentedHandler(handlerName string, handler gin.HandlerFunc) gin.HandlerFunc <span class="cov4" title="3">{
        return func(c *gin.Context) </span><span class="cov4" title="3">{
                ctx, span := StartSpan(c.Request.Context(), fmt.Sprintf("handler.%s", handlerName))
                defer span.End()

                span.SetAttributes(
                        attribute.String("handler.name", handlerName),
                        attribute.String("http.method", c.Request.Method),
                        attribute.String("http.route", c.FullPath()),
                )

                c.Request = c.Request.WithContext(ctx)
                start := time.Now()

                handler(c)

                duration := time.Since(start)
                span.SetAttributes(
                        attribute.Float64("handler.duration_ms", float64(duration.Nanoseconds())/1e6),
                        attribute.Int("http.status_code", c.Writer.Status()),
                )

                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        SetSpanError(ctx, c.Errors.Last())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package decorators

import (
        "sync"
        "testing"

        "github.com/gin-gonic/gin"
)

var (
        ginModeMutex sync.Mutex
        ginModeSet   bool
)

// setupGinTestMode sets Gin to test mode in a thread-safe way
func setupGinTestMode(_ *testing.T) <span class="cov10" title="28">{
        ginModeMutex.Lock()
        defer ginModeMutex.Unlock()

        if !ginModeSet </span><span class="cov1" title="1">{
                gin.SetMode(gin.TestMode)
                ginModeSet = true
        }</span>
}

// createTestGinContext creates a test Gin context with proper setup
// This function is kept for future use in more complex test scenarios

// createTestGinEngine creates a test Gin engine with proper setup
func createTestGinEngine(t *testing.T) *gin.Engine <span class="cov9" title="20">{
        setupGinTestMode(t)
        return gin.New()
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package decorators

import (
        "fmt"

        "github.com/gin-gonic/gin"
)

// Route represents a route extracted from parsing
type Route struct {
        Method      string            `json:"method"`
        Path        string            `json:"path"`
        Handler     gin.HandlerFunc   `json:"-"`
        Middlewares []gin.HandlerFunc `json:"-"`
}

// MiddlewareInfo information about middlewares aplicados
type MiddlewareInfo struct {
        Name        string                 `json:"name"`
        Args        map[string]interface{} `json:"args"`
        Order       int                    `json:"order"`
        Description string                 `json:"description"`
}

// FrameworkStats statistics do framework
type FrameworkStats struct {
        TotalRoutes       int            `json:"total_routes"`
        UniqueMiddlewares int            `json:"unique_middlewares"`
        PackagesScanned   int            `json:"packages_scanned"`
        BuildMode         string         `json:"build_mode"` // "development" ou "production"
        GeneratedAt       string         `json:"generated_at"`
        Methods           map[string]int `json:"methods"` // GET: 5, POST: 3, etc.
}

// ValidationError validation error during parsing or generation
type ValidationError struct {
        File    string `json:"file"`
        Line    int    `json:"line"`
        Message string `json:"message"`
        Code    string `json:"code"`
}

func (e ValidationError) Error() string <span class="cov10" title="3">{
        if e.Line &gt; 0 </span><span class="cov6" title="2">{
                return fmt.Sprintf("%s:%d - %s", e.File, e.Line, e.Message)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%s - %s", e.File, e.Message)</span>
}

// ParserStats statistics do processo de parsing
type ParserStats struct {
        FilesProcessed  int               `json:"files_processed"`
        RoutesFound     int               `json:"routes_found"`
        MarkersApplied  int               `json:"markers_applied"`
        Errors          []ValidationError `json:"errors"`
        Warnings        []ValidationError `json:"warnings"`
        ProcessingTime  string            `json:"processing_time"`
        SourceDirectory string            `json:"source_directory"`
}

// SchemaInfo information about a registered schema/entity
type SchemaInfo struct {
        Name        string                   `json:"name"`
        Description string                   `json:"description"`
        Type        string                   `json:"type"` // "object", "array", etc.
        Properties  map[string]*PropertyInfo `json:"properties,omitempty"`
        Required    []string                 `json:"required,omitempty"`
        Example     interface{}              `json:"example,omitempty"`
        PackageName string                   `json:"package_name"`
        FileName    string                   `json:"file_name"`
}

// PropertyInfo information about a schema property
type PropertyInfo struct {
        Name        string        `json:"name"`
        Type        string        `json:"type,omitempty"`
        Format      string        `json:"format,omitempty"`
        Description string        `json:"description,omitempty"`
        Example     interface{}   `json:"example,omitempty"`
        Required    bool          `json:"required"`
        Enum        []string      `json:"enum,omitempty"`
        MinLength   *int          `json:"min_length,omitempty"`
        MaxLength   *int          `json:"max_length,omitempty"`
        Minimum     *float64      `json:"minimum,omitempty"`
        Maximum     *float64      `json:"maximum,omitempty"`
        Items       *PropertyInfo `json:"items,omitempty"` // For array types
        Ref         string        `json:"$ref,omitempty"`  // For schema references
}

// EntityMeta represents metadata of an entity/struct extracted from comments
type EntityMeta struct {
        Name        string           `json:"name"`
        PackageName string           `json:"package_name"`
        FileName    string           `json:"file_name"`
        Markers     []MarkerInstance `json:"markers"`
        Fields      []FieldMeta      `json:"fields"`

        // Documentation information
        Description string                 `json:"description"`
        Example     map[string]interface{} `json:"example,omitempty"`
}

// FieldMeta represents metadata of a struct field
type FieldMeta struct {
        Name        string      `json:"name"`
        Type        string      `json:"type"`
        JSONTag     string      `json:"json_tag"`
        Description string      `json:"description"`
        Example     interface{} `json:"example,omitempty"`
        Validation  string      `json:"validation,omitempty"` // from validate tags
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package decorators

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
)

// Validator global validator instance
var validate *validator.Validate

// init initializes the validator
func init() <span class="cov1" title="1">{
        validate = validator.New()

        // Register custom validators
        if err := validate.RegisterValidation("phone", validatePhone); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to register phone validation: %v", err)
        }</span>
        <span class="cov1" title="1">if err := validate.RegisterValidation("cpf", validateCPF); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to register CPF validation: %v", err)
        }</span>
        <span class="cov1" title="1">if err := validate.RegisterValidation("cnpj", validateCNPJ); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to register CNPJ validation: %v", err)
        }</span>
        <span class="cov1" title="1">if err := validate.RegisterValidation("datetime", validateDateTime); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to register datetime validation: %v", err)
        }</span>
}

// ValidationResponse validation error response
type ValidationResponse struct {
        Error   string                 `json:"error"`
        Message string                 `json:"message"`
        Fields  []ValidationField      `json:"fields,omitempty"`
        Details map[string]interface{} `json:"details,omitempty"`
}

// ValidationField field-specific error
type ValidationField struct {
        Field   string `json:"field"`
        Value   string `json:"value"`
        Tag     string `json:"tag"`
        Message string `json:"message"`
        Param   string `json:"param,omitempty"`
}

// ValidateStruct middleware for automatic struct validation
func ValidateStruct(config *ValidationConfig) gin.HandlerFunc <span class="cov2" title="3">{
        return func(c *gin.Context) </span><span class="cov2" title="3">{
                // Continue processing
                c.Next()

                // If there are no binding errors, we do not need to validate
                if len(c.Errors) == 0 </span><span class="cov2" title="3">{
                        return
                }</span>

                // Process validation errors
                <span class="cov0" title="0">var validationErrors []ValidationField

                for _, err := range c.Errors </span><span class="cov0" title="0">{
                        if validatorErr, ok := err.Err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                                for _, fieldErr := range validatorErr </span><span class="cov0" title="0">{
                                        validationErrors = append(validationErrors, ValidationField{
                                                Field:   fieldErr.Field(),
                                                Value:   fmt.Sprintf("%v", fieldErr.Value()),
                                                Tag:     fieldErr.Tag(),
                                                Message: getValidationMessage(fieldErr, config),
                                                Param:   fieldErr.Param(),
                                        })
                                }</span>
                        }
                }

                <span class="cov0" title="0">if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                        response := ValidationResponse{
                                Error:   "validation_failed",
                                Message: "Invalid data provided",
                                Fields:  validationErrors,
                        }

                        c.AbortWithStatusJSON(http.StatusBadRequest, response)
                        return
                }</span>
        }
}

// ValidateJSON middleware for automatic JSON validation
func ValidateJSON(target interface{}, config *ValidationConfig) gin.HandlerFunc <span class="cov4" title="14">{
        return func(c *gin.Context) </span><span class="cov10" title="1024">{
                // Create a new instance of the target type
                targetType := reflect.TypeOf(target)
                if targetType.Kind() == reflect.Ptr </span><span class="cov10" title="1024">{
                        targetType = targetType.Elem()
                }</span>

                <span class="cov10" title="1024">newInstance := reflect.New(targetType).Interface()

                // Parse JSON manually to avoid Gin's built-in validation
                body, err := io.ReadAll(c.Request.Body)
                if err != nil </span><span class="cov0" title="0">{
                        response := ValidationResponse{
                                Error:   "validation_failed",
                                Message: "Failed to read request body",
                                Fields: []ValidationField{
                                        {
                                                Field:   "body",
                                                Message: "Failed to read request body",
                                        },
                                },
                        }
                        c.AbortWithStatusJSON(http.StatusBadRequest, response)
                        return
                }</span>

                // Parse JSON
                <span class="cov10" title="1024">if err := json.Unmarshal(body, newInstance); err != nil </span><span class="cov2" title="4">{
                        response := ValidationResponse{
                                Error:   "validation_failed",
                                Message: "Invalid JSON format",
                                Fields: []ValidationField{
                                        {
                                                Field:   "json",
                                                Message: "Invalid JSON format",
                                        },
                                },
                        }
                        c.AbortWithStatusJSON(http.StatusBadRequest, response)
                        return
                }</span>

                // Validate the instance using our custom validator
                <span class="cov9" title="1020">if err := validate.Struct(newInstance); err != nil </span><span class="cov3" title="7">{
                        var validationErrors []ValidationField

                        if validatorErr, ok := err.(validator.ValidationErrors); ok </span><span class="cov3" title="7">{
                                for _, fieldErr := range validatorErr </span><span class="cov5" title="47">{
                                        validationErrors = append(validationErrors, ValidationField{
                                                Field:   fieldErr.Field(),
                                                Value:   fmt.Sprintf("%v", fieldErr.Value()),
                                                Tag:     fieldErr.Tag(),
                                                Message: getValidationMessage(fieldErr, config),
                                                Param:   fieldErr.Param(),
                                        })
                                }</span>
                        }

                        <span class="cov3" title="7">if len(validationErrors) &gt; 0 </span><span class="cov3" title="7">{
                                response := ValidationResponse{
                                        Error:   "validation_failed",
                                        Message: "Invalid data provided",
                                        Fields:  validationErrors,
                                }

                                c.AbortWithStatusJSON(http.StatusBadRequest, response)
                                return
                        }</span>
                }

                // Save in context for later use
                <span class="cov9" title="1013">c.Set("validated_data", newInstance)
                c.Next()</span>
        }
}

// ValidateQuery middleware for query parameter validation
func ValidateQuery(target interface{}, config *ValidationConfig) gin.HandlerFunc <span class="cov2" title="4">{
        return func(c *gin.Context) </span><span class="cov2" title="4">{
                targetType := reflect.TypeOf(target)
                if targetType.Kind() == reflect.Ptr </span><span class="cov2" title="4">{
                        targetType = targetType.Elem()
                }</span>

                <span class="cov2" title="4">newInstance := reflect.New(targetType).Interface()

                // Bind the query parameters
                if err := c.ShouldBindQuery(newInstance); err != nil </span><span class="cov1" title="1">{
                        var validationErrors []ValidationField

                        if validatorErr, ok := err.(validator.ValidationErrors); ok </span><span class="cov1" title="1">{
                                for _, fieldErr := range validatorErr </span><span class="cov2" title="4">{
                                        validationErrors = append(validationErrors, ValidationField{
                                                Field:   fieldErr.Field(),
                                                Value:   fmt.Sprintf("%v", fieldErr.Value()),
                                                Tag:     fieldErr.Tag(),
                                                Message: getValidationMessage(fieldErr, config),
                                                Param:   fieldErr.Param(),
                                        })
                                }</span>
                        }

                        <span class="cov1" title="1">response := ValidationResponse{
                                Error:   "validation_failed",
                                Message: "Invalid query parameters",
                                Fields:  validationErrors,
                        }

                        c.AbortWithStatusJSON(http.StatusBadRequest, response)
                        return</span>
                }

                // Additional validation using our custom validator
                <span class="cov2" title="3">if err := validate.Struct(newInstance); err != nil </span><span class="cov0" title="0">{
                        var validationErrors []ValidationField

                        if validatorErr, ok := err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                                for _, fieldErr := range validatorErr </span><span class="cov0" title="0">{
                                        validationErrors = append(validationErrors, ValidationField{
                                                Field:   fieldErr.Field(),
                                                Value:   fmt.Sprintf("%v", fieldErr.Value()),
                                                Tag:     fieldErr.Tag(),
                                                Message: getValidationMessage(fieldErr, config),
                                                Param:   fieldErr.Param(),
                                        })
                                }</span>
                        }

                        <span class="cov0" title="0">if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                                response := ValidationResponse{
                                        Error:   "validation_failed",
                                        Message: "Invalid query parameters",
                                        Fields:  validationErrors,
                                }

                                c.AbortWithStatusJSON(http.StatusBadRequest, response)
                                return
                        }</span>
                }

                // Save no contexto
                <span class="cov2" title="3">c.Set("validated_query", newInstance)
                c.Next()</span>
        }
}

// ValidateParams middleware for path parameter validation
func ValidateParams(rules map[string]string, config *ValidationConfig) gin.HandlerFunc <span class="cov3" title="6">{
        return func(c *gin.Context) </span><span class="cov3" title="6">{
                var validationErrors []ValidationField

                for param, rule := range rules </span><span class="cov3" title="7">{
                        // Try URL parameter first, then query parameter
                        value := c.Param(param)
                        if value == "" </span><span class="cov3" title="7">{
                                value = c.Query(param)
                        }</span>

                        // Check if parameter is required
                        <span class="cov3" title="7">if strings.Contains(rule, "required") &amp;&amp; value == "" </span><span class="cov0" title="0">{
                                validationErrors = append(validationErrors, ValidationField{
                                        Field:   param,
                                        Value:   "",
                                        Tag:     "required",
                                        Message: getValidationMessageForParam(param, "required", "", config),
                                })
                                continue</span>
                        }

                        // If value is empty and not required, skip validation
                        <span class="cov3" title="7">if value == "" </span><span class="cov1" title="2">{
                                continue</span>
                        }

                        // Validate based on the rule (remove "required" from rule for validation)
                        <span class="cov3" title="5">validationRule := strings.Replace(rule, "required,", "", 1)
                        validationRule = strings.Replace(validationRule, ",required", "", 1)

                        if !validateParamValue(value, validationRule) </span><span class="cov0" title="0">{
                                validationErrors = append(validationErrors, ValidationField{
                                        Field:   param,
                                        Value:   value,
                                        Tag:     validationRule,
                                        Message: getValidationMessageForParam(param, validationRule, value, config),
                                })
                        }</span>
                }

                <span class="cov3" title="6">if len(validationErrors) &gt; 0 </span><span class="cov0" title="0">{
                        response := ValidationResponse{
                                Error:   "validation_failed",
                                Message: "Invalid parameters",
                                Fields:  validationErrors,
                        }

                        c.AbortWithStatusJSON(http.StatusBadRequest, response)
                        return
                }</span>

                <span class="cov3" title="6">c.Next()</span>
        }
}

// getValidationMessage returns custom error message
func getValidationMessage(fieldErr validator.FieldError, config *ValidationConfig) string <span class="cov6" title="51">{
        field := fieldErr.Field()
        tag := fieldErr.Tag()
        param := fieldErr.Param()

        // Use custom error format if specified in config
        if config.ErrorFormat == "detailed" </span><span class="cov0" title="0">{
                return getDetailedValidationMessage(field, tag, param, config)
        }</span>

        // Custom messages in English
        <span class="cov6" title="51">messages := map[string]string{
                "required": "is required",
                "email":    "must be a valid email",
                "min":      fmt.Sprintf("must have at least %s characters", param),
                "max":      fmt.Sprintf("must have at most %s characters", param),
                "len":      fmt.Sprintf("must have exactly %s characters", param),
                "gt":       fmt.Sprintf("must be greater than %s", param),
                "gte":      fmt.Sprintf("must be greater than or equal to %s", param),
                "lt":       fmt.Sprintf("must be less than %s", param),
                "lte":      fmt.Sprintf("must be less than or equal to %s", param),
                "alpha":    "must contain only letters",
                "alphanum": "must contain only letters and numbers",
                "numeric":  "must be a number",
                "url":      "must be a valid URL",
                "phone":    "must be a valid phone number",
                "cpf":      "must be a valid CPF",
                "cnpj":     "must be a valid CNPJ",
                "datetime": "must be a valid date/time",
                "uuid":     "must be a valid UUID",
                "json":     "must be a valid JSON",
        }

        if message, exists := messages[tag]; exists </span><span class="cov6" title="50">{
                return fmt.Sprintf("Field '%s' %s", field, message)
        }</span>

        <span class="cov1" title="1">return fmt.Sprintf("Field '%s' is invalid (%s)", field, tag)</span>
}

// getValidationMessageForParam returns custom error message for path parameters
func getValidationMessageForParam(param, rule, value string, config *ValidationConfig) string <span class="cov0" title="0">{
        // Use custom error format if specified in config
        if config.ErrorFormat == "detailed" </span><span class="cov0" title="0">{
                return getDetailedValidationMessage(param, rule, value, config)
        }</span>

        // Custom messages for path parameters
        <span class="cov0" title="0">messages := map[string]string{
                "required": fmt.Sprintf("Parameter '%s' is required", param),
                "numeric":  fmt.Sprintf("Parameter '%s' must be a number", param),
                "uuid":     fmt.Sprintf("Parameter '%s' must be a valid UUID", param),
                "alpha":    fmt.Sprintf("Parameter '%s' must contain only letters", param),
                "email":    fmt.Sprintf("Parameter '%s' must be a valid email", param),
        }

        if message, exists := messages[rule]; exists </span><span class="cov0" title="0">{
                return message
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("Parameter '%s' does not meet rule '%s'", param, rule)</span>
}

// getDetailedValidationMessage returns detailed validation message using config settings
func getDetailedValidationMessage(field, tag, param string, config *ValidationConfig) string <span class="cov1" title="1">{
        // Use custom translation function if specified
        if config.TranslateFunc != "" </span><span class="cov0" title="0">{
                // In a real implementation, this would call the specified translation function
                return fmt.Sprintf("[%s] Field '%s' failed validation '%s' with param '%s'",
                        config.TranslateFunc, field, tag, param)
        }</span>

        // Return user-friendly messages based on field and tag
        <span class="cov1" title="1">switch tag </span>{
        case "required":<span class="cov1" title="1">
                return fmt.Sprintf("%s is required", field)</span>
        case "email":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid email address", field)</span>
        case "min":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be at least %s characters", field, param)</span>
        case "max":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be at most %s characters", field, param)</span>
        case "gte":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be greater than or equal to %s", field, param)</span>
        case "lte":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be less than or equal to %s", field, param)</span>
        case "gt":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be greater than %s", field, param)</span>
        case "lt":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be less than %s", field, param)</span>
        case "len":<span class="cov0" title="0">
                return fmt.Sprintf("%s must have exactly %s characters", field, param)</span>
        case "alpha":<span class="cov0" title="0">
                return fmt.Sprintf("%s must contain only letters", field)</span>
        case "alphanum":<span class="cov0" title="0">
                return fmt.Sprintf("%s must contain only letters and numbers", field)</span>
        case "numeric":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be numeric", field)</span>
        case "uuid":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid UUID", field)</span>
        case "phone":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid phone number", field)</span>
        case "cpf":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid CPF", field)</span>
        case "cnpj":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid CNPJ", field)</span>
        case "datetime":<span class="cov0" title="0">
                return fmt.Sprintf("%s must be a valid date/time", field)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%s validation failed", field)</span>
        }
}

// validateParamValue validates parameter value based on rule
func validateParamValue(value, rule string) bool <span class="cov4" title="15">{
        // Handle rules with parameters (e.g., "gte=5", "oneof=tech business sports")
        if strings.Contains(rule, "=") </span><span class="cov3" title="10">{
                return validateParamRule(value, rule)
        }</span>

        // Handle simple rules without parameters
        <span class="cov3" title="5">return validateSimpleRule(value, rule)</span>
}

// validateParamRule handles rules with parameters
func validateParamRule(value, rule string) bool <span class="cov3" title="10">{
        parts := strings.SplitN(rule, "=", 2)
        ruleType := parts[0]
        param := parts[1]

        switch ruleType </span>{
        case "gte":<span class="cov2" title="4">
                return validateGreaterThanEqual(value, param)</span>
        case "lte":<span class="cov2" title="4">
                return validateLessThanEqual(value, param)</span>
        case "oneof":<span class="cov1" title="2">
                return validateOneOf(value, param)</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// validateGreaterThanEqual validates if value is greater than or equal to param
func validateGreaterThanEqual(value, param string) bool <span class="cov2" title="4">{
        val, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="4">limit, err := strconv.Atoi(param)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="4">return val &gt;= limit</span>
}

// validateLessThanEqual validates if value is less than or equal to param
func validateLessThanEqual(value, param string) bool <span class="cov2" title="4">{
        val, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="4">limit, err := strconv.Atoi(param)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov2" title="4">return val &lt;= limit</span>
}

// validateOneOf validates if value is one of the options
func validateOneOf(value, param string) bool <span class="cov1" title="2">{
        options := strings.Split(param, " ")
        for _, option := range options </span><span class="cov2" title="4">{
                if value == option </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// validateSimpleRule handles simple rules without parameters
func validateSimpleRule(value, rule string) bool <span class="cov3" title="5">{
        switch rule </span>{
        case "required":<span class="cov2" title="3">
                return value != ""</span>
        case "numeric":<span class="cov0" title="0">
                _, err := strconv.Atoi(value)
                return err == nil</span>
        case "uuid":<span class="cov0" title="0">
                return len(value) == 36 &amp;&amp; strings.Count(value, "-") == 4</span>
        case "alpha":<span class="cov0" title="0">
                return validateAlpha(value)</span>
        case "email":<span class="cov1" title="2">
                return strings.Contains(value, "@") &amp;&amp; strings.Contains(value, ".")</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// validateAlpha validates if string contains only alphabetic characters
func validateAlpha(value string) bool <span class="cov0" title="0">{
        for _, r := range value </span><span class="cov0" title="0">{
                if (r &lt; 'a' || r &gt; 'z') &amp;&amp; (r &lt; 'A' || r &gt; 'Z') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Custom validators

// validatePhone validates Brazilian phone number
func validatePhone(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        phone := fl.Field().String()
        // Remove non-numeric characters
        cleaned := strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(phone, "(", ""), ")", ""), "-", "")
        cleaned = strings.ReplaceAll(strings.ReplaceAll(cleaned, " ", ""), "+55", "")

        // Brazilian phone should have 10 or 11 digits
        return len(cleaned) == 10 || len(cleaned) == 11
}</span>

// validateCPF validates Brazilian CPF
func validateCPF(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        cpf := fl.Field().String()
        // Remove non-numeric characters
        cleaned := strings.ReplaceAll(strings.ReplaceAll(cpf, ".", ""), "-", "")

        if len(cleaned) != 11 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if all digits are equal
        <span class="cov0" title="0">if cleaned == strings.Repeat(string(cleaned[0]), 11) </span><span class="cov0" title="0">{
                return false
        }</span>

        // CPF validation algorithm
        <span class="cov0" title="0">sum := 0
        for i := 0; i &lt; 9; i++ </span><span class="cov0" title="0">{
                digit, _ := strconv.Atoi(string(cleaned[i]))
                sum += digit * (10 - i)
        }</span>

        <span class="cov0" title="0">remainder := sum % 11
        var checkDigit1 int
        if remainder &lt; 2 </span><span class="cov0" title="0">{
                checkDigit1 = 0
        }</span> else<span class="cov0" title="0"> {
                checkDigit1 = 11 - remainder
        }</span>

        <span class="cov0" title="0">if checkDigit1 != int(cleaned[9]-'0') </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">sum = 0
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                digit, _ := strconv.Atoi(string(cleaned[i]))
                sum += digit * (11 - i)
        }</span>

        <span class="cov0" title="0">remainder = sum % 11
        var checkDigit2 int
        if remainder &lt; 2 </span><span class="cov0" title="0">{
                checkDigit2 = 0
        }</span> else<span class="cov0" title="0"> {
                checkDigit2 = 11 - remainder
        }</span>

        <span class="cov0" title="0">return checkDigit2 == int(cleaned[10]-'0')</span>
}

// validateCNPJ validates Brazilian CNPJ
func validateCNPJ(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        cnpj := fl.Field().String()
        // Remove non-numeric characters
        cleaned := strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(cnpj, ".", ""), "/", ""), "-", "")

        if len(cleaned) != 14 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if all digits are equal
        <span class="cov0" title="0">if cleaned == strings.Repeat(string(cleaned[0]), 14) </span><span class="cov0" title="0">{
                return false
        }</span>

        // CNPJ validation algorithm
        <span class="cov0" title="0">weights1 := []int{5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2}
        sum := 0
        for i := 0; i &lt; 12; i++ </span><span class="cov0" title="0">{
                digit, _ := strconv.Atoi(string(cleaned[i]))
                sum += digit * weights1[i]
        }</span>

        <span class="cov0" title="0">remainder := sum % 11
        var checkDigit1 int
        if remainder &lt; 2 </span><span class="cov0" title="0">{
                checkDigit1 = 0
        }</span> else<span class="cov0" title="0"> {
                checkDigit1 = 11 - remainder
        }</span>

        <span class="cov0" title="0">if checkDigit1 != int(cleaned[12]-'0') </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">weights2 := []int{6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2}
        sum = 0
        for i := 0; i &lt; 13; i++ </span><span class="cov0" title="0">{
                digit, _ := strconv.Atoi(string(cleaned[i]))
                sum += digit * weights2[i]
        }</span>

        <span class="cov0" title="0">remainder = sum % 11
        var checkDigit2 int
        if remainder &lt; 2 </span><span class="cov0" title="0">{
                checkDigit2 = 0
        }</span> else<span class="cov0" title="0"> {
                checkDigit2 = 11 - remainder
        }</span>

        <span class="cov0" title="0">return checkDigit2 == int(cleaned[13]-'0')</span>
}

// validateDateTime validates date/time format
func validateDateTime(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        dateTime := fl.Field().String()

        // Formatos aceitos
        formats := []string{
                "2006-01-02T15:04:05Z07:00",
                "2006-01-02T15:04:05",
                "2006-01-02 15:04:05",
                "2006-01-02",
                "15:04:05",
        }

        for _, format := range formats </span><span class="cov0" title="0">{
                if _, err := time.Parse(format, dateTime); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// GetValidatedData extracts validated data from context
func GetValidatedData(c *gin.Context) (interface{}, bool) <span class="cov1" title="1">{
        data, exists := c.Get("validated_data")
        return data, exists
}</span>

// GetValidatedQuery extracts validated query from context
func GetValidatedQuery(c *gin.Context) (interface{}, bool) <span class="cov1" title="1">{
        data, exists := c.Get("validated_query")
        return data, exists
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package decorators

import (
        "fmt"
        "log"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
)

// FileWatcher monitors handler files and automatically regenerates code
type FileWatcher struct {
        config       *Config
        watcher      *fsnotify.Watcher
        watchedFiles map[string]bool
        debouncer    *Debouncer
        isRunning    bool
        mu           sync.RWMutex
}

// Debouncer prevents too frequent regenerations
type Debouncer struct {
        duration time.Duration
        timer    *time.Timer
        mu       sync.Mutex
}

// NewFileWatcher creates a new file watcher
func NewFileWatcher(config *Config) (*FileWatcher, error) <span class="cov9" title="15">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating watcher: %v", err)
        }</span>

        <span class="cov9" title="15">return &amp;FileWatcher{
                config:       config,
                watcher:      watcher,
                watchedFiles: make(map[string]bool),
                debouncer:    NewDebouncer(500 * time.Millisecond), // 500ms debounce
                isRunning:    false,
        }, nil</span>
}

// NewDebouncer creates a new debouncer
func NewDebouncer(duration time.Duration) *Debouncer <span class="cov10" title="17">{
        return &amp;Debouncer{
                duration: duration,
        }
}</span>

// Debounce executes the function after a delay, canceling previous executions
func (d *Debouncer) Debounce(fn func()) <span class="cov4" title="3">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if d.timer != nil </span><span class="cov3" title="2">{
                d.timer.Stop()
        }</span>

        <span class="cov4" title="3">d.timer = time.AfterFunc(d.duration, fn)</span>
}

// Start starts file watching
func (fw *FileWatcher) Start() error <span class="cov5" title="4">{
        if !fw.config.Dev.Watch </span><span class="cov0" title="0">{
                return nil // Watching disabled
        }</span>

        <span class="cov5" title="4">fw.mu.Lock()
        defer fw.mu.Unlock()

        if fw.isRunning </span><span class="cov0" title="0">{
                return nil // Already running
        }</span>

        // Discover files to monitor
        <span class="cov5" title="4">wd, err := filepath.Abs(".")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting current directory: %v", err)
        }</span>

        <span class="cov5" title="4">handlerFiles, err := fw.config.DiscoverHandlers(wd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error discovering handlers: %v", err)
        }</span>

        // Add files to watcher
        <span class="cov5" title="4">for _, file := range handlerFiles </span><span class="cov0" title="0">{
                if err := fw.addFile(file); err != nil </span><span class="cov0" title="0">{
                        log.Printf("⚠️  Error monitoring file %s: %v", file, err)
                }</span>
        }

        // Add directories to watcher
        <span class="cov5" title="4">if err := fw.addDirectories(wd); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error monitoring directories: %v", err)
        }</span>

        <span class="cov5" title="4">fw.isRunning = true

        // Start goroutine to process events
        go fw.watchEvents()

        LogNormal("👀 Monitoring %d files", len(fw.watchedFiles))
        return nil</span>
}

// Stop file watching
func (fw *FileWatcher) Stop() error <span class="cov7" title="7">{
        fw.mu.Lock()
        defer fw.mu.Unlock()

        if !fw.isRunning </span><span class="cov4" title="3">{
                return nil
        }</span>

        <span class="cov5" title="4">fw.isRunning = false

        if fw.debouncer.timer != nil </span><span class="cov0" title="0">{
                fw.debouncer.timer.Stop()
        }</span>

        <span class="cov5" title="4">err := fw.watcher.Close()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error closing watcher: %v", err)
        }</span>

        <span class="cov5" title="4">log.Println("🛑 File watcher stopped")
        return nil</span>
}

// addFile adds a file to the watcher
func (fw *FileWatcher) addFile(file string) error <span class="cov1" title="1">{
        absPath, err := filepath.Abs(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if fw.watchedFiles[absPath] </span><span class="cov0" title="0">{
                return nil // Already being monitored
        }</span>

        <span class="cov1" title="1">dir := filepath.Dir(absPath)
        if err := fw.watcher.Add(dir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">fw.watchedFiles[absPath] = true
        return nil</span>
}

// addDirectories adds directories to the watcher
func (fw *FileWatcher) addDirectories(rootDir string) error <span class="cov6" title="5">{
        // Monitor directories based on include patterns
        for _, pattern := range fw.config.Handlers.Include </span><span class="cov7" title="7">{
                // Extract base directory from pattern
                dir := extractBaseDir(pattern)
                if dir != "" </span><span class="cov7" title="7">{
                        fullPath := filepath.Join(rootDir, dir)
                        if err := fw.watcher.Add(fullPath); err != nil </span><span class="cov7" title="7">{
                                log.Printf("⚠️  Error monitoring directory %s: %v", fullPath, err)
                        }</span>
                }
        }

        <span class="cov6" title="5">return nil</span>
}

// extractBaseDir extracts the base directory from a pattern
func extractBaseDir(pattern string) string <span class="cov7" title="9">{
        // Remove wildcards and return base directory
        parts := strings.Split(pattern, "**")
        if len(parts) &gt; 0 </span><span class="cov7" title="9">{
                base := strings.TrimSuffix(parts[0], "/")
                if base != "" &amp;&amp; !strings.Contains(base, "*") </span><span class="cov5" title="4">{
                        return base
                }</span>
        }

        // Fallback: try to extract first directory without wildcards
        <span class="cov6" title="5">parts = strings.Split(pattern, "/")
        for _, part := range parts </span><span class="cov6" title="5">{
                if !strings.Contains(part, "*") &amp;&amp; part != "" </span><span class="cov6" title="5">{
                        return part
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// watchEvents processes file watcher events
func (fw *FileWatcher) watchEvents() <span class="cov6" title="5">{
        for </span><span class="cov6" title="5">{
                select </span>{
                case event, ok := &lt;-fw.watcher.Events:<span class="cov5" title="4">
                        if !ok </span><span class="cov5" title="4">{
                                return
                        }</span>

                        <span class="cov0" title="0">if fw.shouldProcessEvent(event) </span><span class="cov0" title="0">{
                                log.Printf("📁 File modified: %s", event.Name)
                                fw.debouncer.Debounce(func() </span><span class="cov0" title="0">{
                                        if err := fw.regenerateCode(); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("❌ Error in automatic regeneration: %v", err)
                                        }</span>
                                })
                        }

                case err, ok := &lt;-fw.watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("❌ File watcher error: %v", err)</span>
                }
        }
}

// shouldProcessEvent checks if we should process the event
func (fw *FileWatcher) shouldProcessEvent(event fsnotify.Event) bool <span class="cov0" title="0">{
        // Ignore temporary/irrelevant events
        if strings.HasSuffix(event.Name, "~") ||
                strings.HasSuffix(event.Name, ".tmp") ||
                strings.HasSuffix(event.Name, ".swp") ||
                strings.Contains(event.Name, ".git/") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Process only .go files that match patterns
        <span class="cov0" title="0">if !strings.HasSuffix(event.Name, ".go") </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if file matches include patterns
        <span class="cov0" title="0">wd, err := filepath.Abs(".")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">relPath, err := filepath.Rel(wd, event.Name)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it matches configured patterns
        <span class="cov0" title="0">return fw.matchesIncludePatterns(relPath) &amp;&amp; !fw.matchesExcludePatterns(relPath)</span>
}

// matchesIncludePatterns checks if file matches include patterns
func (fw *FileWatcher) matchesIncludePatterns(relPath string) bool <span class="cov4" title="3">{
        relPath = filepath.ToSlash(relPath)
        for _, pattern := range fw.config.Handlers.Include </span><span class="cov6" title="5">{
                if matched, _ := filepath.Match(pattern, relPath); matched </span><span class="cov3" title="2">{
                        return true
                }</span>
                // Verify patterns with **
                <span class="cov4" title="3">if strings.Contains(pattern, "**") </span><span class="cov0" title="0">{
                        if fw.matchesGlobPattern(relPath, pattern) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov1" title="1">return false</span>
}

// matchesExcludePatterns checks if file matches exclude patterns
func (fw *FileWatcher) matchesExcludePatterns(relPath string) bool <span class="cov4" title="3">{
        relPath = filepath.ToSlash(relPath)
        for _, pattern := range fw.config.Handlers.Exclude </span><span class="cov6" title="5">{
                if matched, _ := filepath.Match(pattern, relPath); matched </span><span class="cov3" title="2">{
                        return true
                }</span>
                // Verify patterns with **
                <span class="cov4" title="3">if strings.Contains(pattern, "**") </span><span class="cov0" title="0">{
                        if fw.matchesGlobPattern(relPath, pattern) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov1" title="1">return false</span>
}

// matchesGlobPattern checks if path matches glob pattern with **
func (fw *FileWatcher) matchesGlobPattern(path, pattern string) bool <span class="cov5" title="4">{
        regex, err := globToRegex(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="4">return regex.MatchString(path)</span>
}

// regenerateCode automatically regenerates the code
func (fw *FileWatcher) regenerateCode() error <span class="cov0" title="0">{
        log.Println("🔄 Automatically regenerating code...")

        // Use default configuration for regeneration
        outputPath := "./.deco/init_decorators.go"
        packageName := "deco"

        wd, err := filepath.Abs(".")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Discover updated handlers
        <span class="cov0" title="0">handlerFiles, err := fw.config.DiscoverHandlers(wd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error discovering handlers: %v", err)
        }</span>

        <span class="cov0" title="0">if len(handlerFiles) == 0 </span><span class="cov0" title="0">{
                log.Println("⚠️  No handlers found for regeneration")
                return nil
        }</span>

        // Generate code with configuration
        <span class="cov0" title="0">rootDir := findCommonRoot(handlerFiles)
        if err := GenerateInitFileWithConfig(rootDir, outputPath, packageName, fw.config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in generation: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("✅ Code regenerated automatically: %s", outputPath)
        return nil</span>
}

// findCommonRoot finds the common root directory of a file list
func findCommonRoot(files []string) string <span class="cov3" title="2">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return "."
        }</span>

        // Take the first file as base
        <span class="cov3" title="2">common := filepath.Dir(files[0])

        // Find common prefix with all others
        for _, file := range files[1:] </span><span class="cov3" title="2">{
                dir := filepath.Dir(file)

                // Find common prefix between common and dir
                for !strings.HasPrefix(dir, common) </span><span class="cov0" title="0">{
                        common = filepath.Dir(common)
                        if common == "." || common == "/" </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov3" title="2">return common</span>
}

// IsRunning returns whether the watcher is running
func (fw *FileWatcher) IsRunning() bool <span class="cov7" title="7">{
        fw.mu.RLock()
        defer fw.mu.RUnlock()
        return fw.isRunning
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package decorators

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/gorilla/websocket"
)

// WebSocketUpgrader configuration for connection upgrade WebSocket
var WebSocketUpgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(_ *http.Request) bool <span class="cov0" title="0">{
                // By default, accept all origins (configurable)
                return true
        }</span>,
}

// WebSocketConnection represents a WebSocket connection
type WebSocketConnection struct {
        ID       string
        Conn     *websocket.Conn
        Send     chan []byte
        Hub      *WebSocketHub
        UserID   string
        Groups   map[string]bool
        Metadata map[string]interface{}
        mu       sync.RWMutex
}

// WebSocketHub manages WebSocket connections
type WebSocketHub struct {
        // Active connections
        connections map[string]*WebSocketConnection

        // Groups of connections
        groups map[string]map[string]*WebSocketConnection

        // Channel for broadcast
        broadcast chan *WebSocketMessage

        // Channel to register connections
        register chan *WebSocketConnection

        // Channel to unregister connections
        unregister chan *WebSocketConnection

        // Mutex for thread safety
        mu sync.RWMutex

        // Configuration
        config WebSocketConfig
}

// WebSocketMessage represents a WebSocket message
type WebSocketMessage struct {
        Type      string                 `json:"type"`
        Data      interface{}            `json:"data"`
        Sender    string                 `json:"sender,omitempty"`
        Target    string                 `json:"target,omitempty"` // ID of specific connection
        Group     string                 `json:"group,omitempty"`  // Group name
        Timestamp time.Time              `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// WebSocketHandler handler type for WebSocket messages
type WebSocketHandler func(conn *WebSocketConnection, message *WebSocketMessage) error

// WebSocketRouter router for WebSocket messages
type WebSocketRouter struct {
        handlers map[string]WebSocketHandler
        mu       sync.RWMutex
}

// Default global hub
var defaultHub *WebSocketHub
var defaultRouter *WebSocketRouter

// InitWebSocket initializes the WebSocket system
func InitWebSocket(config WebSocketConfig) *WebSocketHub <span class="cov6" title="14">{
        // Configure upgrader
        WebSocketUpgrader.ReadBufferSize = config.ReadBuffer
        WebSocketUpgrader.WriteBufferSize = config.WriteBuffer
        WebSocketUpgrader.CheckOrigin = func(_ *http.Request) bool </span><span class="cov1" title="1">{
                return !config.CheckOrigin // If CheckOrigin is false, accept all origins
        }</span>

        <span class="cov6" title="14">hub := &amp;WebSocketHub{
                connections: make(map[string]*WebSocketConnection),
                groups:      make(map[string]map[string]*WebSocketConnection),
                broadcast:   make(chan *WebSocketMessage, 256),
                register:    make(chan *WebSocketConnection),
                unregister:  make(chan *WebSocketConnection),
                config:      config,
        }

        // Start router
        defaultRouter = &amp;WebSocketRouter{
                handlers: make(map[string]WebSocketHandler),
        }

        // Start hub goroutine
        go hub.run()

        // Register default handlers
        RegisterDefaultHandlers()

        defaultHub = hub
        return hub</span>
}

// run executes the main hub loop
func (h *WebSocketHub) run() <span class="cov6" title="14">{
        ticker := time.NewTicker(54 * time.Second) // Ping interval
        defer ticker.Stop()

        for </span><span class="cov8" title="30">{
                select </span>{
                case conn := &lt;-h.register:<span class="cov5" title="9">
                        h.registerConnection(conn)</span>

                case conn := &lt;-h.unregister:<span class="cov2" title="2">
                        h.unregisterConnection(conn)</span>

                case message := &lt;-h.broadcast:<span class="cov4" title="5">
                        h.broadcastMessage(message)</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.pingConnections()</span>
                }
        }
}

// registerConnection registers a new connection
func (h *WebSocketHub) registerConnection(conn *WebSocketConnection) <span class="cov6" title="12">{
        h.mu.Lock()
        defer h.mu.Unlock()

        h.connections[conn.ID] = conn
        log.Printf("WebSocket: New connection registered %s", conn.ID)

        // Send welcome message
        welcome := &amp;WebSocketMessage{
                Type:      "welcome",
                Data:      map[string]string{"connection_id": conn.ID},
                Timestamp: time.Now(),
        }
        conn.Send &lt;- []byte(welcome.ToJSON())
}</span>

// unregisterConnection removes a connection
func (h *WebSocketHub) unregisterConnection(conn *WebSocketConnection) <span class="cov4" title="5">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if _, exists := h.connections[conn.ID]; exists </span><span class="cov4" title="5">{
                // Remove from all groups
                for groupName := range conn.Groups </span><span class="cov1" title="1">{
                        h.leaveGroupUnsafe(conn, groupName)
                }</span>

                <span class="cov4" title="5">delete(h.connections, conn.ID)
                close(conn.Send)
                log.Printf("WebSocket: Connection removed %s", conn.ID)</span>
        }
}

// broadcastMessage sends message to recipients
func (h *WebSocketHub) broadcastMessage(message *WebSocketMessage) <span class="cov4" title="5">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        data := []byte(message.ToJSON())

        // Send directed to specific connection
        if message.Target != "" </span><span class="cov1" title="1">{
                if conn, exists := h.connections[message.Target]; exists </span><span class="cov0" title="0">{
                        select </span>{
                        case conn.Send &lt;- data:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                h.unregisterConnection(conn)</span>
                        }
                }
                <span class="cov1" title="1">return</span>
        }

        // Send to specific group
        <span class="cov4" title="4">if message.Group != "" </span><span class="cov1" title="1">{
                if group, exists := h.groups[message.Group]; exists </span><span class="cov1" title="1">{
                        for _, conn := range group </span><span class="cov2" title="2">{
                                select </span>{
                                case conn.Send &lt;- data:<span class="cov2" title="2"></span>
                                default:<span class="cov0" title="0">
                                        h.unregisterConnection(conn)</span>
                                }
                        }
                }
                <span class="cov1" title="1">return</span>
        }

        // Broadcast to all connections
        <span class="cov3" title="3">for id, conn := range h.connections </span><span class="cov2" title="2">{
                select </span>{
                case conn.Send &lt;- data:<span class="cov2" title="2"></span>
                default:<span class="cov0" title="0">
                        delete(h.connections, id)
                        close(conn.Send)</span>
                }
        }
}

// pingConnections sends ping to all connections
func (h *WebSocketHub) pingConnections() <span class="cov0" title="0">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        for id, conn := range h.connections </span><span class="cov0" title="0">{
                conn.mu.Lock()
                if conn.Conn != nil </span><span class="cov0" title="0">{
                        if err := conn.Conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                log.Printf("WebSocket: Error sending ping to %s: %v", id, err)
                                conn.mu.Unlock()
                                h.unregister &lt;- conn
                                continue</span>
                        }
                }
                <span class="cov0" title="0">conn.mu.Unlock()</span>
        }
}

// JoinGroup adds connection to a group
func (h *WebSocketHub) JoinGroup(connID, groupName string) error <span class="cov4" title="5">{
        h.mu.Lock()
        defer h.mu.Unlock()

        conn, exists := h.connections[connID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("connection %s not found", connID)
        }</span>

        <span class="cov4" title="5">if h.groups[groupName] == nil </span><span class="cov4" title="4">{
                h.groups[groupName] = make(map[string]*WebSocketConnection)
        }</span>

        <span class="cov4" title="5">h.groups[groupName][connID] = conn
        conn.Groups[groupName] = true

        log.Printf("WebSocket: Connection %s joined group %s", connID, groupName)
        return nil</span>
}

// LeaveGroup removes connection from a group
func (h *WebSocketHub) LeaveGroup(connID, groupName string) error <span class="cov2" title="2">{
        h.mu.Lock()
        defer h.mu.Unlock()

        conn, exists := h.connections[connID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("connection %s not found", connID)
        }</span>

        <span class="cov2" title="2">h.leaveGroupUnsafe(conn, groupName)
        return nil</span>
}

// leaveGroupUnsafe removes connection from group (without lock)
func (h *WebSocketHub) leaveGroupUnsafe(conn *WebSocketConnection, groupName string) <span class="cov3" title="3">{
        if group, exists := h.groups[groupName]; exists </span><span class="cov2" title="2">{
                delete(group, conn.ID)
                delete(conn.Groups, groupName)

                // Remove group if empty
                if len(group) == 0 </span><span class="cov2" title="2">{
                        delete(h.groups, groupName)
                }</span>

                <span class="cov2" title="2">log.Printf("WebSocket: Connection %s left group %s", conn.ID, groupName)</span>
        }
}

// Broadcast sends message to all connections
func (h *WebSocketHub) Broadcast(message *WebSocketMessage) <span class="cov2" title="2">{
        message.Timestamp = time.Now()
        h.broadcast &lt;- message
}</span>

// SendToConnection sends message to specific connection
func (h *WebSocketHub) SendToConnection(connID string, message *WebSocketMessage) <span class="cov1" title="1">{
        message.Target = connID
        message.Timestamp = time.Now()
        h.broadcast &lt;- message
}</span>

// SendToGroup sends message to group
func (h *WebSocketHub) SendToGroup(groupName string, message *WebSocketMessage) <span class="cov1" title="1">{
        message.Group = groupName
        message.Timestamp = time.Now()
        h.broadcast &lt;- message
}</span>

// ToJSON converts message to JSON
func (m *WebSocketMessage) ToJSON() string <span class="cov7" title="19">{
        data, _ := json.Marshal(m)
        return string(data)
}</span>

// CreateWebSocketHandler creates handler for WebSocket connections
func CreateWebSocketHandler(config *WebSocketConfig) gin.HandlerFunc <span class="cov3" title="3">{
        if !config.Enabled </span><span class="cov2" title="2">{
                return func(c *gin.Context) </span><span class="cov2" title="2">{
                        c.JSON(http.StatusNotImplemented, gin.H{
                                "error": "WebSocket not enabled",
                        })
                }</span>
        }

        // Initialize hub if it does not exist
        <span class="cov1" title="1">if defaultHub == nil </span><span class="cov0" title="0">{
                InitWebSocket(*config)
        }</span>

        <span class="cov1" title="1">return func(c *gin.Context) </span><span class="cov1" title="1">{
                // Upgrade to WebSocket
                conn, err := WebSocketUpgrader.Upgrade(c.Writer, c.Request, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket: Error during upgrade: %v", err)
                        return
                }</span>

                // Create connection
                <span class="cov1" title="1">wsConn := &amp;WebSocketConnection{
                        ID:       generateConnectionID(),
                        Conn:     conn,
                        Send:     make(chan []byte, 256),
                        Hub:      defaultHub,
                        UserID:   c.GetString("user_id"), // Get from context if authenticated
                        Groups:   make(map[string]bool),
                        Metadata: make(map[string]interface{}),
                }

                // Register connection
                defaultHub.register &lt;- wsConn

                // Start goroutines
                go wsConn.writePump()
                go wsConn.readPump()</span>
        }
}

// readPump processes received messages
func (c *WebSocketConnection) readPump() <span class="cov1" title="1">{
        defer func() </span><span class="cov1" title="1">{
                c.Hub.unregister &lt;- c
                c.Conn.Close()
        }</span>()

        // Configure timeouts
        <span class="cov1" title="1">pongTimeout, _ := time.ParseDuration(c.Hub.config.PongTimeout)
        if err := c.Conn.SetReadDeadline(time.Now().Add(pongTimeout)); err != nil </span><span class="cov0" title="0">{
                log.Printf("WebSocket: Error setting read deadline: %v", err)
        }</span>
        <span class="cov1" title="1">c.Conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                if err := c.Conn.SetReadDeadline(time.Now().Add(pongTimeout)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket: Error setting read deadline in pong handler: %v", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov1" title="1">for </span><span class="cov1" title="1">{
                _, messageBytes, err := c.Conn.ReadMessage()
                if err != nil </span><span class="cov1" title="1">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                log.Printf("WebSocket: Error: %v", err)
                        }</span>
                        <span class="cov1" title="1">break</span>
                }

                // Parse the message
                <span class="cov0" title="0">var message WebSocketMessage
                if err := json.Unmarshal(messageBytes, &amp;message); err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket: Error parsing message: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">message.Sender = c.ID
                message.Timestamp = time.Now()

                // Process with router
                if defaultRouter != nil </span><span class="cov0" title="0">{
                        defaultRouter.HandleMessage(c, &amp;message)
                }</span>
        }
}

// writePump sends messages to client
func (c *WebSocketConnection) writePump() <span class="cov1" title="1">{
        pingInterval, _ := time.ParseDuration(c.Hub.config.PingInterval)
        ticker := time.NewTicker(pingInterval)
        defer func() </span><span class="cov1" title="1">{
                ticker.Stop()
                c.Conn.Close()
        }</span>()

        <span class="cov1" title="1">for </span><span class="cov2" title="2">{
                select </span>{
                case message, ok := &lt;-c.Send:<span class="cov2" title="2">
                        if err := c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil </span><span class="cov0" title="0">{
                                log.Printf("WebSocket: Error setting write deadline: %v", err)
                        }</span>
                        <span class="cov2" title="2">if !ok </span><span class="cov1" title="1">{
                                if err := c.Conn.WriteMessage(websocket.CloseMessage, []byte{}); err != nil </span><span class="cov1" title="1">{
                                        log.Printf("WebSocket: Error writing close message: %v", err)
                                }</span>
                                <span class="cov1" title="1">return</span>
                        }

                        <span class="cov1" title="1">c.mu.Lock()
                        err := c.Conn.WriteMessage(websocket.TextMessage, message)
                        c.mu.Unlock()
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := c.Conn.SetWriteDeadline(time.Now().Add(10 * time.Second)); err != nil </span><span class="cov0" title="0">{
                                log.Printf("WebSocket: Error setting write deadline for ping: %v", err)
                        }</span>
                        <span class="cov0" title="0">c.mu.Lock()
                        err := c.Conn.WriteMessage(websocket.PingMessage, nil)
                        c.mu.Unlock()
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// RegisterHandler registers handler for message type
func (r *WebSocketRouter) RegisterHandler(messageType string, handler WebSocketHandler) <span class="cov10" title="61">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.handlers[messageType] = handler
}</span>

// HandleMessage processes message using registered handlers
func (r *WebSocketRouter) HandleMessage(conn *WebSocketConnection, message *WebSocketMessage) <span class="cov0" title="0">{
        r.mu.RLock()
        handler, exists := r.handlers[message.Type]
        r.mu.RUnlock()

        if exists </span><span class="cov0" title="0">{
                if err := handler(conn, message); err != nil </span><span class="cov0" title="0">{
                        log.Printf("WebSocket: Handler error %s: %v", message.Type, err)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("WebSocket: Handler not found for type %s", message.Type)
        }</span>
}

// generateConnectionID generates unique ID for connection
func generateConnectionID() string <span class="cov4" title="4">{
        return fmt.Sprintf("conn_%d", time.Now().UnixNano())
}</span>

// Default handlers

// JoinGroupHandler handler to join group
func JoinGroupHandler(conn *WebSocketConnection, message *WebSocketMessage) error <span class="cov1" title="1">{
        if data, ok := message.Data.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                if groupName, ok := data["group"].(string); ok </span><span class="cov1" title="1">{
                        return conn.Hub.JoinGroup(conn.ID, groupName)
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("group not specified")</span>
}

// LeaveGroupHandler handler to leave group
func LeaveGroupHandler(conn *WebSocketConnection, message *WebSocketMessage) error <span class="cov1" title="1">{
        if data, ok := message.Data.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                if groupName, ok := data["group"].(string); ok </span><span class="cov1" title="1">{
                        return conn.Hub.LeaveGroup(conn.ID, groupName)
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("group not specified")</span>
}

// EchoHandler echo handler for testing
func EchoHandler(conn *WebSocketConnection, message *WebSocketMessage) error <span class="cov1" title="1">{
        response := &amp;WebSocketMessage{
                Type:      "echo",
                Data:      message.Data,
                Timestamp: time.Now(),
        }
        conn.Send &lt;- []byte(response.ToJSON())
        return nil
}</span>

// BroadcastHandler handler for broadcast
func BroadcastHandler(conn *WebSocketConnection, message *WebSocketMessage) error <span class="cov1" title="1">{
        message.Sender = conn.ID
        conn.Hub.Broadcast(message)
        return nil
}</span>

// RegisterDefaultHandlers registers default handlers
func RegisterDefaultHandlers() <span class="cov6" title="15">{
        if defaultRouter == nil </span><span class="cov0" title="0">{
                defaultRouter = &amp;WebSocketRouter{
                        handlers: make(map[string]WebSocketHandler),
                }
        }</span>

        <span class="cov6" title="15">defaultRouter.RegisterHandler("join_group", JoinGroupHandler)
        defaultRouter.RegisterHandler("leave_group", LeaveGroupHandler)
        defaultRouter.RegisterHandler("echo", EchoHandler)
        defaultRouter.RegisterHandler("broadcast", BroadcastHandler)</span>
}

// RegisterDefaultWebSocketHandlers is a public alias for RegisterDefaultHandlers
func RegisterDefaultWebSocketHandlers() <span class="cov1" title="1">{
        RegisterDefaultHandlers()
}</span>

// RegisterWebSocketHandler allows applications to register custom WebSocket handlers
func RegisterWebSocketHandler(messageType string, handler WebSocketHandler) <span class="cov1" title="1">{
        if defaultRouter == nil </span><span class="cov0" title="0">{
                defaultRouter = &amp;WebSocketRouter{
                        handlers: make(map[string]WebSocketHandler),
                }
        }</span>
        <span class="cov1" title="1">defaultRouter.RegisterHandler(messageType, handler)</span>
}

// GetWebSocketHub returns the default WebSocket hub for direct access
func GetWebSocketHub() *WebSocketHub <span class="cov1" title="1">{
        return defaultHub
}</span>

// GetWebSocketInfo returns information about WebSocket
func GetWebSocketInfo(config WebSocketConfig) map[string]interface{} <span class="cov1" title="1">{
        info := map[string]interface{}{
                "enabled":       config.Enabled,
                "read_buffer":   config.ReadBuffer,
                "write_buffer":  config.WriteBuffer,
                "check_origin":  config.CheckOrigin,
                "compression":   config.Compression,
                "ping_interval": config.PingInterval,
                "pong_timeout":  config.PongTimeout,
        }

        if defaultHub != nil </span><span class="cov1" title="1">{
                defaultHub.mu.RLock()
                info["active_connections"] = len(defaultHub.connections)
                info["active_groups"] = len(defaultHub.groups)
                defaultHub.mu.RUnlock()
        }</span>

        <span class="cov1" title="1">return info</span>
}

// WebSocketStatsHandler handler for WebSocket statistics
func WebSocketStatsHandler() gin.HandlerFunc <span class="cov3" title="3">{
        return func(c *gin.Context) </span><span class="cov3" title="3">{
                if defaultHub == nil </span><span class="cov2" title="2">{
                        c.JSON(http.StatusOK, gin.H{
                                "websocket": "not_initialized",
                        })
                        return
                }</span>

                <span class="cov1" title="1">defaultHub.mu.RLock()
                stats := map[string]interface{}{
                        "active_connections": len(defaultHub.connections),
                        "active_groups":      len(defaultHub.groups),
                        "groups":             make(map[string]int),
                }

                for groupName, group := range defaultHub.groups </span><span class="cov1" title="1">{
                        stats["groups"].(map[string]int)[groupName] = len(group)
                }</span>
                <span class="cov1" title="1">defaultHub.mu.RUnlock()

                c.JSON(http.StatusOK, gin.H{
                        "websocket_stats": stats,
                })</span>
        }
}

// WebSocketHandlerWrapper converts a WebSocketHandler to gin.HandlerFunc, allowing customization
func WebSocketHandlerWrapper(handler WebSocketHandler) gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Example: customization - connection logging
                connID := c.Query("conn_id")
                if connID == "" </span><span class="cov0" title="0">{
                        connID = "anonymous"
                }</span>
                // Create a fake connection for example
                <span class="cov0" title="0">conn := &amp;WebSocketConnection{ID: connID}
                msg := &amp;WebSocketMessage{Type: "connect", Data: nil}
                if err := handler(conn, msg); err != nil </span><span class="cov0" title="0">{
                        c.JSON(500, gin.H{"error": err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(200, gin.H{
                        "message": "WebSocket handler executed successfully",
                        "conn_id": connID,
                })</span>
        }
}

// CustomCheckOrigin allows customizable origin checking via parameter
func CustomCheckOrigin(allowedOrigins []string) func(r *http.Request) bool <span class="cov3" title="3">{
        return func(r *http.Request) bool </span><span class="cov3" title="3">{
                origin := r.Header.Get("Origin")
                if len(allowedOrigins) == 0 </span><span class="cov0" title="0">{
                        return true // Accept all if not specified
                }</span>
                <span class="cov3" title="3">for _, ao := range allowedOrigins </span><span class="cov4" title="5">{
                        if origin == ao </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
                <span class="cov2" title="2">return false</span>
        }
}

// Usage example: WebSocketUpgrader.CheckOrigin = CustomCheckOrigin([]string{"https://mysite.com"})
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
